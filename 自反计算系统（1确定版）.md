### **引言：研究动机与设计哲学**

在计算理论中，一个深刻且持久的问题涉及自反计算（reflective computation）的界限：即一个系统能够修改自身定义或规则的计算模型。当一个形式系统可以不受约束地修改自身时，它通常会立即获得图灵完备的全部能力，也因此继承了其固有的不可判定性问题（如停机问题）。这给分析此类系统的长期行为带来了根本性的困难。

本研究纲领旨在探索这一领域的边界。我们提出一个核心问题：**在一个规则和数据共存于同一语法领域的自反计算模型中，需要施加何种仅依赖于规则来源位置和应用位置在项中相对关系的约束，才能恢复其演化行为的可分析性？**

为了隔离和研究结构约束的作用，我们构建了一个**由单一项的结构内规则驱动的项重写演化系统**。该系统是一个单一、扁平、一阶的形式系统，有意地放弃了传统模型中用于保证健全性的元层/对象层分离。这种设计的价值在于，它使我们能够隔离并精确研究“结构约束”本身在驯服自反计算复杂性中的作用。我们提出的“分层重写”假设，正是此类内在约束的一个具体候选：它将在系统演化中引入一个纯粹基于语法位置的限制，我们猜想这一限制足以恢复系统的可分析性（具体表现为终止性与不动点可判定性）。

虽然对这类基础模型的深刻理解，可能是未来设计更可靠、可预测的自适应系统的理论前提之一，但本研究的直接焦点是严格的形式化调查：探索一个自反项重写系统的计算属性，并划定其可判定与不可判定行为之间的界限。

### **1. 语法：项代数与规范项**

我们首先定义构成我们形式世界的语法对象。设 `V` 是一个可数的变量集合。所有项的宇宙是在签名 `Σ` 上以变量集 `V` 为基础构建的自由项代数 `T_Σ(V)`。

**签名 (Signature) `Σ`:**
`Σ` 包含以下构造器：
*   `equiv: Term × Term → Term` （二元，等价断言构造器）
*   `rewrite: Term × Term → Term` （二元，重写规则构造器）
*   `tuple_n: Termⁿ → Term` for each n ≥ 0 （n元组构造器）
    (我们常用 `(t₁, ..., tₙ)` 表示 `tuple_n(t₁, ..., tₙ)`)。

**项集 (Set of Terms) `T_Σ(V)`:**
`T_Σ(V)` 是在签名 `Σ` 上以变量集 `V` 为基础的最小集合。**基项 (Ground Terms)** 的集合 `T_Σ` 是 `T_Σ(V)` 中不含任何变量的项的子集。

**规范项 (Specification Term):**
一个形式系统由一个称为“规范项”的特殊项 `T` 来指定。`T` 必须是一个**含变量的项 (`T ∈ T_Σ(V)`)**，但需满足以下**关键约束**:

**变量约束 (Variable Scoping Constraint):** `T` 中的任何变量 `v ∈ V` 必须仅出现在形式为 `rewrite(l, r)` 的子项的 `l` 或 `r` 部分。这意味着，如果一个位置 `p` 不是任何 `rewrite` 子项内部（即 `l` 或 `r`）的前缀，那么子项 `T|ₚ` 必须是一个基项（`T|ₚ ∈ T_Σ`）。

这个约束形式化了一个核心思想：变量仅用于定义具有模式匹配能力的“规则”，而系统的“数据”部分（即规则之外的所有结构）必须是具体的、不含变量的基项。

### **2. 语义：从规范项中提取规则**

一个规范项 `T` 的语义由其所有子项决定。为了进行分析，我们可以提取其中包含的规则和公理。

*   **重写规则集 (Rewrite Rules - for analysis only):**
    `R(T) = { s → t | rewrite(s, t) ∈ Sub(T) }`
    其中 `Sub(T)` 是 `T` 的所有子项的集合，`s, t ∈ T_Σ(V)`。
    **重要注记**: `R(T)` 是一个丢失了规则来源位置信息的集合，仅用于静态分析。系统的动态演化（见第4节）将直接操作项 `T` 的结构，以避免歧义。

*   **等价公理集 (Equivalence Axioms):**
    `E(T) = { (s, t) | equiv(s, t) ∈ Sub(T) }`
    其中 `s, t ∈ T_Σ(V)`。

### **3. 核心演绎系统与分阶段研究计划**

在一般情况下，由 `E(T)` 生成的等价关系 `≡_T` 可能会导致其字词问题（word problem）不可判定。这意味着，检查一个任意规则 `l → r` 是否满足 `l ≢_T r`（相干性）本身就是一个不可判定的问题。因此，一个依赖于这种检查作为前提的理论框架是无法成立的。

为了建立一个坚实的理论基础，我们采取**分阶段的研究策略**。

#### **阶段一：核心系统 (The Core System)**

在研究的第一阶段，我们**限制规范项 `T` 不包含任何 `equiv` 子项**，即 `E(T) = ∅`。我们称此类系统为**核心系统**。
在此约束下：
1.  **等价关系是平凡的**: `≡_T` 退化为**语法恒等 (` = `)**。这是一个可判定的关系。
2.  **重写关系是标准的**: 模等价重写 `→_{T/E}` 退化为标准的一阶项重写 `→_R(T)`。

**定义 (标准重写关系 `→_R(T)`)**
`s →_R(T) t` 当且仅当存在规则 `l → r ∈ R(T)`，位置 `p` 和替换 `σ: V → T_Σ`，使得 `s|ₚ = σ(l)` 且 `t = s[σ(r)]ₚ`。

本研究纲领的其余部分将首先聚焦于对这个**核心系统**的分析。

#### **阶段二：扩展至可判定的等价理论**

在对核心系统有了深入理解之后，研究的第二阶段将是谨慎地重新引入 `equiv` 项。我们将研究那些能保证 `≡_T` 的字词问题是**可判定的**规范项子类。一个自然的的起点是限制 `E(T)` 只能包含**基项公理**（即公理中的项不含变量），因为此类等式理论的字词问题是可判定的。

### **4. 动态演化：单步变换**

在本框架的核心系统 (`E(T)=∅`) 中，我们将规范项 `T` 自身视为其所指定的重写系统 `→_R(T)` 的作用对象。演化是确定性的，由一个单步变换函数 `Step` 定义。

**定义 (单步演化函数 `Step`)**
`Step: T_Σ(V) → T_Σ(V)` 是一个确定性函数。其计算过程如下：

1.  **确定所有重写实例**: 首先，我们构造 `T` 中所有可能的重写实例（redex）的集合，记为 `RedexInst(T)`。一个**重写实例**是一个良定义的四元组 `(p, p_rule, l→r, σ)`，其中：
    *   `p_rule` 是规则在 `T` 中的**来源位置** (source position)。
    *   `p` 是规则在 `T` 中的**应用位置** (application position)。
    *   `l→r` 是被应用的规则。
    *   `σ` 是匹配的替换。

    `RedexInst(T)` 的构造如下：
    初始化 `RedexInst(T) = ∅`。
    遍历 `T` 中所有的位置 `p_rule`：
      如果子项 `T|{p_rule}` 的形式为 `rewrite(l, r)` (其中 `l, r ∈ T_Σ(V)`):
        则遍历 `T` 中所有的位置 `p`：
          根据**变量约束**，应用位置 `p` 处的子项 `T|p` 必须是**基项**。
          如果存在一个**基替换 (ground substitution)** `σ: V → T_Σ` 使得 `T|p = σ(l)`：
            则将四元组 `(p, p_rule, l→r, σ)` 添加到 `RedexInst(T)` 中。
    （注：检查 `T|p = σ(l)` 是否成立是一个标准的一阶匹配问题，它是可判定的。）

2.  **确定性选择**: 如果 `RedexInst(T)` 为空，则 `Step(T) = T`。否则，应用一个确定的选择函数 `Select` 从中选择一个唯一的、最小的重写实例。
    *   **选择策略 `Select`**: `Select` 函数的定义基于对重写实例的良序。令 `i₁ = (p₁, p_rule₁, l₁→r₁, σ₁)` 和 `i₂ = (p₂, p_rule₂, l₂→r₂, σ₂)` 为两个重写实例。我们定义序关系 `≺_select` 如下：
        `i₁ ≺_select i₂` 当且仅当偶对 `(p₁, p_rule₁)` 在字典序上小于 `(p₂, p_rule₂)`。
        也就是说，我们首先比较重写发生的应用位置 `p` 的字典序；如果位置相同（`p₁ = p₂`），则我们比较规则的来源位置 `p_rule` 的字典序作为决胜者。
    *   `Select` 函数选择 `RedexInst(T)` 中关于 `≺_select` 的最小元素。由于位置的字典序是良序，这个最小元素总是唯一存在的。我们将其记为 `(p*, p*_rule, l*→r*, σ*)`。

3.  **应用变换**: `Step(T) = T[σ*(r*)]_{p*}`。
    （注：由于 `σ*` 是一个基替换，`σ*(r*)` 是一个基项。因此，变换过程是用一个基项替换另一个基项，这保持了**变量约束**的有效性。）

系统的演化被建模为离散序列 `T₀, T₁, T₂, ...`，其中 `T₀` 是初始规范项，且 `T_{n+1} = Step(T_n)`。

### **5. 核心假设与研究方向 (针对核心系统)**

我们的研究计划由以下针对核心系统 (`E(T)=∅`) 的具体、可检验的假设驱动。

*   **分层重写 (Stratified Rewriting):**
    *   我们定义 `p_a ≺ p_b` 当且仅当位置 `p_a` 是位置 `p_b` 的一个真前缀。一个**分层`Step`函数** `Step_strat` 被定义为 `Step` 的一个变体，其 `Select` 函数仅在 `RedexInst(T)` 的一个子集上操作：
        `RedexInst_strat(T) = { (p, p_rule, l→r, σ) ∈ RedexInst(T) | p_rule ≺ p }`
        这个约束形式化了“规则只能重写其自身定义之外（即更深层）的项”这一直觉。
#### **5.1 核心假设与终止性证明**

##### **假设 A (已证伪)(分层终止性)**

对于任何不含 `equiv` 子项的规范项 `T`，其上的**分层重写**演化序列 `T₀, T₁, ...` 其中 `T_{i+1} = Step_strat(T_i)` 必然终止。

##### **非终止性反例：一个三步循环**

我们将构造一个初始规范项 `T₀`，其演化序列 `T₀, T₁, T₂, ...` 将进入一个 `T₃, T₄, T₅, ...` 的循环，导致系统永不终止。

###### **1. 初始规范项的构造**

设初始规范项 `T₀` 如下：
`T₀ = tuple( rule_A, rule_B, rule_C, target )`

其中：
*   **规则 (Rules):**
    *   `rule_A = rewrite(a, c)`  (在位置 `<0>`)
    *   `rule_B = rewrite(b, a)`  (在位置 `<1>`)
    *   `rule_C = rewrite(c, b)`  (在位置 `<2>`)

*   **目标 (Target):**
    *   `target = b`             (在位置 `<3>`)

* `a`, `b`, `c` 是无参数的构造器（常量）。

###### **2. 演化过程的逐步分析**

我们将追踪 `min_inst(T_n)` 的演化，即在每一步被 `Select` 函数选择的、字典序最小的有效实例偶对 `(p, p_rule)`。

---

**第 0 步: 状态 `T₀`**

*   `T₀ = tuple( rewrite(a, c), rewrite(b, a), rewrite(c, b), b )`
*   **有效重写实例分析**:
    *   将 `rule_A` (`a→c`) 应用于 `target` (`b`)：不匹配。
    *   将 `rule_B` (`b→a`) 应用于 `target` (`b`)：**匹配**。实例偶对为 `(<3>, <1>)`。
    *   将 `rule_C` (`c→b`) 应用于 `target` (`b`)：不匹配。
*   **确定性选择**:
    *   `T₀` 中唯一的有效分层实例是 `(<3>, <1>)`。
    *   `min_inst(T₀) = (<3>, <1>)`。
*   **动作**: 在位置 `<3>` 应用规则 `rule_B`。

**演化 ⟶ `T₁ = Step_strat(T₀)`**

---

**第 1 步: 状态 `T₁`**

*   `T₁ = tuple( rewrite(a, c), rewrite(b, a), rewrite(c, b), a )`
*   **有效重写实例分析**:
    *   将 `rule_A` (`a→c`) 应用于 `target` (`a`)：**匹配**。实例偶对为 `(<3>, <0>)`。
    *   将 `rule_B` (`b→a`) 应用于 `target` (`a`)：不匹配。
    *   将 `rule_C` (`c→b`) 应用于 `target` (`a`)：不匹配。
*   **确定性选择**:
    *   `T₁` 中唯一的有效分层实例是 `(<3>, <0>)`。
    *   `min_inst(T₁) = (<3>, <0>)`。
*   **动作**: 在位置 `<3>` 应用规则 `rule_A`。

**演化 ⟶ `T₂ = Step_strat(T₁)`**

---

**第 2 步: 状态 `T₂`**

*   `T₂ = tuple( rewrite(a, c), rewrite(b, a), rewrite(c, b), c )`
*   **有效重写实例分析**:
    *   将 `rule_A` (`a→c`) 应用于 `target` (`c`)：不匹配。
    *   将 `rule_B` (`b→a`) 应用于 `target` (`c`)：不匹配。
    *   将 `rule_C` (`c→b`) 应用于 `target` (`c`)：**匹配**。实例偶对为 `(<3>, <2>)`。
*   **确定性选择**:
    *   `T₂` 中唯一的有效分层实例是 `(<3>, <2>)`。
    *   `min_inst(T₂) = (<3>, <2>)`。
*   **动作**: 在位置 `<3>` 应用规则 `rule_C`。

**演化 ⟶ `T₃ = Step_strat(T₂)`**

---

**第 3 步: 状态 `T₃`**

*   `T₃ = tuple( rewrite(a, c), rewrite(b, a), rewrite(c, b), b )`
*   **观察**: 我们发现 `T₃` 与 `T₀` 的结构完全相同。
*   **有效重写实例分析**: 与 `T₀` 完全相同。
*   **确定性选择**:
    *   `min_inst(T₃) = (<3>, <1>)`。
*   **动作**: 在位置 `<3>` 应用规则 `rule_B`。

**演化 ⟶ `T₄ = Step_strat(T₃)`**
`T₄` 将会与 `T₁` 相同，以此类推。系统进入了一个周期为 3 的循环：`T₀ → T₁ → T₂ → T₀ → ...`

###### **3. 演化总结**

| 步骤 n | 演化后的状态 `T_n` | 有效实例偶对集合 | `min_inst(T_n)` | 备注 |
|---|---|---|---|---|
| 0 | `...tuple(..., b)` | `{ (<3>, <1>) }` | `(<3>, <1>)` | 初始状态 |
| 1 | `...tuple(..., a)` | `{ (<3>, <0>) }` | `(<3>, <0>)` | `min_inst` 序列**递减** |
| 2 | `...tuple(..., c)` | `{ (<3>, <2>) }` | `(<3>, <2>)` | `min_inst` 序列**递增** |
| 3 | `...tuple(..., b)` | `{ (<3>, <1>) }` | `(<3>, <1>)` | **循环开始** (`T₃ = T₀`) |
| 4 | `...tuple(..., a)` | `{ (<3>, <0>) }` | `(<3>, <0>)` | `T₄ = T₁` |

###### **4. 失败机制分析**

这个反例清晰地展示了终止性假设的证明思路为何失败。失败的核心在于**“远距离激活”（Action at a Distance）**破坏了 `min_inst(T_n)` 序列的单调性。

1.  **错误的假设**:  `min_inst(T_{n+1})` 必须大于 `min_inst(T_n)`的假设是错误的。它认为，要激活一个字典序更小的实例，必须首先执行一个字典序更小的重写，而这与 `Select` 的最小性选择相矛盾。

2.  **现实情况**: 这个反例显示，执行一个字典序**较大**的重写（`min_inst(T₀) = (<3>, <1>)`）完全可以创造出使一个字典序**更小**的实例（`(<3>, <0>)`）变得有效的条件。
    *   在 `T₀` 时，实例 `(<3>, <0>)` 是潜在的、更高优先级的任务，但因不匹配而“休眠”。
    *   系统完全按照规则，执行了当时唯一可用的、优先级较低的任务 `(<3>, <1>)`。
    *   这次合法的、短视的重写，其后果（将 `b` 变为 `a`）恰好“唤醒”了那个休眠的高优先级任务。
    *   因此，在 `T₁` 时，`min_inst(T₁)` 变为了 `(<3>, <0>)`，导致 `min_inst(T₁) <_lex min_inst(T₀)`。

3.  **结论**: `min_inst` 序列 `(<3>, <1>)`, `(<3>, <0>)`, `(<3>, <2>)`, `(<3>, <1>)`, ... 在字典序上并非单调递增。由于实例偶对的集合不是一个良基序（well-founded order）下的“进度度量”（progress measure），系统无法保证终止。这个精心构造的 `b → a → c → b` 的循环，正是利用了这种非单调性，证明了即使在分层约束下，本系统也非必然终止，从而证伪了最初的假设A。

##### **假设 B (分层不动点可判定性)**
对于任何不含 `equiv` 子项的规范项 `T`，其在**分层重写**下的不动点问题 `Step_strat(T) = T` 是**可判定的**。

*   *研究路线：* 此假设的正确性基于对不动点条件的分析。`Step_strat(T) = T` 当且仅当 `RedexInst_strat(T)` 为空。要判断此集合是否为空，需要遍历 `T` 的所有位置对 `(p, p_rule)`，检查是否存在分层匹配 `T|p = σ(l)` (其中 `rewrite(l,r) = T|p_rule` 且 `p_rule ≺ p`)。由于 `T` 是一个有限项，位置对的数量是有限的；对于每一个位置对，检查是否存在匹配 `σ` 是一个可判定的一阶匹配问题。因此，整个过程是可判定的。

### **6. 证明：本系统的图灵完备性**

本框架的图灵完备性可以在核心系统（`E(T)=∅`）内被证明。其对组合子逻辑的编码不依赖任何 `equiv` 项。

*   **编码**: 我们将组合子 `S` 和 `K` 编码为常量基项，例如 `S_term := tuple(0)` 和 `K_term := tuple(1)`。应用 `(P Q)` 编码为 `tuple(P', Q')`。
*   **规则**: `S` 和 `K` 的归约规则编码为两个 `rewrite` 项，使用系统变量 `v_x, v_y, v_z`：
    *   `rule_S := rewrite( tuple(tuple(tuple(S_term, v_x), v_y), v_z), tuple(tuple(v_x, v_z), tuple(v_y, v_z)) )`
    *   `rule_K := rewrite( tuple(tuple(K_term, v_x), v_y), v_x )`
*   **规范项**: 令 `T_CL := tuple(rule_S, rule_K)`。这是一个基项。
*   **模拟**: `E_{T_{CL}}` 是空集，因此 `≡_{T_{CL}}` 是语法恒等。任何组合子逻辑中的基项归约序列，都可以在本系统中找到一条对应的归约路径。

**关于确定性的澄清与完备性论证：**
必须指出，组合子逻辑的归约通常是非确定性的，而我们的 `Step` 函数是确定性的，它通过 `≺_select` 字典序选择策略来强制执行一个单一的归约路径。然而，这并未丧失通用计算能力。这是因为对于组合子逻辑，存在标准的确定性归约策略（如“左外最优先”策略）同样是图灵完备的。我们的 `≺_select` 策略，通过优先选择字典序最小的应用位置 `p`，实现了这样一种固定的、确定的归约顺序。我们断言，这种确定性策略足以模拟任何通用计算。例如，对 `((SK)K)x` 的编码项的重写，将忠实地遵循由 `≺_select` 决定的那条归约路径，而该路径本身就代表了一个有效的计算过程。

**结论**: 由于我们可以将图灵完备的组合子逻辑编码到核心系统中，并通过一个确定的、足以保证通用性的归约策略来执行它，我们提出的形式系统是**图灵完备的**。这突显了不受约束的自修改的内在复杂性，并强调了研究可判定子类（如通过分层约束定义的子类）的必要性。

### **7. 相关工作与技术分野**

本框架通过其**一阶、结构敏感、顺序演化**的特性，在自反计算模型的设计空间中占据了一个明确的位置。

*   **与 Maude / 反射逻辑 的对比**: Maude通过元层分离提供了一种基于类型或层次的全局约束，这对于构建强大的、可分析的系统至关重要。我们的框架则采取了不同的研究策略：我们移除了这个“外部守护者”，以直接研究**内在的、结构性的**约束如何影响计算行为。我们用一个纯粹基于语法结构位置的局部约束 (`p_rule ≺ p`)，取代了基于类型或层次的全局约束（元层分离），并猜想这个更精细的局部约束是否足以恢复系统的可分析性。因此，本框架并非要取代分层模型，而是对其进行理论补充，旨在探索自反计算的另一个可能。

*   **与 CHAM / Gamma 范式 的对比**: 本框架关注的是设计空间中的另一极：演化发生在一个具有刚性树状结构的**单一项** `T` 上。重写是**结构敏感**且**顺序**的。

*   **与 高阶项重写系统 (HORS) 的对比**: 本框架是一个**使用一阶语法**来编码**高阶自反行为**的系统，使我们能够专注于由项的结构和一阶规则驱动的自反性。

### **总结**

本纲领设置了一个分阶段的研究计划，旨在探索自反计算模型中结构约束与可判定性之间的关系。它首先定义了一个可判定的、图灵完备的**核心系统**，并围绕它提出了具体的、可检验的假设。我们关注计算理论中最基本的属性——终止性和不动点可判定性——以此作为系统“可分析性”的形式化代理指标。这项工作旨在为“由单一项的结构内规则驱动的项重写演化系统”这一基础计算模型提供一个坚实的理论起点和清晰的未来路线图。通过理解这些极简模型中可计算性的边界，我们希望为更广泛的计算理论领域贡献新的工具与见解。

### **8. 阶段二的初步设想一：凭证式重写**

我们可以如下定义一个单步演化函数 `Step_witnessed`。

**定义 (凭证式重写实例)**
一个**凭证式重写实例**是一个良定义的五元组 `(p_app, p_rule, p_equiv, l→r, σ)`，其中：
*   `p_rule` 是规则 `rewrite(l,r)` 在规范项 `T` 中的来源位置。
*   `p_app` 是被重写的**目标子项** `a = T|{p_app}` 的位置。
*   `p_equiv` 是作为**重写凭证**的等价断言 `equiv(t₁, t₂)` 在 `T` 中的位置。
*   `l→r` 是被应用的规则。
*   `σ` 是一个基替换 (ground substitution)。

这五者必须满足以下**匹配条件**:
`σ(l)` 与 `t₁` 语法相同 (` = `)，且目标子项 `a` 与 `t₂` 语法相同 (` = `)。
（或反之，`σ(l) = t₂` 且 `a = t₁`，因为 `equiv` 是对称的）。

**定义 (单步演化函数 `Step_witnessed`)**
`Step_witnessed: T_Σ(V) → T_Σ(V)` 的计算过程如下：

1.  **确定所有实例**: 构造所有满足上述条件的凭证式重写实例的集合，记为 `RedexInst_witnessed(T)`。

2.  **确定性选择**: 如果 `RedexInst_witnessed(T)` 为空，则 `Step_witnessed(T) = T`。否则，应用一个确定的选择函数 `Select_witnessed` 从中选择一个唯一的、最小的实例。
    *   **选择策略 `Select_witnessed`**: 我们需要为实例五元组定义一个良序。一个自然的选择是基于位置的字典序：
        `Select_witnessed` 选择 `RedexInst_witnessed(T)` 中关于三元组 `(p_app, p_rule, p_equiv)` **字典序**最小的元素。我们将其记为 `(p*_app, p*_rule, p*_equiv, l*→r*, σ*)`。

3.  **应用变换**: `Step_witnessed(T) = T[σ*(r*)]_{p*_app}`。即，用 `σ*(r*)` 替换位置 `p*_app` 处的子项 `a`。

---
### **9. 阶段二的初步设想二：推论式重写**

**约束 (基项公理约束 - Ground Axiom Constraint):**
一个规范项`T`若要进入推论式重写阶段，其包含的任何形式为`equiv(s, t)`的子项，都必须满足`s`和`t`是**基项 (ground terms)**，即`s, t ∈ T_Σ`。

此约束是保证后续步骤可判定性的基石。

**定义 (动态等价关系 `≡_T`)**
对于一个给定的规范项`T`，其动态等价关系`≡_T`的构建过程如下：

1.  **公理提取**: 从`T`的所有子项中提取所有等价断言，构成一个基项偶对集合：
    `E_pairs(T) = { (s, t) | equiv(s, t) ∈ Sub(T) }`
    根据基项公理约束，`E_pairs(T)`是一个有限的基项偶对集合。

2.  **闭包计算**: `≡_T`被定义为在`T`的所有基项子项的集合上，由`E_pairs(T)`生成的最小等价关系（即自反、对称、传递闭包）。

由于`T`是有限项，其基项子项的集合也是有限的。因此，`≡_T`所代表的等价类划分可以通过标准算法（如并查集 Union-Find）在多项式时间内有效计算。这确保了对于任意两个基项`u, v`，判断`u ≡_T v`是否成立是**可判定的**。

**定义 (单步演化函数 `Step_inferential`)**
`Step_inferential: T_Σ(V) → T_Σ(V)`是一个确定性函数，其计算过程如下：

1.  **构建背景理论**: 根据当前项`T`，计算出其动态等价关系`≡_T`。

2.  **确定所有重写实例**: 构造`T`中所有可能的**推论式重写实例**（inferential redex）的集合，记为`RedexInst_infer(T)`。一个实例是一个良定义的四元组`(p_app, p_rule, l→r, σ)`，其中：
    *   `p_rule`是规则`rewrite(l, r)`在`T`中的来源位置。
    *   `p_app`是被重写的**目标子项**`a = T|{p_app}`的位置。根据变量约束，`a`必须是基项。
    *   `l→r`是被应用的规则。
    *   `σ`是一个基替换 (ground substitution)。

    这四者必须满足以下**推论匹配条件 (Inferential Matching Condition)**:
    `a ≡_T σ(l)`

3.  **确定性选择**: 如果`RedexInst_infer(T)`为空，则`Step_inferential(T) = T`。否则，应用一个确定的选择函数`Select_infer`从中选择一个唯一的、最小的实例。
    *   **选择策略 `Select_infer`**: `Select_infer`函数选择`RedexInst_infer(T)`中关于偶对`(p_app, p_rule)`在字典序上最小的元素。我们将其记为`(p*_app, p*_rule, l*→r*, σ*)`。

4.  **应用变换**: `Step_inferential(T) = T[σ*(r*)]_{p*_app}`。

