### **生成逻辑框架 G (System G)：形式化规范**

#### **1. 语法 (Syntax)**

**1.1. 基础集合**

*   `V`: 一个可数的变量集合 (e.g., `x, y, z, ...`)。
*   `Id`: 一个可数的原子标识符集合 (e.g., `f, proc_1, builder, ...`)。
*   `C`: 一个用户定义的常量和构造器符号集合，每个符号 `c ∈ C` 都有一个固定的元数 (arity) `ar(c) ≥ 0`。

**1.2. 签名 (Signature)**

系统 G 的签名 `Σ` 由 `C` 以及以下特殊的构造器符号构成：

*   `locus`: 元数为 3。用于定义生成位点。
*   `trigger`: 元数为 2。用于激活生成位点。
*   `param_list`: 元数 `n ≥ 0`。用于表示形式参数列表。
*   `arg_list`: 元数 `n ≥ 0`。用于表示实际参数列表。
*   `tuple`: 元数 `n ≥ 0`。用于构成复合数据结构。

**1.3. 项 (Terms)**

项的集合 `T_Σ(V)` 在签名 `Σ` 和变量集 `V` 上被归纳定义如下：
1.  如果 `v ∈ V`，那么 `v` 是一个项。
2.  如果 `c ∈ C` 且 `ar(c) = n`，`t₁, ..., tₙ` 是项，那么 `c(t₁, ..., tₙ)` 是一个项。
3.  如果 `id ∈ Id`，`v₁, ..., vₙ ∈ V`，`body` 是一个项，那么 `locus(id, param_list(v₁, ..., vₙ), body)` 是一个项。
4.  如果 `id ∈ Id`，`t₁, ..., tₙ` 是项，那么 `trigger(id, arg_list(t₁, ..., tₙ))` 是一个项。
5.  如果 `t₁, ..., tₙ` 是项，那么 `tuple(t₁, ..., tₙ)` 是一个项。

**基项 (Ground Terms)** 的集合 `T_Σ` 是 `T_Σ(V)` 中不含任何变量的项的子集。

**1.4. 系统状态 (System State)**

System G 的一个**状态**由一个单一的基项 `T ∈ T_Σ` 定义。

**1.5. 良构约束 (Well-formedness Constraint)**

一个状态 `T` 是**良构的 (well-formed)**，当且仅当对于 `T` 中的任何子项 `s = locus(id, param_list(v₁, ..., vₙ), body)`，都满足 `vars(body) ⊆ {v₁, ..., vₙ}`。其中 `vars(body)` 表示在项 `body` 中出现的变量集合。

#### **2. 操作语义 (Operational Semantics)**

系统的演化由一个单步**生成迁移关系** `⟶_G` 定义，该关系作用于良构的状态上。

**2.1. 单步生成迁移 (`⟶_G`)**

一个状态 `T` 可以通过单步迁移演化为状态 `T'`，记为 `T ⟶_G T'`，其推导规则如下：

<br>

**规则 (GENERATE)**
$$
\Large
\frac{
\begin{array}{l}
T|_{p_{\text{trig}}} = \text{trigger}(\text{id}, \text{arg\_list}(t_1, \dots, t_n)) \\[1ex]
T|_{p_{\text{loc}}} = \text{locus}(\text{id}, \text{param\_list}(v_1, \dots, v_n), \text{body}) \\[1ex]
\sigma = \{v_1 \mapsto t_1, \dots, v_n \mapsto t_n\} \\[1ex]
T' = T[\sigma(\text{body})]_{p_{\text{trig}}}
\end{array}
}
{
T \longrightarrow_G T'
}
$$

**前提条件解释:**

1.  在状态 `T` 中，存在一个位置 `p_trig`，其子项是一个**激活器** `trigger(id, arg_list(t₁, ..., tₙ))`。
2.  在状态 `T` 中，存在一个位置 `p_loc`，其子项是一个**生成位点** `locus(id, param_list(v₁, ..., vₙ), body)`。
3.  这两个子项的标识符 `id` 必须相同，并且参数列表的长度 `n` 必须相等。
4.  定义一个替换 `σ`，它将 `locus` 的形式参数 `vᵢ` 映射到 `trigger` 的实际参数 `tᵢ`。
5.  构造后继状态 `T'`，它通过在位置 `p_trig` 处，用实例化后的 `body` (即 `σ(body)`) 替换原有的 `trigger` 子项而得到。

**注记**:
*   该关系是**非确定性的 (non-deterministic)**。如果在一个状态 `T` 中存在多个满足条件的 `(p_trig, p_loc)` 对，系统可以选择任何一对来执行迁移。
*   良构约束保证了 `σ(body)` 是一个基项，因此后继状态 `T'` 仍然是一个基项。可以证明，如果 `T` 是良构的，那么 `T'` 也是良构的。

#### **3. 计算 (Computation)**

**3.1. 推导 (Derivation)**

一个**推导**或**计算**是一个（有限或无限的）迁移序列：
`T₀ ⟶_G T₁ ⟶_G T₂ ⟶_G ...`
其中 `T₀` 是一个初始的良构状态。`⟶_G^*` 表示关系 `⟶_G` 的自反传递闭包。

**3.2. 范式与终止 (Normal Form and Termination)**

一个状态 `T` 被称为**范式 (Normal Form)**，如果不存在任何状态 `T'` 使得 `T ⟶_G T'`。
一个计算如果达到一个范式，则称该计算**终止 (terminates)**。

---

### **示例：递归生成二叉树**

此示例演示了如何通过激活生成位点来逐步构建一个数据结构。

**初始状态 `T₀`**

```
T₀ = tuple(
    // 定义1: 创建叶子节点的 locus
    locus(
        make_leaf,
        param_list(val),
        leaf(val)
    ),

    // 定义2: 创建内部节点的 locus
    locus(
        make_node,
        param_list(left_val, right_val),
        node(
            trigger(make_leaf, arg_list(left_val)),
            trigger(make_leaf, arg_list(right_val))
        )
    ),

    // 初始激活器，任务是创建一个根节点
    trigger(make_node, arg_list(A, B))
)
```

**推导过程**

**1. `T₀ ⟶_G T₁`**
*   **匹配**: `trigger(make_node, arg_list(A, B))` 与 `locus(make_node, ...)` 匹配。
*   **替换**: `σ = {left_val ↦ A, right_val ↦ B}`。
*   **结果**: `trigger` 被 `node(trigger(make_leaf, arg_list(A)), trigger(make_leaf, arg_list(B)))` 替换。

```
T₁ = tuple(
    locus(make_leaf, ...),
    locus(make_node, ...),
    node(
        trigger(make_leaf, arg_list(A)),
        trigger(make_leaf, arg_list(B))
    )
)
```

**2. `T₁ ⟶_G T₂`** (选择左侧的 trigger)
*   **匹配**: `trigger(make_leaf, arg_list(A))` 与 `locus(make_leaf, ...)` 匹配。
*   **替换**: `σ = {val ↦ A}`。
*   **结果**: `trigger` 被 `leaf(A)` 替换。

```
T₂ = tuple(
    locus(make_leaf, ...),
    locus(make_node, ...),
    node(
        leaf(A),
        trigger(make_leaf, arg_list(B))
    )
)
```

**3. `T₂ ⟶_G T₃`**
*   **匹配**: `trigger(make_leaf, arg_list(B))` 与 `locus(make_leaf, ...)` 匹配。
*   **替换**: `σ = {val ↦ B}`。
*   **结果**: `trigger` 被 `leaf(B)` 替换。

```
T₃ = tuple(
    locus(make_leaf, ...),
    locus(make_node, ...),
    node(
        leaf(A),
        leaf(B)
    )
)
```

**终止**

状态 `T₃` 是一个范式，因为其中不再有任何 `trigger` 子项可以被激活。计算终止。