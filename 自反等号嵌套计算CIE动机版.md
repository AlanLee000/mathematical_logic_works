### **一份关于CIE形式系统的技术说明**

本文旨在提供一份关于“CIE”（Calculus of Internalized Equivalences）形式系统的技术说明。本文档将独立阐述该系统的核心设计原则、机制及元理论属性。

---

### **第一部分：核心设计与构造**

CIE系统的设计围绕三个核心思想展开，它们共同构建了一个既具备计算能力又能在对象层面上进行自我指涉的形式系统。

#### **1. 等价的内化 (Internalization of Equivalence)**

**动机**

在形式系统中，我们通常需要区分两种“等价”：一种是**可证等价**（记为 `~`），这是一个存在于系统之外的元语言概念，表示我们可以通过一系列推理规则从一个项推导出另一个项；另一种是**等价构造**（记为 `≡`），这是一个存在于系统之内的对象语言符号，它自身构成一个项。

CIE的核心动机之一在于，一个强大的自反系统不仅需要拥有这两种概念，还必须在它们之间建立一座坚固的双向桥梁。如果没有这样的桥梁，系统内部的等价断言（如 `[a ≡ b]`）就只是一个不具特殊意义的普通数据结构，无法反映外部的可证性事实。反之，外部的可证性也无法在系统内部被表达和操作。因此，系统必须能够可靠地将元语言层面的“可证性”**内化**为对象语言层面的“真值”，反之亦然。

**构造与机制**

CIE通过三条专门的推理规则来构建这座桥梁，其中 `()` 被视为规范的“真”值：

*   **`(Equiv-Reflection)`: `Γ ⊢ t₁ ~ t₂`  ⇒  `Γ ⊢ (t₁ ≡ t₂) ~ ()`**
    *   **机制**: 这条规则是“内化”的通道。它规定，如果在元语言层面可以证明 `t₁` 与 `t₂` 等价，那么在对象语言层面，代表这一事实的项 `(t₁ ≡ t₂)` 就与规范的真值 `()` 等价。它将一个外部的证明结论“反射”成了系统内部的一个真值断言。

*   **`(Equiv-Elim)`: `Γ ⊢ (t₁ ≡ t₂) ~ ()`  ⇒  `Γ ⊢ t₁ ~ t₂`**
    *   **机制**: 这是“外化”的通道。它规定，如果一个内化的等价断言 `(t₁ ≡ t₂)` 被证明与 `()` 等价（即它在系统内部被断定为“真”），那么我们就可以在元语言层面得出 `t₁ ~ t₂` 这一事实。它允许我们从系统内部的计算结果中“消除”等价构造，提取出外部的证明结论。

*   **`(Equiv-Intro)`: (`Γ, t₁~t₂ ⊢ s₁~s₂` 且 `Γ, s₁~s₂ ⊢ t₁~t₂`)  ⇒  `Γ ⊢ (t₁ ≡ t₂) ~ (s₁ ≡ s₂)`**
    *   **机制**: 这条规则处理的是等价断言之间的等价性。它指出，如果两个元语言判断 `(t₁ ~ t₂)` 和 `(s₁ ~ s₂)` 在逻辑上是互推的（在给定上下文 `Γ` 的情况下），那么它们各自对应的对象语言项 `(t₁ ≡ t₂)` 和 `(s₁ ≡ s₂)` 也是可证等价的。这确保了逻辑等价性在内化过程中得以保持。

这三条规则协同工作，确保了元语言证明 (`~`) 与对象语言构造 (`≡`) 之间的一致性和可转换性，使得系统能够对其自身的等价关系进行有意义的推理。

#### **2. 再化 (Reification)**

**动机**

CIE的第二个核心思想是“一个项是其自身真值断言的等价物”，我们称之为**再化**（或具体化）。这一设计旨在赋予系统一种自我指涉能力。在传统逻辑中，项（如 `7`）和关于项的命题（如 `7 > 5`）是严格分离的。CIE试图模糊这一界限，其设计哲学认为，一个项 `t` 的存在本身就蕴含了“`t` 为真”这一断言。这种设计使得任何数据结构都可以同时被看作是一个命题。

**构造与机制**

这一思想通过一条规则来实现：

*   **`(Reif)`: `Γ ⊢ t ~ (t ≡ ())`**

**机制**: 这条规则是一条公理（没有前提），对系统中的任何项 `t` 都成立。它断言 `t` 本身与另一个项 `(t ≡ ())` 是可证等价的。我们来解析 `(t ≡ ())` 的含义：它是一个内化的等价断言，其语义可以解读为“项 `t` 是否等价于规范的真值 `()`？”。

因此，`(Reif)` 规则的本质是建立了一个等式：

`t`  **~**  (命题：“`t` 等价于真”)

这条规则，与将 `()` 视为“真”的设计相结合，形成了一个自洽的循环。它断言一个项的“真值”就是这个项本身。例如，对于项 `pair(a, b)`，`(Reif)` 规则允许我们证明 `pair(a, b) ~ (pair(a, b) ≡ ())`。这使得系统可以在不脱离对象语言的情况下，将任何数据项 `t` 无缝地转换为一个关于其自身真值的命题。

#### **3. 等价关系的非结合性 (Non-associativity of Equivalence)**

**动机**

在代数系统中，结合律（associativity）通常是一个期望的属性。然而，CIE有意地将 `≡` 设计为**非结合律**的。这一设计的动机源于对系统中两种不同语义实体的区分：**命题**和**数据**。

*   表达式 `[a ≡ b]` 的意图是构造一个**命题**，其值最终应被解释为“真”或“假”。
*   而像 `c` 这样的项（例如一个原子符号或一个 `pair` 构造）通常代表**数据**。

因此，`[[a ≡ b] ≡ c]` 和 `[a ≡ [b ≡ c]]` 在语义上有着根本的区别：
*   `[[a ≡ b] ≡ c]` 比较的是一个“命题” `[a ≡ b]` 和一个“数据” `c`。
*   `[a ≡ [b ≡ c]]` 比较的是一个“数据” `a` 和一个“命题” `[b ≡ c]`。

系统设计者认为，强制这两个结构等价会混淆命题和数据之间的语义界限，导致不直观的后果。非结合性正是维持这种语义区分的形式化体现。

**构造与机制**

为了形式化地证明结合律不成立，我们可以构造一个三值语义模型，其中项的解释值可以落在集合 `{⊤, ⊥, δ}` 中。

1.  **模型定义**:
    *   **域**: `D = {⊤, ⊥, δ}`。其中 `⊤` 代表“真”，`⊥` 代表“假”，`δ` 代表“数据”。
    *   **解释**:
        *   `〚()〛` 被解释为 `⊤`。
        *   所有数据构造子（如 `pair` 或其他原子符号）的解释值为 `δ`。
        *   `〚[t₁ ≡ t₂]〛` 的解释是一个元语言的相等性测试：
            *   如果 `〚t₁〛 = 〚t₂〛`，则结果为 `⊤`。
            *   否则，结果为 `⊥`。

2.  **反例演算**:
    我们选择三个原子项 `a`, `b`, `c`，并为它们分配如下语义值：
    *   `〚a〛 = δ`
    *   `〚b〛 = δ`
    *   `〚c〛 = ⊤` (例如，我们可以让 `c` 就是 `()`)

    现在，我们分别计算结合律公式两边的语义值：

    *   **演算左侧 `〚[[a ≡ b] ≡ c]〛`**:
        1.  计算内层 `〚[a ≡ b]〛`：由于 `〚a〛 = δ` 且 `〚b〛 = δ`，两者相等，因此 `〚[a ≡ b]〛 = ⊤`。
        2.  计算外层 `〚[⊤ ≡ c]〛`：代入内层结果和 `c` 的值，得到 `〚[⊤ ≡ ⊤]〛`。由于 `⊤ = ⊤`，最终结果为 `⊤`。
        *   所以，**LHS = `⊤`**。

    *   **演算右侧 `〚[a ≡ [b ≡ c]]〛`**:
        1.  计算内层 `〚[b ≡ c]〛`：由于 `〚b〛 = δ` 且 `〚c〛 = ⊤`，两者不相等，因此 `〚[b ≡ c]〛 = ⊥`。
        2.  计算外层 `〚[a ≡ ⊥]〛`：代入 `a` 的值和内层结果，得到 `〚[δ ≡ ⊥]〛`。由于 `δ ≠ ⊥`，最终结果为 `⊥`。
        *   所以，**RHS = `⊥`**。

由于 `LHS (⊤)` 不等于 `RHS (⊥)`，该模型提供了一个有效的反例。根据可靠性原则（任何可证的定理必须在所有有效的语义模型中都成立），这证明了结合律在CIE系统中是不可证的。

---

### **第二部分：关键元理论证明的深入说明**

本部分将重构CIE系统最重要的元理论属性之一——一致性——的核心论证过程。

#### **4. 一致性证明的重构**

系统的**一致性**（Consistency）是指它不能证明所有命题，即存在不可证的判断。证明一致性的标准方法是构造一个模型，并展示某个我们不希望成立的判断在该模型中为假。

**证明策略**

整体策略分为两步：
1.  **构造一个布尔语义模型 `M`**，并证明CIE的所有推理规则在该模型下都是**可靠的（Sound）**。可靠性意味着，任何在CIE中可证的判断，在模型 `M` 中必然为真。
2.  **展示一个反例**。我们选择一个特定的、不应成立的判断（例如 `⟨()⟩ ~ ()`），并计算出它在模型 `M` 中的值为假。
3.  **得出结论**。根据可靠性定理，如果一个判断在模型中为假，那么它在CIE系统中必然是**不可证的**。这就证明了系统不是什么都能证明的，因此它是一致的。

**模型构造细节**

我们构造一个简单的布尔语义模型 `M`，它将所有项区分为“真”或“非真/数据”。

1.  **域 (Domain)**:
    模型的域是布尔集合 `D = {1, 0}`，其中 `1` 代表“真”，`0` 代表“非真”或“数据”。

2.  **核心构造子的解释**:
    *   规范的“真”值 `()` 被解释为 `1`：
        `〚()〛 = 1`
    *   所有用于构造数据的符号，如 `pair` 以及任何用户定义的函数符号，都被解释为 `0`：
        `〚pair(t₁, t₂)〛 = 0`

3.  **等价构造 `≡` 的解释**:
    内化的等价 `[t₁ ≡ t₂]` 被解释为一个元语言的**相等性测试**。它检查其参数的解释值是否相等：
    *   `〚[t₁ ≡ t₂]〛 = 1`  如果 `〚t₁〛 = 〚t₂〛`
    *   `〚[t₁ ≡ t₂]〛 = 0`  如果 `〚t₁〛 ≠ 〚t₂〛`

**可靠性论证的核心**

可靠性定理的证明需要验证CIE的每一条推理规则在模型 `M` 中都保持真理。大部分规则（如 `(Refl)`, `(Trans)`, `(Cong)`）的可靠性是直观的，因为它们直接反映了模型中等式关系的基本性质。然而，`(Hyp-Schema)` 规则的可靠性论证需要特别注意。

*   **`(Hyp-Schema)` 规则**: 该规则允许我们从上下文中取出一个包含变量的公理模式 `(l ~ r)`，并将其中的变量用任意项进行替换 `θ`，从而得到结论 `θ(l) ~ θ(r)`。

*   **可靠性保证**: 这条规则的可靠性之所以能够成立，是因为模型 `M` 中对“满足公理模式”的语义定义非常严格。一个估值 `ν` 满足一个上下文 `Γ`，不仅仅要求 `Γ` 中的局部公理在 `ν` 下为真，还要求 `Γ` 中的**公理模式**在**所有可能的估值**下都为真。
    *   即，如果 `(l ~ r)` 是一个公理模式，那么 `ν ⊨ (l ~ r)` 成立的条件是：**对于任意估值 `μ`**，都有 `〚l〛_μ = 〚r〛_μ`。

    这个**对所有估值的全称量化**是关键。证明过程如下：
    1.  我们要证明 `θ(l) ~ θ(r)` 在任何满足 `Γ` 的估值 `ν` 下都成立。
    2.  我们利用一个**语义替换引理**，该引理表明 `〚θ(t)〛_ν = 〚t〛_ν'`，其中 `ν'` 是一个新的估值，它将变量 `x` 映射到 `〚θ(x)〛_ν`。
    3.  由于公理模式 `(l ~ r)` 对**所有**估值都成立，它自然也对我们构造出的这个新估值 `ν'` 成立。因此，`〚l〛_ν' = 〚r〛_ν'`。
    4.  结合替换引理，我们得到 `〚θ(l)〛_ν = 〚l〛_ν' = 〚r〛_ν' = 〚θ(r)〛_ν`。
    5.  这就证明了即使经过任意替换，结论在语义上依然成立，保证了 `(Hyp-Schema)` 规则的可靠性。

**最终的矛盾**

在证明了系统的可靠性之后，我们来演算最终的反例：判断 `⟨()⟩ ~ ()`。

1.  根据语法糖的定义，`⟨()⟩` 是 `pair((), ())` 的简写。
2.  我们计算该判断在模型 `M` 中的两侧的语义值：
    *   **左侧 `〚⟨()⟩〛`**:  `〚pair((), ())〛`。根据模型的定义，任何由 `pair` 构造的项都被解释为 `0`。
    *   **右侧 `〚()〛`**: 根据模型的定义，`()` 被解释为 `1`。
3.  因此，判断 `⟨()⟩ ~ ()` 在模型 `M` 中对应的语义断言是 `0 = 1`。
4.  这是一个明确的矛盾。这意味着该判断在模型 `M` 中为假。

根据可靠性定理，任何可证的判断必须在模型中为真。由于 `⟨()⟩ ~ ()` 在模型中为假，它在CIE系统中必然是**不可证的**。这证明了系统存在不可证的判断，因此它是一致的。