### **Ω-演算：形式化规约系统**

#### **1. 语法 (Syntax)**

##### **1.1. 符号集 (Sets of Symbols)**

1.  **变量 (Variables):** 一个可数的无穷集合 $V = \{x, y, z, ...\}$。
2.  **常量 (Constants):** 一个有限集合 $C = \{\top, \bot\}$。
    *   $\top$: 真理范式 (Truth Canonical Form)。
    *   $\bot$: 矛盾范式 (Contradiction Canonical Form)。

##### **1.2. 项 (Terms)**

项的集合 $\mathcal{T}$ 是由以下BNF（巴科斯-瑙尔范式）语法归纳定义的最小集合：

$t, s ::= x \mid \top \mid \bot \mid (t \ s) \mid ('t) \mid (t \equiv s)$

其中 $x \in V$。

##### **1.3. 记法与约定 (Notation and Conventions)**

1.  **应用 (Application):** `(t s)` 表示应用。应用是左结合的，即 `(t s u)` 是 `((t s) u)` 的简写。
2.  **引用 (Quotation):** `('t)` 表示引用。
3.  **等价 (Equivalence):** `(t ≡ s)` 表示内化的等价断言。
4.  **自由变量 (Free Variables):** 项 `t` 的自由变量集合，记为 $FV(t)$，定义如下：
    *   $FV(x) = \{x\}$
    *   $FV(\top) = \emptyset$
    *   $FV(\bot) = \emptyset$
    *   $FV((t \ s)) = FV(t) \cup FV(s)$
    *   $FV(('t)) = FV(t)$
    *   $FV((t \equiv s)) = FV(t) \cup FV(s)$
5.  **句法同一性 (Syntactic Identity):** 在元语言（我们用于描述本系统的语言）中，我们使用 $t_1 = t_2$ 来表示项 $t_1$ 和 $t_2$ 是句法上完全相同的（即作为符号串或抽象语法树是相同的）。这与对象语言中的项构造子 `(t ≡ s)` 是严格区分的。类似地，$t_1 \neq t_2$ 表示它们在句法上不同。

##### **1.4. 替换 (Substitution)**

将项 `s` 替换项 `t` 中的所有自由变量 `x`，记为 $t[s/x]$，其定义如下：

*   $x[s/x] = s$
*   $y[s/x] = y$, 如果 $y \neq x$
*   $\top[s/x] = \top$
*   $\bot[s/x] = \bot$
*   $(t_1 \ t_2)[s/x] = (t_1[s/x] \ t_2[s/x])$
*   $('t_1)[s/x] = ('(t_1[s/x]))$
*   $(t_1 \equiv t_2)[s/x] = (t_1[s/x] \equiv t_2[s/x])$

#### **2. 操作语义 (Operational Semantics)**

系统的动态行为由一个小步归约关系 `⟶` 定义。

##### **2.1. 值 (Values)**

值的集合 $\mathcal{V} \subset \mathcal{T}$ 是可在归约中充当部分求值结果的项。它由以下三个不相交的子集构成：

1.  **真理值 (Truth Value):** $\mathcal{V}_{T} = \{\top\}$。
2.  **矛盾值 (Contradiction Value):** $\mathcal{V}_{\bot} = \{\bot\}$。
3.  **数据值 (Data Value):** $\mathcal{V}_{D} = \{('t) \mid t \in \mathcal{T} \land t \neq \bot \}$。
    *   此定义规定，一个引用项 `('t)` 是一个数据值，当且仅当其内部的项 `t` 在句法上不是常量 `⊥`。

值的全集为 $\mathcal{V} = \mathcal{V}_{T} \cup \mathcal{V}_{\bot} \cup \mathcal{V}_{D}$。

##### **2.1. 典范值 (Canonical Values)**

为了严谨地定义等价判定规则，我们引入一个纯句法概念——**典范值 (Canonical Value)**，记为 $\mathcal{CV}$。它是值的集合 $\mathcal{V}$ 的一个严格子集，代表那些已完全求值的、不可再规约的数据结构。

**定义 2.1.1 (典范项, Canonical Terms, $\mathcal{CT}$)**
典范项的集合 $\mathcal{CT}$ 是由以下规则归纳定义的最小集合：
1.  **变量:** 如果 $x \in V$, 那么 $x \in \mathcal{CT}$。
2.  **真理常量:** $\top \in \mathcal{CT}$。
3.  **典范引用:** 如果 $t \in \mathcal{CT}$, 那么 $('t) \in \mathcal{CT}$。
4.  **典范应用:** 如果 $t_1, t_2 \in \mathcal{CT}$ 且 $t_1$ 本身是一个变量或典范应用，那么 $(t_1 \ t_2) \in \mathcal{CT}$。

**定义 2.1.2 (典范值, Canonical Values, $\mathcal{CV}$)**
一个值 $v \in \mathcal{V}$ 被称为**典范值**，当且仅当它满足以下条件之一：
1.  $v = \top$。
2.  $v$ 的形式是 `('t)`，其中 $t \in \mathcal{CT}$。

**备注 (关于值与范式):** 在本系统中，**值 (Value)** 与 **范式 (Normal Form)** 是两个不同的概念。一个范式是指无法再进行任何归约的项。虽然 `⊤` 是一个典范值也是范式，但一个非典范的数据值 `('t)` 不一定是范式。例如，`(' (⊤ x))` 是一个数据值，但它不是范式，因为 `(' (⊤ x)) ⟶ ('x)`。而典范值，根据其构造，将被证明都是范式。

##### **2.2. 单步归约关系 (Single-Step Reduction Relation `⟶`)**

归约关系 $t \longrightarrow t'$ 由以下公理化规则和同余规则共同定义。

###### **A) 公理化归约规则**

1.  **(Ω-Id)** $(\top \ t) \longrightarrow t$
2.  **(Ω-Reflect)** $('t \ t) \longrightarrow \top$
3.  **(Ω-Quote⊥)** $('\bot) \longrightarrow \bot$
4.  **(Ω-Explode)** $(\bot \ t) \longrightarrow \bot$
5.  **(Ω-Eval≡)** 对于任意**典范值** $v_1, v_2 \in \mathcal{CV}$:
    $$ (v_1 \equiv v_2) \longrightarrow \begin{cases} \top & \text{如果 } v_1 = v_2 \\ \bot & \text{如果 } v_1 \neq v_2 \end{cases} $$

###### **B) 同余归约规则**

这些规则允许在项的内部进行归约。

1.  **(Cong-App₁)**
    $$ \frac{t_1 \longrightarrow t'_1}{(t_1 \ t_2) \longrightarrow (t'_1 \ t_2)} $$

2.  **(Cong-App₂)**
    $$ \frac{t_2 \longrightarrow t'_2}{(v_1 \ t_2) \longrightarrow (v_1 \ t'_2)} \quad (\text{其中 } v_1 \in \mathcal{V}) $$

3.  **(Cong-Quote)**
    $$ \frac{t \longrightarrow t'}{('t) \longrightarrow ('t')} $$

4.  **(Cong-Equiv₁)**
    $$ \frac{t_1 \longrightarrow t'_1}{(t_1 \equiv t_2) \longrightarrow (t'_1 \equiv t_2)} $$

5.  **(Cong-Equiv₂)**
    $$ \frac{t_2 \longrightarrow t'_2}{(v_1 \equiv t_2) \longrightarrow (v_1 \equiv t'_2)} \quad (\text{其中 } v_1 \in \mathcal{V}) $$

##### **2.3. 多步归约与求值 (Multi-Step Reduction and Evaluation)**

1.  **多步归约 (Multi-step Reduction `⟶*`)**:
    `⟶*` 是 `⟶` 关系的自反传递闭包。

2.  **求值判断 (Evaluation Judgment `⇓`)**:
    我们说一个项 `t` **求值为** `v`，记为 $t \Downarrow v$，当且仅当：
    $t \longrightarrow^* v$，其中 $v \in \mathcal{V}$，并且 $v$ 是一个**范式** (Normal Form)，即不存在任何项 $v'$ 使得 $v \longrightarrow v'$。
---

#### **3. 示例计算**

*   **示例 1: 单位元律**
    `((('x) ('y)) T) ⟶ (('x) ('y))`
    *   **理由**: 直接应用 **(Ω-Id)** 规则。

*   **示例 2: 反射律**
    `(('('x)) ('x)) ⟶ T`
    *   **理由**: 直接应用 **(Ω-Reflect)** 规则。

*   **示例 3: 等价判定 (真)**
    `((⊤ ('x)) ≡ ('x))`
    `⟶ (('x) ≡ ('x))` (根据 **Cong-Equiv₁** 和 **Ω-Id**)
    *   此时，左项 `('x)` 和右项 `('x)` 都是数据值（因为 $x \neq \bot$）。
    `⟶ ⊤` (根据 **Ω-Eval≡**，因为 `('x)` 与自身句法相同)
    *   因此, `((⊤ ('x)) ≡ ('x)) ⇓ ⊤`。

*   **示例 3.1: 无法判定的等价**
    `((('x) ('y)) ≡ (('x) ('y)))`
    *   此项是一个范式。其中子项 `(('x) ('y))` 的结构是应用，不符合任何值的句法形式（`⊤`, `⊥` 或 `('t)`)，因此 `(('x) ('y))` 不是一个值。
    *   由于 `(Ω-Eval≡)` 的前提条件 ($v_1, v_2 \in \mathcal{V}$) 未被满足，该规则不可应用。
    *   此项不进行任何归约，它是一个“卡死”的范式，但没有求值结果。

*   **示例 4: 等价判定 (矛盾)**
    `(T ≡ ('T))`
    *   `T` 是值 `v₁`，`('T)` 是值 `v₂`。它们是不同的值。
    `⟶ ⊥` (根据 **Ω-Eval≡**)
    *   因此, `(T ≡ ('T)) ⇓ ⊥`。

*   **示例 5: 矛盾的传播**
    `((('⊥) ('x)) y)`
    `⟶ ( (⊥) ('x)) y)` (根据 **Cong-App₁** 和 **Ω-Quote⊥**)
    `⟶ (⊥ y)` (根据 **Cong-App₁** 和 **Ω-Explode**)
    `⟶ ⊥` (根据 **Ω-Explode**)
    *   因此, `((('⊥) ('x)) y) ⇓ ⊥`。

--- 
### **附录：形式化证明**

本附录提供了Ω-演算系统的核心元理论性质的形式化证明。我们将首先证明系统的**合流性 (Confluence)**，也称为丘奇-罗瑟性质 (Church-Rosser Property)。合流性确保了任何项的归约路径，无论选择何种顺序，最终都能达到一个共同的结果。

我们的证明策略将采用**纽曼引理 (Newman's Lemma)**。该引理指出，一个重写系统若是**弱合流的 (Weakly Confluent)** 并且是**强规范化的 (Strongly Normalizing)**，那么它就是合流的。

#### **A.1 弱合流性 (Weak Confluence)**

**定义 A.1 (弱合流性)**
一个归约关系 `⟶` 被称为弱合流的，如果对于任意项 `u`, `t₁`, `t₂`，当 `u ⟶ t₁` 且 `u ⟶ t₂` 时，存在一个项 `s`，使得 `t₁ ⟶* s` 且 `t₂ ⟶* s`。

为了证明弱合流性，我们首先证明一个关键引理：所有典范值都是不可约的范式。

**引理 A.1.1 (典范值的不可约性)**
如果一个项 $v$ 是一个典范值 (即 $v \in \mathcal{CV}$)，那么 $v$ 是一个范式 (Normal Form)，即不存在任何项 $v'$ 使得 $v \longrightarrow v'$。

**证明:**
 我们通过对 $t \in \mathcal{CT}$ 的派生结构进行归纳，来证明所有典范项 $t$ 都是范式。

 1.  **基础情况 1: $t = x$** (其中 $x \in V$)
     没有任何归约规则的左手边能匹配一个孤立的变量。因此 $x$ 是范式。
 2.  **基础情况 2: $t = \top$**
     没有任何归约规则的左手边能匹配常量 $\top$。因此 $\top$ 是范式。
 3.  **归纳步骤 1: $t = ('s)$**，其中 $s \in \mathcal{CT}$
     **归纳假设 (IH):** 项 $s$ 是一个范式。
     要使 $t$ 可归约，它必须：
     a) 匹配一个公理化规则的左手边。`(Ω-Id)`, `(Ω-Reflect)`, `(Ω-Explode)`, `(Ω-Eval≡)` 的结构均不匹配 `('s)`。`(Ω-Quote⊥)` 要求 $s = \bot$，但这与典范项的定义（$\bot \notin \mathcal{CT}$）矛盾。
     b) 允许一个同余规则。唯一可能的是 `(Cong-Quote)`，它要求内部项 $s$ 可归约，即存在 $s'$ 使得 $s \longrightarrow s'$。这直接与我们的归纳假设（$s$ 是范式）相矛盾。
     因此，`('s)` 不可归约，是范式。
 4.  **归纳步骤 2: $t = (t_1 \ t_2)$**，其中 $t_1, t_2 \in \mathcal{CT}$，且 $t_1$ 是一个变量或典范应用。
     **归纳假设 (IH):** 项 $t_1$ 和 $t_2$ 都是范式。
     要使 $t$ 可归约，它必须：
     a) 匹配一个公理化规则的左手边。
     *   `(Ω-Id)` 要求 $t_1 = \top$，但这与 $t_1$ 的结构（变量或典范应用）矛盾。
     *   `(Ω-Reflect)` 要求 $t_1$ 是一个引用 `('s)`，这也与 $t_1$ 的结构矛盾。
     *   `(Ω-Explode)` 要求 $t_1 = \bot$，但这与 $t_1 \in \mathcal{CT}$ 矛盾。
     *   `(Ω-Eval≡)` 的结构是 `(_ ≡ _)`，不匹配应用 `(_ _)`。
     b) 允许一个同余规则。
     *   `(Cong-App₁)` 要求 $t_1$ 可归约，与 IH 矛盾。
     *   `(Cong-App₂)` 要求 $t_2$ 可归约（且 $t_1$ 是值），与 IH 矛盾。
     因此，`(t_1 t_2)` 不可归约，是范式。

 综上，通过对 $\mathcal{CT}$ 结构的完全归纳，我们证明了所有典范项都是范式。由于典范值 $\mathcal{CV}$ 的定义（$\top$ 或 `('t)` 其中 $t \in \mathcal{CT}$），结合上述证明，可得任何典范值 $v \in \mathcal{CV}$ 都是范式。∎

**引理 A.1.1.1 (基本值的不可约性)**
常量值 `⊤` 和 `⊥` 都是范式。
**证明:** 检查所有归约规则可知，没有任何规则的左手边可以匹配 `⊤` 或 `⊥`。∎

**引理 A.1.2 (值归约的结构)**
如果一个项 $v$ 是一个值 (即 $v \in \mathcal{V}$) 且 $v \longrightarrow v'$，那么 $v'$ 必须满足以下两种情况之一：
1.  $v'$ 本身也是一个值 (即 $v' \in \mathcal{V}$)。
2.  $v'$ 在句法上与项 `('⊥)` 完全相同。

**证明:**
我们通过对值 $v \in \mathcal{V}$ 的结构进行情况分析。

1.  **情况 1: $v = \top$ 或 $v = \bot$**
    根据 **引理 A.1.1.1**，这两个常量都是范式，不可归约。因此，前提条件 $v \longrightarrow v'$ 为假，该蕴含式真空地成立。

2.  **情况 2: $v = ('t)$，其中 $t \in \mathcal{T}$ 且 $t \neq \bot$**
    要使 `('t)` 发生一步归约，只能通过同余规则 `(Cong-Quote)`，因为没有任何公理化规则的左手边匹配 `('t)` (规则 `(Ω-Quote⊥)` 要求内部项为 `⊥`，与 $v$ 的定义矛盾)。
    因此，归约 $v \longrightarrow v'$ 必然是 `('t) ⟶ ('t')` 的形式，其中前提是 $t \longrightarrow t'$。
    此时 $v' = ('t')$。我们分析 $t'$ 的句法形式：
    *   **子情况 2a: $t' \neq \bot$**
        根据值的定义 (2.1)，如果 $t'$ 在句法上不是 `⊥`，那么项 `('t')` 是一个数据值。因此 $v' \in \mathcal{V}_D \subset \mathcal{V}$。此情况满足结论1。
    *   **子情况 2b: $t' = \bot$**
        在这种情况下，$v'$ 在句法上就是 `('⊥)`。此情况满足结论2。

由于所有可能的值归约情况都落入上述两种结论之一，引理得证。∎


**证明 (弱合流性):**
我们通过分析所有可能产生临界对 (Critical Pairs) 的规则重叠来进行证明。

1.  **情况 1: (Ω-Id) 与 (Cong-App₂) 重叠**
    令 `u = (⊤ s)`，且 `s ⟶ s'`。
    *   **路径 1 (Ω-Id):** `u ⟶ s`。
    *   **路径 2 (Cong-App₂):** 因 `⊤ ∈ V`，`u = (⊤ s) ⟶ (⊤ s')`。
    *   **汇合 (Join):** 从路径 2 的结果 `(⊤ s')` 出发，可通过 `(Ω-Id)` 一步归约至 `s'`。从路径 1 的结果 `s` 出发，已知 `s ⟶ s'`。两条路径在 `s'` 处汇合。

2.  **情况 2: (Ω-Reflect) 与同余规则重叠**

    这是最关键的临界情况。考虑项 `u = (('t) t)`，并假设其子项 `t` 存在一步归约 `t ⟶ t'`。该项 `u` 同时匹配顶层规则 `(Ω-Reflect)` 和允许内部归约的同余规则。

    *   **路径 A (顶层归约):**
        直接应用 `(Ω-Reflect)` 规则于 `u`：
        `(('t) t) ⟶ ⊤`
        令 `t_A = ⊤`。由于 `⊤` 是一个范式，任何有效的汇合都必须以 `⊤` 为终点。

    *   **路径 B (内部归约):**
        `u` 的子项 `t` 的归约 `t ⟶ t'` 可以通过两条不同的同余路径影响 `u`：
        *   **路径 B.1 (经由 Cong-App₁):**
            内部归约 `t ⟶ t'` 导致运算符 `('t)` 归约：`('t) ⟶ ('t')` (经由 Cong-Quote)。
            应用 `(Cong-App₁)`，我们得到：
            `u = (('t) t) ⟶ (('t') t)`。
            令 `t_{B.1} = (('t') t)`。
        *   **路径 B.2 (经由 Cong-App₂):**
            运算符 `('t)` 是一个数据值 (`('t) ∈ V`)。操作数 `t` 可归约 `t ⟶ t'`。
            应用 `(Cong-App₂)`，我们得到：
            `u = (('t) t) ⟶ (('t) t')`。
            令 `t_{B.2} = (('t) t')`。

    *   **汇合 (Join):**
        我们必须证明 `t_{B.1}` 和 `t_{B.2}` 都能通过多步归约汇合于 `t_A = ⊤`。

        *   **分析 `t_{B.1}`:**
            对于项 `(('t') t)`，其操作数 `t` 仍然是可归约的 (`t ⟶ t'`)，且其运算符 `('t')` 是一个值。因此，我们可以应用 `(Cong-App₂)`：
            `(('t') t) ⟶ (('t') t')`
            得到的项 `(('t') t')` 的结构现在精确匹配了 `(Ω-Reflect)` 规则的左手边。因此：
            `(('t') t') ⟶ ⊤`
            完整的归约序列为：`t_{B.1} = (('t') t) ⟶ (('t') t') ⟶ ⊤`。该路径与 `t_A` 汇合。

        *   **分析 `t_{B.2}`:**
            对于项 `(('t) t')`，其运算符 `('t)` 是可归约的 (`('t) ⟶ ('t')`)。因此，我们可以应用 `(Cong-App₁)`：
            `(('t) t') ⟶ (('t') t')`
            同样，得到的项 `(('t') t')` 匹配 `(Ω-Reflect)` 规则。因此：
            `(('t') t') ⟶ ⊤`
            完整的归约序列为：`t_{B.2} = (('t) t') ⟶ (('t') t') ⟶ ⊤`。该路径也与 `t_A` 汇合。

    **结论**: 两种内部归约路径 `B.1` 和 `B.2` 产生的项，均可在两步之内归约到顶层归约路径 `A` 的结果 `⊤`。因此，该临界对是可闭合的。

3.  **情况 3: (Ω-Explode) 与 (Cong-App₂) 重叠**
    令 `u = (⊥ s)`，且 `s ⟶ s'`。
    *   **路径 1 (Ω-Explode):** `u ⟶ ⊥`。
    *   **路径 2 (Cong-App₂):** 因 `⊥ ∈ V`，`u = (⊥ s) ⟶ (⊥ s')`。
    *   **汇合 (Join):** `(⊥ s') ⟶ ⊥` (通过 Ω-Explode)。两条路径在 `⊥` 处汇合。

4.  **情况 4: `(Ω-Eval≡)` 与 `(Cong-Equiv)` 重叠**
    令 `u = (t₁ ≡ t₂)`。要产生临界对，`u` 必须同时匹配 `(Ω-Eval≡)` 的左侧和某个同余规则。
    *   为了匹配 `(Ω-Eval≡)`，必须有 $t_1, t_2 \in \mathcal{CV}$。
    *   为了匹配 `(Cong-Equiv₁)`，必须有 $t_1 \longrightarrow t'_1$。
    *   然而，根据**引理 A.1.1**，如果 $t_1 \in \mathcal{CV}$，那么 $t_1$ 是一个范式，不可归约。这两个条件是**互相排斥**的。
    *   同理，`(Cong-Equiv₂)` 要求 $t_2$ 可归约（且 $t_1 \in \mathcal{V}$），这也与 `(Ω-Eval≡)` 要求 $t_2 \in \mathcal{CV}$ 相互排斥。
    *   **结论:** `(Ω-Eval≡)` 和同余规则 `(Cong-Equiv₁)`、`(Cong-Equiv₂)` **不可能**在同一个项上产生临界对。

5.  **情况 5: `(Cong-App₁)` 与 `(Cong-App₂)` 重叠 (通勤情况)**
    当一个应用项 `u = (v₁ t₂)` 的两个子项都可归约，且其运算符 `v₁` 是一个值时，会产生临界对。
    设 `u = (v₁ t₂)`，其中 $v₁ \in \mathcal{V}$，且存在归约 `v₁ ⟶ v₁'` 和 `t₂ ⟶ t₂'`。

    *   **路径 1 (经由 Cong-App₁):** 由于 `v₁` 可归约，我们应用 `Cong-App₁`：
        `(v₁ t₂) ⟶ (v₁' t₂)`

    *   **路径 2 (经由 Cong-App₂):** 由于 `v₁` 是一个值且 `t₂` 可归约，我们应用 `Cong-App₂`：
        `(v₁ t₂) ⟶ (v₁ t₂')`

    *   **汇合 (Join):** 我们需要证明 `(v₁' t₂)` 和 `(v₁ t₂')` 可以汇合。
        首先，从路径 2 的结果 `(v₁ t₂')` 出发，其运算符 `v₁` 仍然可归约 (`v₁ ⟶ v₁'`)。根据 `Cong-App₁` 规则，存在归约：
        `(v₁ t₂') ⟶ (v₁' t₂')`
        我们将这个结果项记为 `s = (v₁' t₂')`。现在，我们必须证明路径 1 的结果 `(v₁' t₂)` 也能归约到 `s` 或与 `s` 汇合于某处。

        为此，我们对 `v₁'` 的结构进行分析。根据 **引理 A.1.2**，由于 $v₁ \in \mathcal{V}$ 且 `v₁ ⟶ v₁'`，`v₁'` 只有两种可能：

        *   **子情况 5a: `v₁'` 是一个值 ($v₁' \in \mathcal{V}$)。**
            在这种情况下，考察路径 1 的结果 `(v₁' t₂)`。因为 `v₁'` 是一个值，且 `t₂ ⟶ t₂'`，我们可以应用 `(Cong-App₂)` 规则：
            `(v₁' t₂) ⟶ (v₁' t₂')`
            这个结果恰好是 `s`。因此，两条路径在 `s` 处汇合。

        *   **子情况 5b: `v₁'` 在句法上是 `('⊥)`。**
            在这种情况下，`v₁'` 不是一个值。因此，不能对 `(v₁' t₂)` 应用 `(Cong-App₂)`。
            考察路径 1 的结果：`u₁ = (v₁' t₂) = (('⊥) t₂)`。
            其运算符 `('⊥)` 可通过 `(Ω-Quote⊥)` 归约为 `⊥`。因此，通过 `(Cong-App₁)`：
            `(('⊥) t₂) ⟶ (⊥ t₂)`
            接下来，通过 `(Ω-Explode)`：
            `(⊥ t₂) ⟶ ⊥`
            所以，在子情况 5b 中，路径 1 的结果通过两步归约到达 `⊥`。即 `(v₁' t₂) ⟶* ⊥`。

            现在考察汇合点 `s = (v₁' t₂') = (('⊥) t₂')`。
            同样地，该项也满足归约条件：
            `(('⊥) t₂') ⟶ (⊥ t₂')`  (经由 `Cong-App₁` 和 `Ω-Quote⊥`)
            `(⊥ t₂') ⟶ ⊥`           (经由 `Ω-Explode`)
            所以，`s ⟶* ⊥`。
            由于路径 2 的结果 `(v₁ t₂')` 可以归约到 `s`，而 `s` 又可以归约到 `⊥`，因此路径 2 的结果也可以归约到 `⊥`。

            两条路径最终都在 `⊥` 处汇合。

    在这两种子情况中，临界对都是可闭合的。同样的方法可证明 `(Cong-Equiv₁)` 与 `(Cong-Equiv₂)` 的通勤情况。

6.  **情况 6: `(Cong-Equiv₁)` 与 `(Cong-Equiv₂)` 重叠 (通勤情况)**
    当一个等价项 `u = (v₁ ≡ t₂)` 的两个子项都可归约，且其左子项 `v₁` 是一个值时，会产生临界对。
    设 `u = (v₁ ≡ t₂)`，其中 $v_1 \in \mathcal{V}$，且存在归约 `v₁ ⟶ v₁'` 和 `t₂ ⟶ t₂'`。

    *   **路径 1 (经由 Cong-Equiv₁):** 由于 `v₁` 可归约，我们应用 `Cong-Equiv₁`：
        `(v₁ ≡ t₂) ⟶ (v₁' ≡ t₂)`

    *   **路径 2 (经由 Cong-Equiv₂):** 由于 `v₁` 是一个值且 `t₂` 可归约，我们应用 `Cong-Equiv₂`：
        `(v₁ ≡ t₂) ⟶ (v₁ ≡ t₂')`

    *   **汇合 (Join):** 我们需要证明 `(v₁' ≡ t₂)` 和 `(v₁ ≡ t₂')` 可以汇合。
        首先，从路径 2 的结果 `(v₁ ≡ t₂')` 出发，其左子项 `v₁` 仍然可归约 (`v₁ ⟶ v₁'`)。根据 `Cong-Equiv₁` 规则，存在归约：
        `(v₁ ≡ t₂') ⟶ (v₁' ≡ t₂')`
        我们将这个结果项记为 `s = (v₁' ≡ t₂')`。现在，我们必须证明路径 1 的结果 `(v₁' ≡ t₂)` 也能归约到 `s`。

        为此，我们再次对 `v₁'` 的结构进行分析。根据 **引理 A.1.2**，由于 $v₁ \in \mathcal{V}$ 且 `v₁ ⟶ v₁'`，`v₁'` 只有两种可能：

        *   **子情况 6a: `v₁'` 是一个值 ($v₁' \in \mathcal{V}$)。**
            在这种情况下，考察路径 1 的结果 `(v₁' ≡ t₂)`。因为 `v₁'` 是一个值，且 `t₂ ⟶ t₂'`，我们可以应用 `(Cong-Equiv₂)` 规则：
            `(v₁' ≡ t₂) ⟶ (v₁' ≡ t₂')`
            这个结果恰好是 `s`。因此，两条路径在 `s` 处汇合。

        *   **子情况 6b: `v₁'` 在句法上是 `('⊥)`。**
            根据值的定义 (2.1)，项 `('⊥)` **不是一个值**。因此，对于路径 1 的结果 `(v₁' ≡ t₂) = (('⊥) ≡ t₂)`，我们**不能**应用 `(Cong-Equiv₂)` 来归约 `t₂`。唯一的归约可能性来自于其左子项 `('⊥)`。
            *   `('⊥) ⟶ ⊥`  (根据规则 `Ω-Quote⊥`)。
            *   因此，通过 `(Cong-Equiv₁)`，我们有：
                `(v₁' ≡ t₂) = (('⊥) ≡ t₂) ⟶ (⊥ ≡ t₂)`
            现在，考察项 `(⊥ ≡ t₂)`。常量 `⊥` 是一个值 ($⊥ \in \mathcal{V}_{\bot} \subset \mathcal{V}$)，且 `t₂ ⟶ t₂'`。因此，我们可以应用 `(Cong-Equiv₂)`：
                `(⊥ ≡ t₂) ⟶ (⊥ ≡ t₂')`
            所以，路径 1 的结果通过两步归约到达 `(⊥ ≡ t₂')`。即 `(v₁' ≡ t₂) ⟶* (⊥ ≡ t₂')`。

            现在考察汇合点 `s = (v₁' ≡ t₂') = (('⊥) ≡ t₂')`。
            同样地，该项的左子项可归约：
            `(('⊥) ≡ t₂') ⟶ (⊥ ≡ t₂')`  (经由 `Cong-Equiv₁` 和 `Ω-Quote⊥`)
            由于路径 2 的结果 `(v₁ ≡ t₂')` 可以一步归约到 `s`，而 `s` 又可以一步归约到 `(⊥ ≡ t₂')`，因此路径 2 的结果也可以归约到 `(⊥ ≡ t₂')`。

            两条路径最终都在 `(⊥ ≡ t₂')` 处汇合。

    在这两种子情况中，临界对都是可闭合的。

由于所有临界对都可以在有限步内汇合，我们断定 `⟶` 关系是弱合流的。∎

---

#### **A.2 强规范化 (Strong Normalization)**

**定义 A.2 (强规范化)**
一个归约关系 `⟶` 被称为强规范化的，如果不存在无限的归约序列 $t_0 \longrightarrow t_1 \longrightarrow t_2 \longrightarrow \dots$。

**证明:**
为了证明强规范化，我们构造一个度量函数 `μ: T → N`，它将每个项映射到一个自然数，并证明每一步归约都使该度量严格减小。

**定义 A.3 (度量函数 `μ`)**
对于任意项 `t`，`μ(t)` 定义如下：
*   `μ(x) = 1`
*   `μ(⊤) = 1`
*   `μ(⊥) = 1`
*   `μ('t) = μ(t) + 2`
*   `μ((t ≡ s)) = μ(t) + μ(s) + 1`
*   `μ((t s)) = 2 * μ(t) + μ(s) + 1`

我们通过对归约规则进行分析，证明对于任意归约 `t ⟶ t'`，恒有 `μ(t) > μ(t')`。

1.  **公理化规则:**
    *   **(Ω-Id):** `μ((⊤ t)) = 2μ(⊤) + μ(t) + 1 = μ(t) + 3 > μ(t)`。
    *   **(Ω-Reflect):** `μ((('t) t)) = 2μ('t) + μ(t) + 1 = 2(μ(t)+2) + μ(t) + 1 = 3μ(t) + 5 > 1 = μ(⊤)`。
    *   **(Ω-Quote⊥):** `μ('⊥) = μ(⊥) + 2 = 3 > 1 = μ(⊥)`。
    *   **(Ω-Explode):** `μ((⊥ t)) = 2μ(⊥) + μ(t) + 1 = μ(t) + 3 > 1 = μ(⊥)`。
    *   **(Ω-Eval≡):** `μ((v₁ ≡ v₂)) = μ(v₁) + μ(v₂) + 1 > 1` (对于结果 `⊤` 或 `⊥`)。

2.  **同余规则:** 我们依赖归纳假设：对于归约的子项，度量已经减小。
    *   **(Cong-App₁):** `t₁ ⟶ t₁'` 蕴含 `μ(t₁) > μ(t₁')`。
        `μ((t₁ t₂)) = 2μ(t₁) + μ(t₂) + 1 > 2μ(t₁') + μ(t₂) + 1 = μ((t₁' t₂))`。
    *   **(Cong-App₂):** `t₂ ⟶ t₂'` 蕴含 `μ(t₂) > μ(t₂')`。
        `μ((v₁ t₂)) = 2μ(v₁) + μ(t₂) + 1 > 2μ(v₁) + μ(t₂') + 1 = μ((v₁ t₂'))`。
    *   **(Cong-Quote):** `t ⟶ t'` 蕴含 `μ(t) > μ(t')`。
        `μ('t) = μ(t) + 2 > μ(t') + 2 = μ('t')`。
    *   **(Cong-Equiv₁/₂):** 证明与 `Cong-App` 类似。

由于每一步归约（无论是公理化的还是同余的）都严格地减小了度量 `μ` 的值，而 `μ` 的值域是良序集 `(N, >)`，因此不可能存在无限的归约序列。

故Ω-演算系统是强规范化的。∎

---

#### **A.3 合流性 (Confluence)**

**定理 A.6 (合流性)**
归约关系 `⟶` 是合流的。即，如果 `t ⟶* t₁` 并且 `t ⟶* t₂`，那么存在一个项 `s`，使得 `t₁ ⟶* s` 并且 `t₂ ⟶* s`。

**证明:**
1.  在 **A.1** 中，我们证明了Ω-演算是**弱合流的**。
2.  在 **A.2** 中，我们证明了Ω-演算是**强规范化的**。

根据**纽曼引理 (Newman's Lemma)**，任何满足弱合流性和强规范化的重写系统都是合流的。

因此，Ω-演算的归约关系 `⟶` 是合流的。∎

#### **A.4 逻辑一致性 (Logical Consistency)**

**定理 A.7 (求值的唯一性)**
一个项的求值结果是唯一的。如果 `t ⇓ v₁` 并且 `t ⇓ v₂`，那么 `v₁ = v₂`。
**证明:** 
1.  `t ⇓ v₁` 意味着 `t ⟶* v₁` 且 `v₁` 是一个范式值。
2.  `t ⇓ v₂` 意味着 `t ⟶* v₂` 且 `v₂` 是一个范式值。
3.  根据 **定理 A.6 (合流性)**，存在一个项 `s` 使得 `v₁ ⟶* s` 且 `v₂ ⟶* s`。
4.  因为 `v₁` 和 `v₂` 都是范式，它们不可再归约。因此，从它们出发的多步归约序列长度必须为0。
5.  这意味着 `v₁ = s` 且 `v₂ = s`。
6.  因此，`v₁ = v₂`。∎

**定理 A.8 (逻辑一致性)**
Ω-演算在逻辑上是一致的。不存在任何项 `t`，使得 `t ⇓ ⊤` 并且 `t ⇓ ⊥`。
**证明:**
假设存在这样一个项 `t`。根据 **定理 A.7 (求值的唯一性)**，如果 `t` 同时求值为 `⊤` 和 `⊥`，则必须有 `⊤ = ⊥`。这与系统语法中 `⊤` 和 `⊥` 是两个不同的常量符号相矛盾。因此，初始假设错误，系统是逻辑一致的。∎

