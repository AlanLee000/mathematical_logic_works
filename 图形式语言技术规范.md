
### **《Axiom Trace》: 技术设计与交互规范**

**版本**: 6.0
**文档目标**: 本文档为策略解谜游戏《Axiom Trace》提供最终的技术实现蓝图。它详细定义了游戏的核心数据结构、基于形式公理的交互模型、动态布局策略、视觉设计语言以及关卡数据格式，旨在将抽象的句法依赖证明过程，转化为一种直观、流畅且逻辑严谨的视觉解谜体验。

#### **引言：逻辑即景观**

《Axiom Trace》的设计哲学是将逻辑视为一片可供探索的、动态演化的景观。游戏世界由一组句法单元及其之间永恒不变的、由形式公理定义的依赖关系构成。玩家的角色不是改变这些关系，而是作为一名探险家，通过应用公理来发现并点亮从“起点”到“终点”的证明路径。玩家的操作会实例化新的句法片段，从而扩展这片景观。本文档将详细阐述如何构建这个“逻辑即景观”的交互体验。

---

### **第一部分：核心数据结构**

```typescript
// 游戏内所有对象的唯一标识符
type TermID = number | string;

// 1.1. 术语仓库 (Term Repository)
// 用于集中管理所有Term实例，确保其唯一性。
interface TermRepository {
  // 根据哈希值查找Term
  findByHash(hash: string): Term | undefined;
  
  // 根据ID查找Term
  findById(id: TermID): Term | undefined;

  // 获取或创建一个新的Atom
  getOrCreateAtom(name: string): Atom;

  // 获取或创建一个新的Tuple
  getOrCreateTuple(childrenIds: TermID[]): Tuple;

  // 获取或创建一个新的Definition
  getOrCreateDefinition(definedId: TermID, bodyId: TermID): Definition;
  
  // 返回仓库中所有Term的迭代器
  getAllTerms(): IterableIterator<Term>;
}

// 1.2. 术语规范化原则
// 为了在游戏状态中严格对应形式系统中的字面相等关系 (≡)，所有句法单元 (Term) 的实例化
// 必须是规范化的 (canonicalized)。这意味着任何两个字面相等的项，在游戏运行的任何时刻，
// 都必须是同一个对象实例，拥有相同的 TermID。
//
// TermRepository 负责实现此原则。所有新项的创建（无论是关卡加载还是玩家动态实例化）都
// 必须通过此仓库进行。仓库内部使用项的哈希值作为内容寻址的键，以保证每个唯一的句法结构
// 只存在一个实例。此设计是维持游戏逻辑一致性的基石。

// 1.3. 句法单元 (Term) 基础接口
interface Term {
  readonly id: TermID;
  readonly type: 'atom' | 'tuple' | 'definition';
  getHash(): string; // 用于字面相等 (≡) 检查的唯一哈希值
}

// 2. 原子 (Atom)
interface Atom extends Term {
  readonly type: 'atom';
  readonly name: string;
}

// 3. 元组 (Tuple)
interface Tuple extends Term {
  readonly type: 'tuple';
  readonly children: TermID[];
}

// 4. 定义 (Definition)
interface Definition extends Term {
  readonly type: 'definition';
  readonly defined: TermID; // t₁
  readonly body: TermID;    // t₂
}

// 5. 布局节点 (LayoutNode)
interface LayoutNode {
  termId: TermID;
  parentId: TermID | null;
  children: TermID[];
  // 算法使用的临时数据
  modifier: number;
  width: number;
  height: number;
}

// 6. 关卡状态 (LevelState)
interface LevelState {
  // 存储所有已存在的句法单元
  readonly terms: Map<TermID, Term>;
  
  // 存储用于视觉布局的父子关系树
  layoutTree: Map<TermID, LayoutNode>; 

  // 存储所有项的当前稳定世界坐标
  currentLayout: Map<TermID, { x: number, y: number }>;
  
  // 存储所有项的视觉和交互状态
  termVisuals: Map<TermID, { /* ... visual data ... */ }>;
  
  // 已证明的依赖关系 R(t, u)
  provenR: Set<string>; // The dynamically growing set of all proven dependencies R(t, u), representing the player's cumulative logical discoveries (lemmas). Key: "hash(t)->hash(u)"

  readonly goal: {
    startTermId: TermID;
    endTermId: TermID;
  };
  isComplete: boolean;
}
```

---

### **第二部分：公理化交互模型**

本模型的核心在于将形式推导转化为一种有状态的、流畅的路径构建体验。

#### **2.1. 游戏模式**

*   **普通模式 (Normal Mode)**: `Shift` 键未被按下。用于场景交互和准备工作。
*   **连接模式 (Connection Mode)**: `Shift` 键被按下。用于构建和扩展句法依赖 `R` 证明链。

#### **2.2. 核心状态变量 (仅在连接模式下激活)**

*   **`transitiveRoot`**: `Term`。当前正在构建的传递链的**起点**。
*   **`activeSource`**: `Term`。传递链的**当前末端**。
*   **`previewLayout`**: `Map<TermID, { x: number, y: number }> | null`。用于存储和预览因潜在操作导致的布局变化。

#### **2.3. 进入连接模式 & 开启证明链**

1.  **从现有项开始**:
    *   **触发**: 在普通模式下，单击选中一个项 `T`。然后**按住 `Shift` 键**。
    *   **系统响应**: 进入连接模式，设置 `transitiveRoot = T` 和 `activeSource = T`，并立即计算高亮合法目标。

2.  **从新切片开始**:
    *   **触发**: 在普通模式下，在某个元组 `S` 的可视化区域内，通过**鼠标长按并拖拽**选中一个或多个连续子项，形成一个切片 `U`。在选中状态下，**按住 `Shift` 键**。
    *   **系统响应**:
        1.  进入连接模式。
        2.  若 `U` 是一个新的句法单元，系统将其实例化并为其分配 `TermID`。
        3.  自动推导并记录 `R(S, U)`。
        4.  在 `layoutTree` 中将 `U` 添加为 `S` 的子节点。
        5.  设置 `transitiveRoot = S` 和 `activeSource = U`。
        6.  **触发布局预览** (详见第四部分)，平滑动画展示因 `U` 的加入而导致的布局变化。
        7.  基于 `activeSource` (`U`) 计算并高亮所有合法目标。
3. **从空元组切片开始**
    *   **触发**: 在普通模式下，在一个空元组`()`项上**长按不动**。一个圆形进度条将出现并填满，表示手势被识别。识别完成后按住`Shift`键。
    *   **系统响应**: 响应与“从新切片开始”类似，其中切片`U`为`()`本身。

#### **2.4. 在连接模式中构建证明**


1. 合法目标的计算与高亮:

当 `activeSource` 为 `T` 时，系统会实时计算并高亮所有满足以下**任一条件**的句法单元 `U`：

| 规则名称                    | 形式依据                         | 游戏内涵义 (当源头为 `T` 时，`U` 为合法目标，如果...)                                                                                                                                                                                                                                                                                     |
| :---------------------- | :--------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **自反 (Self)**           | `(R-Reflex)`                 | `U` 与 `T` 字面相等 (`U ≡ T`)。                                                                                                                                                                                                                                                                                              |
| **构成 (Component)**      | `(R-Comp)`                   | `U` 是 `T` 的直接组成部分。                                                                                                                                                                                                                                                                                                     |
| **源头切片 (Source Slice)** | `(R-Reflex)` + `(R-Sub-Dep)` | `U` 是 `T` 的一个子片段 (`U ⊑ T`)。**交互方式**: 玩家可以直接在 `activeSource` (`T`) 上通过悬停和拖拽选择一个子片段 `U`。                                                                                                                                                                                                                                 |
| **传递推进 (Chain)**        | `(R-Trans)`                  | `R(T, U)` 的关系**已经**存在于 `provenR` 集合中。                                                                                                                                                                                                                                                                                  |
| **继承 (Inherit)**        | `(R-Inherit)`                | `T` 是一个定义 `(t₁:=t₂)`，且 `R(t₂, U)` 的关系**已经**存在于 `provenR` 集合中。                                                                                                                                                                                                                                                          |
| **目标切片 (Target Slice)** | `(R-Sub-Dep)`                | 存在某个项 `S`，使得 `R(T, S)` **已经**在 `provenR` 中，且 `U` 是 `S` 的一个子片段 (`U ⊑ S`)。**交互方式**: 任何满足 `R(T, S)` 的项 `S` 都会成为一个“可切片区域”。玩家可通过以下方式选择 `U`：<ul><li>**选择自身**: 对于任意类型的 `S`，其整体都会高亮为一个合法目标。直接单击 `S` 即代表选择 `U ≡ S` 作为切片。</li><li>**选择子片段**: 若 `S` 为元组，当鼠标悬停于 `S` 上时，玩家还可以通过拖拽来选择一个更小的子片段 `U`。该 `U` 会作为一个临时的、可点击的目标出现。</li></ul> |
 
 2.  **完成连接**:
     *   **触发**: 在 `Shift` 键保持按下的状态，玩家单击任意一个被高亮的合法目标 `U`（包括通过悬停和拖拽动态选择的切片）。
     *   **系统响应**:
         1. **证明并记录新引理**: 设完成连接前的 `activeSource` 为 `T`，新选择的目标为 `U`。系统将在 `provenR` 集合中永久性地添加两条新引理：
		    *   **直接引理**: `R(T, U)`。这代表了本次交互直接证明的、从上一步到当前步骤的依赖关系。
		    *   **传递性引理**: `R(transitiveRoot, U)`。这是利用传递性（`R(transitiveRoot, T)` 和 `R(T, U)`）自动导出的结论。
		    此机制确保了所有证明步骤，无论是局部的还是全局的，都被忠实记录，从而构建一个可供未来所有证明复用的、健壮的引理知识库。
         2.  **更新证明链状态**: `U` 成为新的 `activeSource`。`transitiveRoot` 保持不变，允许玩家基于刚证明的结果继续向前推进当前的证明链。
         3.  **视觉化临时链条**: 创建或延长一条从 `transitiveRoot` 经由路径上所有中间 `activeSource`、最终指向新 `activeSource` (`U`) 的**临时依赖弧**（详见 3.3）。
         4.  **固化新项**: 若 `U` 是一个新实例化的项，`layoutTree` 将被更新，`currentLayout` 也被 `previewLayout` 替换，新项的布局被正式固化。
         5.  **重新计算目标**: 系统基于新的 `activeSource` (`U`) 立即重新计算并高亮下一批合法目标。

#### **2.5. 结束会话并提交证明**

退出连接模式并非取消操作，而是标志着一次成功的证明会话的完成。

 *   **触发**: 玩家在任何时候**松开 `Shift` 键**。
 *   **系统响应**:
     1.  **提交所有新证明**: 本次连接模式会话中所有被添加到 `provenR` 集合的依赖关系，都将被视为已完成的证明。它们所对应的视觉依赖弧将从“临时”状态转变为“已提交”状态（详见 3.3），成为逻辑景观的永久组成部分。
     2.  **清空会话状态**: 游戏退出连接模式。`transitiveRoot` 和 `activeSource` 的高亮消失，临时状态变量被清空，为下一次独立的证明会话做准备。
     3.  **保留所有实例化项**: 在会话中被实例化并参与了成功证明的所有新项（如切片），都将被永久保留在游戏世界中。
     4.  **布局固化**: 若在会话中有 `previewLayout` 生成并被固化，则布局保持在最终状态。不会发生任何还原。

---

### **第三部分：视觉设计与用户界面**

#### **3.1. 画布与视角**

*   **画布**: 游戏世界呈现在一个无限大的逻辑画布上。
*   **视角控制**: 玩家可以通过拖拽画布背景自由平移和缩放视角。
*   **项的不可拖动性**: 任何句法单元的视觉实体都**不可被玩家直接拖动**，以确保选择和切片操作的精确性。

#### **3.2. 视觉元素与状态反馈**

*   **句法单元**: 每种类型 (`Atom`, `Tuple`, `Definition`) 都有独特的、可识别的视觉外形和固定的样式。
*   **状态高亮**:
    *   **`transitiveRoot`**: 独特的、持续脉动的金色辉光。
    *   **`activeSource`**: 清晰的、高亮的银色轮廓。
    *   **合法目标 (静态)**: 已存在的项作为合法目标时，以醒目的绿色高亮。
    *   **合法目标 (动态/切片)**:
        *   **悬停**: 鼠标悬停在可实例化的切片区域时，该区域以绿色高亮。
        *   **拖拽**: 长按拖拽时，一个实时变化的判定框将包围所选区域。框体颜色（绿色/红色）实时反馈当前选择是否为合法切片。
*   **依赖弧**: 带有方向的平滑曲线。玩家可点击并拖拽其中点或端点控制柄，自由调整其曲率以整理画布，此操作不影响任何逻辑。

 #### **3.3. 证明状态的视觉化**

为了清晰地区分构造中的证明与已完成的理论，依赖弧需要两种不同的视觉形态。

 *   **临时依赖弧 (In-Progress Proof Arc)**: 当玩家处于**连接模式**时，代表当前从 `transitiveRoot` 到 `activeSource` 的证明链的视觉弧。它应具有动态、不稳定的外观，例如：
    *   使用虚线或能量流动的动画效果。
    *   颜色与 `activeSource` 的高亮色（银色）保持一致。
    *   当 `activeSource` 移动时，该弧会平滑地延伸或重定向。

 *   **已提交依赖弧 (Committed Proof Arc)**: 代表 `provenR` 集合中一个永久记录的依赖关系。当玩家退出连接模式时，所有临时的证明弧都会转变为此形态。其外观应稳定、清晰，例如：
    *   使用坚实的、不透明的实线。
    *   采用一种中性或与主题一致的标准颜色。
    *   玩家可如前所述，自由调整其曲率以整理画布，而不影响其逻辑意义。

---

### **第四部分：动态布局策略**

#### **4.1. 布局算法**

*   **模型**: 布局基于一个后台的**布局树** (`layoutTree`)，其父子关系由项的静态构成和动态实例化共同定义。
*   **算法**: 采用确定性的**两遍式树形布局算法**（如Reingold-Tilford），根据可配置的间距参数（`levelSeparation`, `siblingSeparation`），为`layoutTree`中的所有节点计算无重叠的绝对坐标。
*   **确定性**: 每次使用相同的`layoutTree`和参数调用，算法必须产生完全相同的位置输出。

#### **4.2. 布局预览与更新机制**

1.  **触发**: 当玩家在连接模式下通过悬停或拖拽操作，可能导致一个新项`U`被实例化时，触发布局预览。
2.  **计算**: 系统在内存中构建一个包含`U`的**假设布局树**，并运行布局算法，生成一个`previewLayout`。
3.  **预览**:
    *   系统对比`currentLayout`和`previewLayout`，找出所有位置变化的项。
    *   这些项的视觉实体会通过平滑动画（例如，200ms ease-out），从当前位置移动到预览位置。
    *   新项`U`的实体会以淡入效果出现在其预览位置上。
4.  **固化**: 如果玩家点击确认操作，`layoutTree`被正式更新，`currentLayout`被`previewLayout`替换，动画结束在最终位置。
5.  **还原**: 如果玩家松开`Shift`键或将鼠标移开，触发还原动画，所有项平滑移回`currentLayout`的位置，`U`的实体淡出并被销毁。

#### **4.3. 布局稳定性原则**

尽管布局算法的确定性是基础要求，但同样重要的是**维护玩家对逻辑景观的空间心智模型的稳定性**。在动态实例化新项时，必须优先考虑布局的**局部性**和**可预测性**，以避免不必要的全局性剧变。实现时应遵循以下原则：

*   **最小化扰动**: 布局更新算法应被设计为尽可能地影响局部区域。当一个新节点 `U` 作为 `S` 的子节点被添加时，理想情况下只有 `S` 的子树和其部分祖先路径需要调整位置，而与 `S` 无关的其他独立子树应保持其世界坐标不变。
*   **增量更新**: 优先采用支持增量更新的布局算法或技术。与其在每次微小变动后都从头计算整个布局树，不如计算出位置变化的“增量”并仅对受影响的节点应用变换。
*   **用户预期的锚定**: 动画预览（如4.2节所述）至关重要，它为玩家提供了即将发生变化的视觉反馈。动画本身应清晰地展示出布局变化的“因果链”，帮助玩家理解布局调整的逻辑，而不是感觉屏幕上的对象在随机移动。

在关卡设计层面，也应避免创建初始布局极为紧凑、牵一发而动全身的结构，为动态生成的项预留合理的“呼吸空间”。此原则旨在确保游戏的视觉呈现服务于逻辑探索，而非成为认知负担。

---

### **第五部分：关卡设计与数据格式**

*   **关卡编辑器**: 提供创建 `Atom`, `Tuple`, `Definition` 的工具；目标设定；预设已证明的 `R` 关系。布局信息仅需定义静态构成关系的父子链接，初始位置将由算法自动生成。
*   **关卡数据格式 (JSON)**:
    ```json
    {
      "levelName": "Example: Dynamic Instantiation",
      "terms": [
        { "id": "t1", "type": "atom", "name": "A" },
        // ... 其他项的定义
      ],
      "layout": {
        "staticParents": [
          // 定义静态构成关系的父子链接
          { "childId": "child_term_id", "parentId": "parent_term_id" }
        ],
        "roots": ["root_term_id_1", "root_term_id_2"]
      },
      "goal": {
        "startTermId": "start_node_id",
        "endTermId": "end_node_id"
      },
      "preProvenR": [
        { "sourceHash": "hash_of_term_A", "targetHash": "hash_of_term_B" }
      ]
    }
    ```

---

### **结论**

本规范通过将形式公理转化为直接的玩家交互，并引入一个**持久化的证明知识库 (`provenR`)**，将《Axiom Trace》的核心玩法设计为一个**非线性的、构造性的理论构建体验**。玩家不再是简单地寻找一条预设的路径，而是作为一名逻辑学家，通过构建、验证并复用一系列引理，来主动地扩展和连接整个逻辑景观。

这种设计不仅通过可预测的动态布局策略解决了动态项创建的挑战，更重要的是，它**更深刻地忠实于形式系统探索与发现的本质**。通过清晰区分“证明过程”（连接模式）与“既有知识”（已提交的依赖），游戏体验将变得既严谨深刻，又极富战略性和创造性。此设计为创造一款真正独特的、体现了数学之美的逻辑解谜游戏提供了坚实、可靠且可执行的蓝图。



