# **原群等价计算 (Magmatic Equivalance Computation, MEC): 形式化规范**

## **第 1 节 语法 (Syntax)**

**定义 1.1 (字母表)**
系统的字母表 $\Sigma$ 由以下不相交的集合构成：

1.  一个可数的**变量符号集** $\mathcal{V} = \{x, y, z, ...\}$。
2.  一个包含两个**常量符号**的集合 $\mathcal{C} = \{T, \bot\}$。
3.  一个包含二元**组合构造子**的集合 $\{\cdot\}$。
4.  一个包含二元**等价构造子**的集合 $\{\text{equiv}\}$。
5.  一个包含一元**引用构造子**的集合 $\{\text{Quote\}}$。   
6.  辅助符号 `(`, `)`。

**定义 1.2 (项)**
项的集合 $\mathcal{T}$ 是满足以下条件的最小集合：

1.  **原子项**: 若 $v \in \mathcal{V}$ 或 $c \in \mathcal{C}$，则 $v$ 和 $c$ 都是项。
2.  **复合项**: 若 $t_1, t_2 \in \mathcal{T}$，则以下表达式也是项：
    *   `(· t₁ t₂)`  (组合项)
    *   `(equiv t₁ t₂)` (等价项)
    *    `(Quote t₁)` (引用项)

*我们使用S-表达式风格的前缀表示法。*

**定义 1.3 (判断)**
系统中唯一的一种判断形式是**可证等价判断**，其形式为 `t₁ ≡ t₂`，其中 $t_1, t_2 \in \mathcal{T}$。

---

## **第 2 节 证明论 (Proof Theory)**

### 2.1 规则集合

一个判断 `t₁ ≡ t₂` 是可证的（记为 `⊢ t₁ ≡ t₂`），当且仅当它可以从以下公理模式和推理规则推导得出。

#### **A. 结构与同余规则 (Structural and Congruence Rules)**

这些规则确保 `≡` 是一个同余关系。

*   **(Reflexivity)**: $\dfrac{}{\vdash t \equiv t}$
*   **(Symmetry)**: $\dfrac{\vdash t_1 \equiv t_2}{\vdash t_2 \equiv t_1}$
*   **(Transitivity)**: $\dfrac{\vdash t_1 \equiv t_2 \quad \vdash t_2 \equiv t_3}{\vdash t_1 \equiv t_3}$
*   **(Congruence)**: $\dfrac{\vdash t_1 \equiv s_1 \quad \vdash t_2 \equiv s_2}{\vdash (· \ t_1 \ t_2) \equiv (· \ s_1 \ s_2) \qquad \vdash (Quote\ t_1 ) \equiv (Quote \ s_1) \qquad \vdash (\text{equiv } t_1 \ t_2) \equiv (\text{equiv } s_1 \ s_2)}$

#### **B. 计算与数据公理 (Axioms of Computation and Data)**

*   **公理 B1 (求值规则)**:
    ```
    若 ⊢ t₁ ≡ (Quote t₂)
    --------------------
    则 ⊢ (· T t₁) ≡ t₂
    ```

#### **C. 引用与矛盾公理与规则 (Axiom and Rule of Quotation and Contradiction)**


*   **公理 C1 (忠实引用 / Faithful Quotation):**
    ```
    ⊢ (· (Quote t) t) ≡ T
    ```
    * 释义：将一个项 `t` 的引用 `(Quote t)` 应用于 `t` 本身，这个行为在系统内被断言为真 `T`。这确立了一种**参照完整性 (referential integrity)**：一个引用 `(Quote t)` 并非一个不透明的符号，而是与它所引用的对象 `t` 具有一种可通过计算验证的、忠实的关系。该公理是系统从项与其自身的表示之间的互动中产生真值 `T` 的主要内生机制。

*   **规则 C2 (底的吸收律 / Absorption Rule of Bottom):**
	```
	若 ⊢ t ≡ T
	----------- (C2-Rule)
	则 ⊢ (· ⊥ t) ≡ ⊥
	```
    * 释义：矛盾范式具有“污染性”，任何与之通过 `·` 运算结合的真的项都会坍缩为矛盾本身。这确保了系统中的矛盾不会被“稀释”或“忽视”，任何与真理结合的矛盾都将导致矛盾的延续。

#### **D. 原群等价公理 (Axioms of Magmatic Equivalence)**

*   **公理 D1 (等价之解引用):**
    ```
	⊢ (· (equiv a b) a) ≡ (· T b)
    ```
    *   **释义**: 此公理定义了“等价证明”对象的**计算功用**。它断言，代表“从 `a` 到 `b` 的路径”的证明对象 `(equiv a b)` 可以作为一个**路径遍历算子 (path-traversal operator)**。当它被应用于其起点 `a` 时，它并不简单地返回终点 `b`，而是返回对 `b` 的求值 `(· T b)`。这赋予了 `equiv` 对象一种主动的、动态的角色：它不仅仅是静态的等价声明，更是一个可执行的转换器，它消耗自身所代表的路径，以实现从起点到终点的计算迁移。

*   **公理 D2 (等价之组合性):**
    ```
    ⊢ (· (equiv a b) (equiv c d)) ≡ (equiv (· a c) (· b d))
    ```
    *   **释义**: 此公理赋予了等价证明对象**代数结构**。它断言 `equiv` 构造子与 `·` 构造子之间存在一种**同态 (homomorphism)** 关系。这意味着等价证明是**组合式 (compositional)** 的：两个独立的等价证明 `a ≡ b` 和 `c ≡ d` 可以通过 `·` 运算组合成一个单一的、更复杂的等价证明，即 `(· a c) ≡ (· b d)`。此公理是系统能够进行模块化和结构化推理的保证，它确保了项的等价性可以从其子项的等价性中构造出来。

*   **公理 D3 (等价之内旋):**
    ```
	⊢ (· a (equiv a b)) ≡ (equiv b (· a b))
    ```
    *   **释义**: 此公理定义了项与路径之间的**非对称交互**。它揭示了当一个项 `a` 应用于一条以自身为起点的路径 `(equiv a b)` 时，会发生路径的变换。这个操作并不消耗路径，而是将其“内旋”或“演化”为一条新的路径：从原路径的终点 `b` 指向“项 `a` 应用于 `b` 的结果” `(· a b)` 的新路径。此公理体现了“对路径的应用等同于路径通往应用之结果”这一核心思想，它是系统处理高阶等价性（路径之间的路径）和自引用的关键机制。

#### **E. 内化与外化规则 (Internalization and Externalization Rules)**

这组规则在元语言层面的可证等价判断 `⊢` 和对象语言层面的证明项 `(equiv ...)` 与真值 `T` 之间的关系上建立了一座关键的桥梁。它们确保了内部的证明代数与外部的证明论是忠实对应、互为镜像的。

*   **规则 E1 (内化 / Reflection)**:
    ```
    若 ⊢ t₁ ≡ t₂
    ----------- (E1-Rule)
    则 ⊢ (equiv t₁ t₂) ≡ T
    ```
    *   **释义**: 此规则将外部的可证性“内化”到系统中。它断言：如果在元语言层面我们可以构造一个从 `t₁` 到 `t₂` 的证明，那么在对象语言层面，代表该证明路径的项 `(equiv t₁ t₂)` 本身就等价于真值 `T`。换言之，一个有效的外部证明对应于一个内部被断定为“真”的证明对象。

*   **规则 E2 (外化 / Reification)**:
    ```
    若 ⊢ (equiv t₁ t₂) ≡ T
    ----------- (E2-Rule)
    则 ⊢ t₁ ≡ t₂
    ```
    *   **释义**: 此规则将内部的真值断言“外化”为外部的可证性。它确保了内部证明代数的可靠性：如果一个代表证明路径的项在系统内部被证明等价于 `T`，那么这条路径所连接的两个项 `t₁` 和 `t₂` 确实是（在外部）可证等价的。这防止了系统内部产生“虚假”的证明。

### **2.2 替换引理 (Substitution Lemma)**

在陈述和证明引理之前，我们首先明确替换的定义。

**定义 2.2.1 (替换)**
一个**替换** $\sigma$ 是一个从变量符号集 $\mathcal{V}$ 到项集 $\mathcal{T}$ 的映射，使得集合 $\{x \in \mathcal{V} \mid \sigma(x) \neq x\}$ 是有限的。我们通常将 $\sigma$ 记为 $[s_1/x_1, ..., s_n/x_n]$。
替换 $\sigma$ 在项上的应用 $t\sigma$ 被归纳定义如下：
1.  $x\sigma = \sigma(x)$，对于变量 $x \in \mathcal{V}$。
2.  $c\sigma = c$，对于常量 $c \in \mathcal{C}$。
3.  `(· t₁ t₂)σ = (· t₁σ t₂σ)`。
4.  `(equiv t₁ t₂)σ = (equiv t₁σ t₂σ)`。
5.  `(Quote t₁)σ = (Quote t₁σ)`。

**引理 2.2.2 (替换引理)**
如果 `⊢ t₁ ≡ t₂`，那么对于任意替换 $\sigma$，`⊢ t₁σ ≡ t₂σ` 也是可证的。

**证明**:
我们对 `⊢ t₁ ≡ t₂` 的**证明推导树的高度**进行结构归纳。

**1. 基础情况 (Base Case): 推导树高度为 1**
此时，`t₁ ≡ t₂` 必然是一个公理模式的实例。这意味着该判断不依赖于任何前提。

*   **(Reflexivity)**: 判断为 `t ≡ t`。应用替换 $\sigma$ 得到 `tσ ≡ tσ`，这本身就是自反性公理的一个实例，因此是可证的。
*   **公理模式 C1, D1, D2, D3**: 这些公理是模式（schemata），通过用任意项替换其元变量（如 `t`, `a`, `b`）来实例化。例如，公理 C1 的一个实例是 `(· (Quote s) s) ≡ T`，其中元变量 `t` 被项 `s` 实例化。对其应用替换 $\sigma$ 得到 `(· (Quote s) s)σ ≡ Tσ`。根据替换的定义，左侧为 `(· (Quote sσ) sσ)`，右侧为 `T` (因为常量不变)。结果 `(· (Quote sσ) sσ) ≡ T` 是公理 C1 的另一个实例（其中元变量 `t` 被项 `sσ` 实例化），因此是可证的。其他公理模式的论证完全相同。

**2. 归纳步骤 (Inductive Step): 推导树高度大于 1**
此时，`⊢ t₁ ≡ t₂` 是通过某个推理规则从一个或多个前提推导出来的，这些前提的推导树高度都小于当前推导树。我们假设替换引理对所有前提都成立（归纳假设，IH），并证明它对结论也成立。

*   **(Symmetry)**:
    $\dfrac{\vdash P \equiv Q}{\vdash Q \equiv P}$
    根据归纳假设，由 `⊢ P ≡ Q` 可得 `⊢ Pσ ≡ Qσ`。对此可证判断应用 (Symmetry) 规则，我们直接得到 `⊢ Qσ ≡ Pσ`。这正是 `(Q ≡ P)σ`，引理成立。

*   **(Transitivity)**:
    $\dfrac{\vdash P \equiv Q \quad \vdash Q \equiv R}{\vdash P \equiv R}$
    根据归纳假设，`⊢ Pσ ≡ Qσ` 和 `⊢ Qσ ≡ Rσ` 均可证。对此二者应用 (Transitivity) 规则，得到 `⊢ Pσ ≡ Rσ`，即 `(P ≡ R)σ`。引理成立。

*   **(Congruence)**:
    以组合构造子为例：$\dfrac{\vdash P_1 \equiv Q_1 \quad \vdash P_2 \equiv Q_2}{\vdash (· \ P_1 \ P_2) \equiv (· \ Q_1 \ Q_2)}$
    根据归纳假设，`⊢ P₁σ ≡ Q₁σ` 和 `⊢ P₂σ ≡ Q₂σ` 均可证。对此二者应用 (Congruence) 规则，得到 `⊢ (· P₁σ P₂σ) ≡ (· Q₁σ Q₂σ)`。根据替换的定义，这等价于 `⊢ (· P₁ P₂)σ ≡ (· Q₁ Q₂)σ`。引理成立。对于 `equiv` 和 `Quote` 构造子，论证完全相同。

*   **带前提的规则 (B1, C2, E1, E2)**: 这些规则是具有前提的推理规则模式。
    *   **规则 E1 (内化)**: $\dfrac{\vdash P \equiv Q}{\vdash (\text{equiv } P \ Q) \equiv \top}$
        根据归纳假设，由前提 `⊢ P ≡ Q` 可得 `⊢ Pσ ≡ Qσ`。将 E1 规则应用于这个新的可证判断，我们推导出 `⊢ (equiv Pσ Qσ) ≡ T`。根据替换定义，这等价于 `⊢ (equiv P Q)σ ≡ Tσ`。引理成立。
    *   **规则 B1, C2, E2**: 论证方式与 E1 完全相同。例如，对于 C2，由前提 `⊢ t ≡ T`，归纳假设给出 `⊢ tσ ≡ Tσ`，即 `⊢ tσ ≡ T`。应用 C2 规则得到 `⊢ (· ⊥ tσ) ≡ ⊥`，这正是 `((· ⊥ t) ≡ ⊥)σ`。

由于替换引理对所有公理（基础情况）和所有推理规则（归纳步骤）都成立，我们通过对证明推导树高度的结构归纳，得出结论：替换引理对 MEC 系统中所有可证的判断都成立。

**Q.E.D. (∎)**


## **第 3 节 指称语义与一致性 (Denotational Semantics and Consistency)**

本节为原群等价计算（MEC）系统构建一个指称语义模型，并基于该模型严格证明系统的可靠性（Soundness）与非平凡一致性（Non-trivial Consistency）。模型的核心是为可证等价关系 `≡` 提供一个数学释义 `≈`，该释义通过构造一个单调算子的最小不动点来定义，以恰当地处理系统中的自引用规则。

### **3.1 模型构造 (Model Construction)**

**定义 3.1 (同余关系)**
一个二元关系 $R \subseteq \mathcal{T} \times \mathcal{T}$ 被称为**同余关系**，若其是等价关系（自反、对称、传递），并且对于所有项 $t_1, t_2, s_1, s_2 \in \mathcal{T}$：
1.  若 $(t_1, s_1) \in R$ 且 $(t_2, s_2) \in R$，则 $((· \ t_1 \ t_2), (· \ s_1 \ s_2)) \in R$。
2.  若 $(t_1, s_1) \in R$ 且 $(t_2, s_2) \in R$，则 $((\text{equiv } t_1 \ t_2), (\text{equiv } s_1 \ s_2)) \in R$。
3.  若 $(t_1, s_1) \in R$，则 $((\text{Quote } t_1), (\text{Quote } s_1)) \in R$。

令 $\mathcal{C}(\mathcal{T})$ 为 $\mathcal{T}$ 上所有同余关系的集合。

**引理 3.1.1 (同余闭包的存在性)**
对于任意关系集合 $S \subseteq \mathcal{T} \times \mathcal{T}$，其**同余闭包** `Cong(S)`，即包含 $S$ 的最小同余关系，存在且唯一。

**证明**:
令 $\mathcal{K}_S = \{ R \in \mathcal{C}(\mathcal{T}) \mid S \subseteq R \}$ 为所有包含 $S$ 的同余关系的集合。该集合非空，因为它至少包含全关系 $\mathcal{T} \times \mathcal{T}$。我们证明任意多个同余关系的交集仍然是同余关系。设 $R_{int} = \bigcap_{R \in \mathcal{K}_S} R$。自反性、对称性、传递性以及对构造子的闭包性都是全称量化的性质，因此它们在交集下得以保持。例如，若 $(t_1, s_1), (t_2, s_2) \in R_{int}$，则对任意 $R \in \mathcal{K}_S$ 都有 $(t_1, s_1), (t_2, s_2) \in R$，故 $((· \ t_1 \ t_2), (· \ s_1 \ s_2)) \in R$，因此 $((· \ t_1 \ t_2), (· \ s_1 \ s_2)) \in R_{int}$。故 $R_{int}$ 是一个同余关系。它显然包含 $S$，且被包含于 $\mathcal{K}_S$ 中的任何其他关系，因此是最小的。**∎**

**引理 3.1.2 (完备格结构)**
以集合包含关系 `⊆` 为序，$(\mathcal{C}(\mathcal{T}), \subseteq)$ 构成一个完备格。

**证明**:
对于 $\mathcal{C}(\mathcal{T})$ 的任意子集 $\mathcal{X} \subseteq \mathcal{C}(\mathcal{T})$：
1.  **下确界 (Infimum)** 由交集 $\inf(\mathcal{X}) = \bigcap_{R \in \mathcal{X}} R$ 给出，根据引理 3.1.1 的证明，它是一个同余关系。
2.  **上确界 (Supremum)** 由并集的同余闭包 $\sup(\mathcal{X}) = \text{Cong}(\bigcup_{R \in \mathcal{X}} R)$ 给出。该关系包含了 $\mathcal{X}$ 中的所有元素，并且根据定义是包含该并集的最小同余关系。
由于任意子集都存在上确界和下确界，故 $(\mathcal{C}(\mathcal{T}), \subseteq)$ 是一个完备格。**∎**


**定义 3.2 (语义算子 Φ)**
我们定义一个算子 $\Phi: \mathcal{C}(\mathcal{T}) \to \mathcal{C}(\mathcal{T})$。对于任意同余关系 $R \in \mathcal{C}(\mathcal{T})$，我们首先定义一个**生成集** $G(R) \subseteq \mathcal{T} \times \mathcal{T}$：
$G(R) = R \cup A \cup B(R)$，其中：
1.  **公理生成集 A** (与 R 无关):
    *   $A_{C1} = \{ ( (· \ (\text{Quote } t) \ t), T) \mid t \in \mathcal{T} \}$
    *   $A_{D1} = \{ ((· \ (\text{equiv } a \ b) \ a), (· \ T \ b)) \mid a, b \in \mathcal{T} \}$
    *   $A_{D2} = \{ ((· \ (\text{equiv } a \ b) \ (\text{equiv } c \ d)), (\text{equiv } (· \ a \ c) \ (· \ b \ d))) \mid a, b, c, d \in \mathcal{T} \}$
    *   $A_{D3} = \{ ((· \ a \ (\text{equiv } a \ b)), (\text{equiv } b \ (· \ a \ b))) \mid a, b \in \mathcal{T} \}$
    *   $A = A_{C1} \cup A_{D1} \cup A_{D2} \cup A_{D3}$
2.  **规则生成集 B(R)** (依赖于 R):
    *   $B_1(R) = \{ ((· \ T \ t_1), t_2) \mid (t_1, (\text{Quote } t_2)) \in R \}$
    *   $B_2(R) = \{ ((· \ \bot \ t), \bot) \mid (t, T) \in R \}$
    *   $B_3(R) = \{ ((\text{equiv } t_1 \ t_2), T) \mid (t_1, t_2) \in R \}$ (对应规则 E1)
    *   $B_4(R) = \{ (t_1, t_2) \mid ((\text{equiv } t_1 \ t_2), T) \in R \}$ (对应规则 E2)
    *   $B(R) = B_1(R) \cup B_2(R) \cup B_3(R) \cup B_4(R)$

然后，我们定义 $\Phi(R) = \text{Cong}(G(R))$。

**引理 3.3 (Φ 的良定义性与单调性)**
算子 $\Phi$ 是良定义的（即对于任意 $R \in \mathcal{C}(\mathcal{T})$，$\Phi(R)$ 也是一个同余关系）且是单调的。

**证明**:
1.  **良定义性**: 对于任意 $R \in \mathcal{C}(\mathcal{T})$，其生成集 $G(R)$ 是 $\mathcal{T} \times \mathcal{T}$ 的一个子集。根据引理 3.1.1，其同余闭包 `Cong(G(R))` 存在且是一个同余关系。因此，$\Phi(R) \in \mathcal{C}(\mathcal{T})$，算子 $\Phi$ 的值域正确，是良定义的。
2.  **单调性**: 假设 $R_1, R_2 \in \mathcal{C}(\mathcal{T})$ 且 $R_1 \subseteq R_2$。我们需要证明 $\Phi(R_1) \subseteq \Phi(R_2)$。
    *   首先，我们证明 $B(R_1) \subseteq B(R_2)$。我们逐一检查 $B(R)$ 的每个组成部分：
        *   若 $((· \ T \ t_1), t_2) \in B_1(R_1)$，则 $(t_1, (\text{Quote } t_2)) \in R_1$。因 $R_1 \subseteq R_2$，故 $(t_1, (\text{Quote } t_2)) \in R_2$，从而 $((· \ T \ t_1), t_2) \in B_1(R_2)$。因此 $B_1(R_1) \subseteq B_1(R_2)$。
        *   同理，若 $((· \ \bot \ t), \bot) \in B_2(R_1)$，则 $(t, T) \in R_1 \subseteq R_2$，故 $((· \ \bot \ t), \bot) \in B_2(R_2)$。因此 $B_2(R_1) \subseteq B_2(R_2)$。
        *   同理，若 $((\text{equiv } t_1 \ t_2), T) \in B_3(R_1)$，则 $(t_1, t_2) \in R_1 \subseteq R_2$，故 $((\text{equiv } t_1 \ t_2), T) \in B_3(R_2)$。因此 $B_3(R_1) \subseteq B_3(R_2)$。
        *   同理，若 $(t_1, t_2) \in B_4(R_1)$，则 $((\text{equiv } t_1 \ t_2), T) \in R_1 \subseteq R_2$，故 $(t_1, t_2) \in B_4(R_2)$。因此 $B_4(R_1) \subseteq B_4(R_2)$。
        由此，$B(R_1) = \bigcup B_i(R_1) \subseteq \bigcup B_i(R_2) = B(R_2)$。
    *   其次，我们比较生成集 $G(R_1)$ 和 $G(R_2)$。因 $R_1 \subseteq R_2$ 且 $B(R_1) \subseteq B(R_2)$，可得 $G(R_1) = R_1 \cup A \cup B(R_1) \subseteq R_2 \cup A \cup B(R_2) = G(R_2)$。
    *   最后，同余闭包 `Cong` 操作是单调的：若 $S_1 \subseteq S_2$，则任何包含 $S_2$ 的同余关系也必然包含 $S_1$，因此包含 $S_1$ 的最小同余关系必然被包含于包含 $S_2$ 的最小同余关系。由 $G(R_1) \subseteq G(R_2)$ 可得 $\text{Cong}(G(R_1)) \subseteq \text{Cong}(G(R_2))$。
    *   综上，$\Phi(R_1) \subseteq \Phi(R_2)$。**∎**

**定义 3.4 (语义模型)**
由于 $(\mathcal{C}(\mathcal{T}), \subseteq)$ 是一个完备格（引理 3.1.2）且 $\Phi$ 是其上的单调算子（引理 3.3），根据 **Knaster-Tarski 不动点定理**，$\Phi$ 存在一个最小不动点。我们定义该最小不动点为 `≈`。

该不动点 `≈` 可通过标准的超限迭代法构造：
*   $\approx_0 = \text{Cong}(\emptyset)$ (即仅包含 `(t,t)` 的平凡同余关系)
*   $\approx_{\alpha+1} = \Phi(\approx_\alpha)$ (后继序数)
*   $\approx_\lambda = \text{Cong}(\bigcup_{\alpha < \lambda} \approx_\alpha)$ (极限序数)

此序列单调递增，故必在某个序数处稳定（该序数的上界可由格的基数给出）。Knaster-Tarski 定理保证了最小不动点的存在性，我们无需确定其稳定的具体序数。MEC 系统的语义模型定义为 **M** $= (\mathcal{T}, \approx)$。

### **3.2 可靠性证明 (Proof of Soundness)**

**定理 3.5 (可靠性)**
对于任意项 $t_1, t_2 \in \mathcal{T}$，如果 $\vdash t_1 \equiv t_2$，那么 $t_1 \approx t_2$。

**证明**:
本证明仅依赖于算子 $\Phi$ 的定义和 `≈` 作为其不动点的性质，不预设系统的一致性结论。
我们对 $\vdash t_1 \equiv t_2$ 的证明推导结构进行归纳。

**1. 基础情况 (Base Cases)**: 证明由一个公理构成。

*   **(Reflexivity)**: $\vdash t \equiv t$。根据 $\approx_0$ 的定义，$(t, t) \in \approx_0 \subseteq \approx$。
*   **(Axioms C1, D1, D2, D3)**: 这些公理模式生成的偶对，根据定义 3.2，包含在公理生成集 $A$ 中。由于对任意关系 $R$ 都有 $A \subseteq G(R) = R \cup A \cup B(R)$，因此这些偶对必然属于 $\text{Cong}(G(\approx_0)) = \Phi(\approx_0) = \approx_1$。由于构造序列是单调的，它们也包含在不动点 `≈` 中。

**2. 归纳步骤 (Inductive Steps)**: 证明由一个推理规则结尾。我们假设所有前提在模型中成立（归纳假设，IH）。

*   **(Symmetry, Transitivity, Congruence)**: 假设前提在模型中成立。由于 `≈` 是 `Φ` 的不动点，`≈ = Φ(≈)`，而 `Φ(≈)` 被定义为一个同余关系，因此 `≈` 本身就是一个同余关系。故这些结构规则在模型 `≈` 中是封闭的。
    *   例如，对于传递性：若 $\vdash t_1 \equiv t_2$ 且 $\vdash t_2 \equiv t_3$，则 $\vdash t_1 \equiv t_3$。IH: $t_1 \approx t_2$ 且 $t_2 \approx t_3$。因为 `≈` 是传递的，所以 $t_1 \approx t_3$。

*   **(Rule B1)**: 假设 `⊢ (· T t₁) ≡ t₂` 由 `⊢ t₁ ≡ (Quote t₂)` 导出。
    *   IH: $t_1 \approx (\text{Quote } t_2)$。
    *   因为 `≈` 是不动点，`≈ = Φ(≈)`。根据 $\Phi$ 的定义3.2(B1)，若 $(t_1, (\text{Quote } t_2)) \in \approx$，则 $((· \ T \ t_1), t_2) \in \Phi(≈)$。
    *   因此，$(· \ T \ t_1) \approx t_2$。

*   **(Rule C2)**: 证明同上，使用 `Φ` 的定义3.2(C2)。

*   **(Rule E1 - Internalization)**: 假设 `⊢ (equiv t₁ t₂) ≡ T` 由 `⊢ t₁ ≡ t₂` 导出。
    *   IH: $t_1 \approx t_2$。
    *   根据 $\Phi$ 的定义3.2(E1)，若 $(t_1, t_2) \in \approx$，则 $((\text{equiv } t_1 \ t_2), T) \in \Phi(≈)$。
    *   因此，$(\text{equiv } t_1 \ t_2) \approx T$。

*   **(Rule E2 - Reification)**: 假设 `⊢ t₁ ≡ t₂` 由 `⊢ (equiv t₁ t₂) ≡ T` 导出。
    *   IH: $(\text{equiv } t_1 \ t_2) \approx T$。
    *   根据 $\Phi$ 的定义3.2(E2)，若 $((\text{equiv } t_1 \ t_2), T) \in \approx$，则 $(t_1, t_2) \in \Phi(≈)$。
    *   因此，$t_1 \approx t_2$。

归纳证明完成。所有可证判断在模型中均成立。**∎**

### **3.3 非平凡一致性证明 (Proof of Non-trivial Consistency)**

一致性证明的核心是表明，在模型的任何构造阶段，`(T, ⊥)` 这个偶对都无法被引入。为此，我们首先建立两个关于模型构造过程的基础引理。

**引理 3.6.1 (闭包的有限链性质)**
若 $(x, y) \in \text{Cong}(S)$，则存在一个有限序列 $t_0, \dots, t_n \in \mathcal{T}$，使得 $x=t_0, y=t_n$，且对所有 $i \in \{0, \dots, n-1\}$，$(t_i, t_{i+1})$（或其反向 $(t_{i+1}, t_i)$）可由 $S$ 中的元素通过一次同余规则的应用（或直接就是 $S$ 的成员）导出。更简洁地说，$x$ 和 $y$ 是通过一条由 $S$ 中元素生成的有限边构成的路径连接起来的。

**证明**:
令 $R$ 为所有通过 $S$ 的元素及同余规则经有限步推导可连接的偶对 $(x,y)$ 的集合。$R$ 包含了 $S$ 并且根据其构造是自反、对称、传递和满足同余性的，因此 $R$ 是一个包含 $S$ 的同余关系。同时，任何包含 $S$ 的同余关系 $R'$ 必须包含所有这些有限推导的结果，因此 $R \subseteq R'$。故 $R$ 是包含 $S$ 的最小同余关系，即 $R = \text{Cong}(S)$。此构造本身即证明了有限链的存在性。**∎**

**引理 3.6.2 (首次出现于后继序数)**
若 $(x, y) \in \approx$ 且 $x \ne y$，则存在一个最小的序数 $\alpha$，使得 $(x, y) \in \approx_\alpha$。该最小序数 $\alpha$ 必然是一个后继序数。

**证明**:
令 $\alpha$ 是满足 $(x, y) \in \approx_\alpha$ 的最小序数。为引出矛盾，假设 $\alpha$ 是一个极限序数。
根据定义，$\approx_\alpha = \text{Cong}(\bigcup_{\gamma < \alpha} \approx_\gamma)$。
根据引理 3.6.1，若 $(x, y) \in \approx_\alpha$，则存在一条连接 $x$ 与 $y$ 的有限链，其所有边均来自集合 $S = \bigcup_{\gamma < \alpha} \approx_\gamma$。
由于该链是有限的，构成链的边 $\{e_1, \dots, e_n\}$ 也是一个有限集合。对于每一条边 $e_i \in S$，都存在一个序数 $\gamma_i < \alpha$ 使得 $e_i \in \approx_{\gamma_i}$。
令 $\beta = \max\{\gamma_1, \dots, \gamma_n\}$。由于这是一个有限的序数集合且每个成员都小于极限序数 $\alpha$，它们的上确界（最大值）$\beta$ 也必然小于 $\alpha$。
因为 `≈` 的构造序列是单调的，所以链中的所有边都属于 $\approx_\beta$。这意味着整条链存在于 $\approx_\beta$ 中，又因 $\approx_\beta$ 本身是同余关系（因此是传递的），可得 $(x, y) \in \approx_\beta$。
但这与 $\alpha$ 是满足该条件的最小序数相矛盾，因为我们找到了一个更小的序数 $\beta < \alpha$。
因此，最小序数 $\alpha$ 不可能是极限序数，它必然是一个后继序数。**∎**

现在我们引入一个关键引理，它严格限制了不同原子项之间等价关系的来源。

**引理 3.6.3 (原子对生成引理)**
令 $R \in \mathcal{C}(\mathcal{T})$ 是一个同余关系。如果 $(u, v) \in G(R)$（即 $\Phi(R)$ 的生成集），其中 $u, v \in \mathcal{C}$ 且 $u \neq v$，那么必然有 $(u, v) \in B_4(R)$。换言之，`(T, ⊥)` 或 `(⊥, T)` 只能通过规则 E2 的语义对应部分 $B_4(R)$ 进入生成集。

**证明**:
我们逐一检查 $G(R) = R \cup A \cup B(R)$ 的构成部分，寻找可能生成 `(u, v)`（其中 $u, v$ 是不同常量）的来源。
1.  **继承 (R)**: 如果 `(u, v) ∈ R`，引理的假设不适用，因为我们考虑的是新生成的对。我们稍后会在主定理中处理这种情况。
2.  **公理生成集 A**:
    *   $A_{C1}, A_{D1}, A_{D2}, A_{D3}$ 中所有偶对的左侧项都是复合项（以 `·` 开头），而右侧项可能是原子项 `T` 或复合项。它们无法生成 `(原子项, 原子项)` 形式的偶对。
3.  **规则生成集 B(R)**:
    *   $B_1(R), B_2(R)$: 这些集合中的偶对，左侧项都是复合项。
    *   $B_3(R)$: 生成的偶对形式为 `((equiv t₁ t₂), T)`，左侧是复合项。
    *   $B_4(R)$: 生成的偶对形式为 `(t₁, t₂)`，其中 `((equiv t₁ t₂), T) ∈ R`。这个条款**可以**生成 `(原子项, 原子项)` 形式的偶对，例如，当 $t_1=T, t_2=\bot$ 时。

因此，在 $A \cup B(R)$ 中，唯一能引入两个不同原子项之间偶对的来源是 $B_4(R)$。**∎**

**定理 3.6 (模型的一致性)**
在模型 M 中，$T$ 与 $\bot$ 不等价，即 $(T, \bot) \notin \approx$。

**证明**:
我们通过对构造 `≈` 的超限归纳法，证明对于任意序数 $\alpha$，$(T, \bot) \notin \approx_\alpha$。

**1. 基础情况 (α = 0)**:
$\approx_0 = \text{Cong}(\emptyset)$。该关系仅包含 `(t, t)` 形式的偶对。由于 $T \neq \bot$，显然 $(T, \bot) \notin \approx_0$。

**2. 归纳步骤 (Inductive Step)**:

*   **极限序数 λ**:
    *   归纳假设 (IH): 对所有 $\alpha < \lambda$, $(T, \bot) \notin \approx_\alpha$。
    *   为引出矛盾，假设 $(T, \bot) \in \approx_\lambda$。由于 $T \ne \bot$，根据引理 3.6.2，这与 $\lambda$ 是一个极限序数相矛盾，因为任何新偶对的首次出现必须在后继序数阶段。
    *   另一种更直接的论证是：若 $(T, \bot) \in \approx_\lambda = \text{Cong}(\bigcup_{\gamma < \lambda} \approx_\gamma)$，则根据引理 3.6.1，存在一条连接 $T$ 和 $\bot$ 的有限链，其所有边均来自 $\bigcup_{\gamma < \lambda} \approx_\gamma$。如引理 3.6.2 的证明所示，这条有限链必然完全存在于某个 $\approx_\beta$ 中（其中 $\beta < \lambda$），从而导致 $(T, \bot) \in \approx_\beta$。这直接与归纳假设相矛盾。
    *   因此，$(T, \bot) \notin \approx_\lambda$。

*   **后继序数 α+1**:
    *   归纳假设 (IH): $(T, \bot) \notin \approx_\alpha$。
    *   我们需证明 $(T, \bot) \notin \approx_{\alpha+1} = \Phi(\approx_\alpha) = \text{Cong}(G(\approx_\alpha))$。

    为引出矛盾，假设 $(T, \bot) \in \approx_{\alpha+1}$。

    1.  **定位“桥接”偶对**:
        根据同余闭包的定义及引理 3.6.1，若 $(T, \bot) \in \approx_{\alpha+1}$，则在生成集 $G(\approx_\alpha)$ 中存在一个有限的传递链 $s_0, s_1, \dots, s_n$，使得 $s_0=T, s_n=\bot$，并且对于所有 $i \in \{0, \dots, n-1\}$，有 $(s_i, s_{i+1}) \in G(\approx_\alpha)$ 或 $(s_{i+1}, s_i) \in G(\approx_\alpha)$。

        根据归纳假设 (IH)，在关系 $\approx_\alpha$ 中，$T$ 和 $\bot$ 属于不同的等价类（即 $T \not\approx_\alpha \bot$）。因此，上述传递链中必须存在至少一个“跨越”这两个等价类的偶对。即，存在某个 $k \in \{0, \dots, n-1\}$，使得 $(s_k, s_{k+1})$（或其反向）满足以下条件：
        *   $(s_k, s_{k+1}) \in G(\approx_\alpha)$
        *   $s_k \in [T]_{\approx_\alpha}$ (即 $s_k \approx_\alpha T$)
        *   $s_{k+1} \notin [T]_{\approx_\alpha}$
        
        由于整条链最终将 $s_k$ 连接到 $\bot$，而 $\approx_\alpha$ 是传递的，这意味着 $s_{k+1}$ 必须属于 $\bot$ 的等价类，即 $s_{k+1} \approx_\alpha \bot$。我们称这样的偶对 $(u, v) = (s_k, s_{k+1})$ 为一个**桥接偶对**。

    2.  **分析桥接偶对的来源**:
        该桥接偶对 `(u, v)` 必然不属于 $G(\approx_\alpha)$ 中的 `≈_α` 部分。因为若 `(u, v) ∈ ≈_α`，结合 `u ≈_α T` 和 `v ≈_α ⊥`，利用 `≈_α` 的对称性和传递性将直接导出 `T ≈_α ⊥`，这与归纳假设 (IH) 矛盾。
        因此，该桥接偶对必须来自生成集的新增部分，即 $(u, v) \in A \cup B(\approx_\alpha)$。

		我们对该桥接偶对 `(u, v)` 的来源 `A ∪ B(≈_α)` 进行系统的案例分析，以证明其唯一可能的来源是 `B_4(≈_α)`，或者其存在本身就会导致与归纳假设 (IH) 的直接矛盾。
		
		*   **情况 1: `(u, v)` 源自 `A_{C1}` 或 `B_3(≈_α)`。**
		    *   若 `(u, v) ∈ A_{C1}`，则 `u = (· (Quote t) t)` 且 `v = T`。
		    *   若 `(u, v) ∈ B_3(≈_α)`，则 `u = (equiv t₁ t₂)` 且 `v = T`，其前提为 `(t₁, t₂) ∈ ≈_α`。
		    *   在这两种情况下，我们都有 `v = T`。根据桥接偶对的定义，我们要求 `v ≈_α ⊥`，这意味着 `T ≈_α ⊥`。这直接与归纳假设 `(T, ⊥) notin ≈_α` 相矛盾。因此，该来源被排除。
		
		*   **情况 2: `(u, v)` 源自 `B_2(≈_α)`。**
		    *   则 `u = (· ⊥ t)` 且 `v = ⊥`，其前提为 `t ≈_α T`。
		    *   根据桥接偶对的定义，我们要求 `u ≈_α T`，即 `(· ⊥ t) ≈_α T`。
		    *   由于 `t ≈_α T` 且 `≈_α` 是一个同余关系，我们有 `(· ⊥ t) ≈_α (· ⊥ T)`。
		    *   通过传递性，上述两点蕴含 `T ≈_α (· ⊥ T)`。
		    *   然而，规则 C2 的一个实例是 `⊢ (· ⊥ T) ≡ ⊥`。根据已证明的可靠性定理 (3.5)，这意味着 `(· ⊥ T) ≈ ⊥`。更具体地说，由于 `T ≈_0 T`，根据 `B_2` 的定义，`((· ⊥ T), ⊥) ∈ B_2(≈_0) ⊆ G(≈_0)`，因此 `(· ⊥ T) ≈_1 ⊥`。由于构造序列是单调的，我们有 `(· ⊥ T) ≈_α ⊥` 对于所有 `α ≥ 1`。
		    *   结合 `T ≈_α (· ⊥ T)` 和 `(· ⊥ T) ≈_α ⊥`，通过传递性得到 `T ≈_α ⊥`，这与归纳假设相矛盾。因此，该来源被排除。
		
		*   **情况 3: `(u, v)` 源自 `B_1(≈_α)`。**
		    *   则 `u = (· T t₁)` 且 `v = t₂`，其前提为 `t₁ ≈_α (Quote t₂)`。
		    *   根据桥接偶对的定义，我们要求 `u ≈_α T` 且 `v ≈_α ⊥`。
		    *   `v ≈_α ⊥` 意味着 `t₂ ≈_α ⊥`。
		    *   将 `t₂ ≈_α ⊥` 代入前提 `t₁ ≈_α (Quote t₂)` 中，由于 `≈_α` 是同余关系，我们得到 `t₁ ≈_α (Quote ⊥)`。
		    *   现在考虑 `u ≈_α T`，即 `(· T t₁) ≈_α T`。再次利用同余性，将 `t₁ ≈_α (Quote ⊥)` 代入，得到 `(· T (Quote ⊥)) ≈_α T`。
		    *   然而，规则 B1 的一个实例是 `⊢ (· T (Quote ⊥)) ≡ ⊥`。与情况 2 类似，由可靠性可知 `(· T (Quote ⊥)) ≈ ⊥`，并且更具体地，`(· T (Quote ⊥)) ≈_1 ⊥`。
		    *   结合 `(· T (Quote ⊥)) ≈_α T` 和 `(· T (Quote ⊥)) ≈_α ⊥`，通过传递性得到 `T ≈_α ⊥`，这与归纳假设相矛盾。因此，该来源被排除。
		
		*   **情况 4: `(u, v)` 源自 `A_{D1}, A_{D2}, A_{D3}`。**
			此情况涵盖源自 `A_{D1}`, `A_{D2}`, 或 `A_{D3}` 的桥接偶对。这些公理的共同点是它们都具有 `⊢ p ≡ q` 的形式，其中 `p` 和 `q` 都是复合项。
			
			1.  **论证的普适性**:
			    令 `(u, v)` 是由任意一个此类公理（`A_{D1}`, `A_{D2}`, 或 `A_{D3}`）生成的偶对。这意味着系统中断言 `⊢ u ≡ v`。
			
			2.  **应用可靠性定理**:
			    根据我们已经证明的**可靠性定理 (3.5)**，任何可证的等价判断在我们的语义模型中都成立。即，如果 `⊢ u ≡ v`，那么 `u ≈ v`。
			    更进一步，由于这些公理不依赖于任何前提，它们所代表的偶对 `(u, v)` 在模型构造的初始阶段就会被引入。具体来说，根据定义 3.2，`(u, v) ∈ A`，因此 `(u, v) ∈ G(≈_0)`，这意味着 `u ≈_1 v`。由于构造序列是单调的 (`≈_1 ⊆ ≈_α` 对所有 `α ≥ 1`)，我们必然有：
			    $$u \approx_\alpha v$$
			
			3.  **与桥接偶对的定义相结合**:
			    我们正在分析的假设是 `(u, v)` 是一个**桥接偶对**。根据桥接偶对的定义，它必须满足以下两个条件：
			    *   `u ≈_α T`
			    *   `v ≈_α ⊥`
			
			4.  **推导矛盾**:
			    现在我们将上述事实串联起来。由于 `≈_α` 是一个等价关系，它满足传递性。结合我们得到的三条等价关系：
			    *   `T ≈_α u` (来自桥接偶对定义，及对称性)
			    *   `u ≈_α v` (来自公理的可靠性)
			    *   `v ≈_α ⊥` (来自桥接偶对定义)
			
			    通过传递性，我们直接推导出：
			    $$T \approx_\alpha \bot$$
			5. **结论**:
			    这个结论 `(T, ⊥) ∈ ≈_α` 直接与我们的**归纳假设 (IH)**——即 `(T, ⊥) ∉ ≈_α`——相矛盾。
			    因此，我们的初始假设“存在一个源自公理集 `A_D` 的桥接偶对”是错误的。这类公理**不可能**产生桥接偶对。

		*   **情况 5: `(u, v)` 源自 `B_4(≈_α)`。**
		    *   则 `u = t₁` 且 `v = t₂`，其前提为 `((equiv t₁ t₂), T) ∈ ≈_α`。
		    *   此规则是唯一一个对其结论 `(t₁, t₂)` 的语法结构不作任何限制的规则。它可以生成任意两个项之间的偶对，包括 `(T, ⊥)`，其代价是要求一个特定的 `equiv` 项在系统内部等价于 `T`。
		
		所有不依赖 `B_4` 的来源均已被证明会导致与归纳假设的直接矛盾。因此，如果存在一个桥接偶对 `(u, v)`，它必须源自 `B_4(≈_α)`。
		由此，我们得出结论：
		*   存在一个桥接偶对 `(u, v)`，满足 `(u, v) ∈ B_4(≈_α)`，`u ≈_α T` 且 `v ≈_α ⊥`。
		*   根据 `B_4` 的定义，这意味着前提 `((equiv u v), T) ∈ ≈_α` 成立。
		*   由于 `u ≈_α T`，`v ≈_α ⊥` 且 `≈_α` 是一个同余关系，我们可以替换 `equiv` 的参数，得到 `(equiv u v) ≈_α (equiv T ⊥)`。
		*   最后，结合 `((equiv u v), T) ∈ ≈_α` 和 `(equiv u v) ≈_α (equiv T ⊥)`，利用 `≈_α` 的对称性和传递性，我们推导出：
		    $$((\text{equiv } T \ \bot), T) \in \approx_\alpha \quad (*)$$

    3.  **最终矛盾：序数的良基性**
        我们已经证明，若 `(T, ⊥) ∈ ≈_{α+1}`，则必然 `((equiv T ⊥), T) ∈ ≈_α`。这个结论是推导最终矛盾的关键。

        为引出矛盾，我们正式化论证：
        假设系统不一致，即 `(T, ⊥) ∈ ≈`。根据引理 3.6.2，存在一个最小的后继序数 `α+1` 使得 `(T, ⊥) ∈ ≈_{α+1}`。这意味着 `(T, ⊥) ∉ ≈_α`，并且对所有 `γ < α+1` 都有 `(T, ⊥) ∉ ≈_γ`。

        根据我们刚刚完成的案例分析，` (T, ⊥) ∈ ≈_{α+1}` 蕴含了 `((equiv T ⊥), T) ∈ ≈_α`。

        现在考虑偶对 `((equiv T ⊥), T)`。由于它属于 `≈_α`，根据引理 3.6.2，同样存在一个最小的后继序数 `β+1 ≤ α` 使得 `((equiv T ⊥), T) ∈ ≈_{β+1}`。这意味着：
        *   `((equiv T ⊥), T) ∈ \text{Cong}(G(\approx_β))`
        *   `((equiv T ⊥), T) ∉ ≈_β`
        *   由于 `β < α`，根据 `α+1` 的最小性假设，我们有 `(T, ⊥) ∉ ≈_β`。

		我们分析 `((equiv T ⊥), T)` 是如何被引入 `≈_{β+1} = \text{Cong}(G(\approx_\beta))` 的。根据 `β+1` 的最小性，`((equiv T ⊥), T) ∉ ≈_β`。因此，此偶对必须通过同余闭包从 `G(\approx_\beta) \setminus ≈_β = A \cup B(≈_β)` 中的元素生成。
		
		存在两种可能性：
		
		1.  **直接生成**: `((equiv T ⊥), T)` 本身即为 `A \cup B(≈_β)` 的一个成员。
		    *   通过检查公理集 `A`，其成员 `((· (Quote t) t), T)`（来自 `A_{C1}`）与 `((equiv T ⊥), T)` 语法不匹配。其他公理的右侧项不是 `T`。
		    *   通过检查规则生成集 `B(≈_β)`，唯一能生成 `(复合项, T)` 形式偶对的是 `B_3(≈_β)`。
		    *   因此，若 `((equiv T ⊥), T)` 直接存在于 `A \cup B(≈_β)`，则必然有 `((equiv T ⊥), T) ∈ B_3(≈_β)`。
		
		2.  **间接生成**: `((equiv T ⊥), T)` 是由 `G(\approx_\beta)` 中的元素通过一次或多次同余规则（对称、传递、同余）的组合而生成的。
		    *   **同余规则**: `((equiv T ⊥), T)` 无法由同余规则直接生成，因为右侧项 `T` 是原子项，无法表示为 `(C s₁ s₂)` 的形式。
		    *   **传递性**: 若 `((equiv T ⊥), T)` 由传递性生成，则在 `G(\approx_β)` 中存在一条有限链 `s_0, ..., s_n`，使得 `$s_0 = (\text{equiv } T \ \bot)$`, `$s_n = T$`, 且对所有 `i`, `(s_i, s_{i+1})`（或其反向）在 `G(\approx_\beta)` 中。根据归纳假设 `(T, ⊥) ∉ ≈_β`，`T` 与 `⊥` 属于 `≈_β` 中不同的等价类。任何以 `(equiv ...)` 开头的项，除非通过 `B_3` 或 `A_{C1}` 与 `T` 关联，否则无法被连接到 `T` 的等价类中。而 `A_{C1}` 语法不匹配。因此，这条传递链必然包含一个形式为 `((equiv u v), T)` 且属于 `B_3(≈_β)` 的“桥接”偶对，其中 `(u, v) ∈ ≈_β`。由于 `≈_β` 的同余性，`(\text{equiv } T \ \bot) \approx_β (\text{equiv } u \ v)` 蕴含 `T \approx_β u` 且 `⊥ \approx_β v`。将后者代入前提 `(u, v) ∈ ≈_β`，利用传递性，可得 `(T, ⊥) ∈ ≈_β`。这与我们的归纳假设 `(T, ⊥) ∉ ≈_β` (因为 `β < α`) 相矛盾。
		
		两种可能性均归结为 `((equiv T ⊥), T)` 必须源自 `B_3(≈_β)`。根据 `B_3` 的定义，这要求其前提成立：
		$$(T, \bot) \in \approx_\beta$$
		这与我们已知的 `(T, ⊥) ∉ ≈_β` (因 `β < α`) 相矛盾。

        这个矛盾证明了我们的中间结论 `((equiv T ⊥), T) ∈ ≈_α` 是错误的。因此，导致此结论的初始假设——`(T, ⊥) ∈ ≈_{α+1}`——也必然是错误的。

通过超限归纳法，我们证明了对所有序数 $\alpha$，$(T, \bot) \notin \approx_\alpha$。因此，$(T, \bot) \notin \approx$。**∎**

**推论 3.7 (MEC 的非平凡一致性)**
系统 MEC 是非平凡一致的，即 `⊢ T ≡ ⊥` 不可证。

**证明**:
假设 `⊢ T ≡ ⊥` 可证。根据定理3.5（可靠性），可得 $T \approx \bot$。但这与定理3.6相矛盾。因此，假设不成立，`⊢ T ≡ ⊥` 不可证。**∎**

## **第 4 节 代数性质分析 (Analysis of Algebraic Properties)**

本节将利用第 3 节构建的指称语义模型 **M** $= (\mathcal{T}, \approx)$，对 `equiv` 构造子的基础代数性质进行形式化分析。我们将严格证明，在 MEC 系统的语义中，`equiv` 构造子既不满足交换律，也不满足结合律。

### **4.1 交换律 (Commutativity)**

**定理 4.1.1 (equiv 的非交换性)**
`equiv` 构造子不满足交换律。即存在项 $a, b \in \mathcal{T}$，使得 `(equiv a b) ≈ (equiv b a)` 不成立。

**证明**:
我们将通过反例证明此定理。令 $a = T$，$b = \bot$。我们将证明 `((equiv T ⊥), (equiv ⊥ T)) ∉ ≈`。

采用反证法。假设 `((equiv T ⊥), (equiv ⊥ T)) ∈ ≈`。

根据模型 `≈` 的构造（定义 3.4），`≈` 是算子 $\Phi$ 的最小不动点，由超限归纳法定义的一系列同余关系 `≈_α` 的极限构成。如果一个偶对属于 `≈`，它必须在某个构造阶段被引入。令 $\alpha$ 为最小的使得 `((equiv T ⊥), (equiv ⊥ T)) ∈ ≈_α` 的序数。

1.  **基础情况 (α = 0)**:
    `≈_0` 仅包含 `(t, t)` 形式的偶对。由于 `(equiv T ⊥)` 与 `(equiv ⊥ T)` 在语法上是不同的项，故 `((equiv T ⊥), (equiv ⊥ T)) ∉ ≈_0`。

2.  **极限序数情况 (α = λ)**:
    假设 `α = λ` 是一个极限序数。则 `≈_λ = Cong(⋃_{γ < λ} ≈_γ)`。
    若 `((equiv T ⊥), (equiv ⊥ T)) ∈ ≈_λ`，由于此偶对的两项具有相同的顶层构造子 `equiv`，它只能通过同余闭包中的 **Congruence** 规则生成。这意味着其子项必须在 `⋃_{γ < λ} ≈_γ` 中满足相应的关系，即：
    *   `(T, ⊥) ∈ ⋃_{γ < λ} ≈_γ`
    *   `(⊥, T) ∈ ⋃_{γ < λ} ≈_γ`
    
    这蕴含了存在某个序数 `γ < λ` 使得 `(T, ⊥) ∈ ≈_γ`。然而，这与**定理 3.6 (模型的一致性)** 直接矛盾，该定理证明了对于任意序数 `γ`，`(T, ⊥) ∉ ≈_γ`。因此，`α` 不可能是一个极限序数。

3.  **后继序数情况 (α = β+1)**:
    `α` 必然是一个后继序数。这意味着 `((equiv T ⊥), (equiv ⊥ T)) ∈ ≈_{β+1} = \Phi(≈_β) = Cong(G(≈_β))`。
    根据 `α` 的最小性，我们有 `((equiv T ⊥), (equiv ⊥ T)) ∉ ≈_β`。

    我们分析该偶对是如何从 `G(≈_β)` 通过同余闭包 `Cong` 产生的。
    *   该偶对不可能直接存在于生成集 `G(≈_β) = ≈_β ∪ A ∪ B(≈_β)` 中。
        *   它不在 `≈_β` 中（根据最小性）。
        *   通过检查公理集 `A` 和规则生成集 `B(≈_β)` 的语法形式（定义 3.2），没有任何规则可以直接生成两个不同的 `(equiv ...)` 项之间的偶对。
    *   因此，该偶对必须是通过 **Congruence** 规则从 `G(≈_β)` 推导出来的。与极限序数情况的分析相同，这要求 `(T, ⊥) ∈ G(≈_β)`。

    现在的问题归结为：`(T, ⊥)` 是否可能属于 `G(≈_β)`？
    *   根据定理 3.6 的证明过程，我们知道 `(T, ⊥) ∉ ≈_β`。
    *   根据**引理 3.6.1 (原子对生成引理)**，在 `G(R)` 的所有构成部分中，唯一能引入两个不同常量（如 `T` 和 `⊥`）之间偶对的来源是 `B_4(R)`。
    *   因此，若 `(T, ⊥) ∈ G(≈_β)`，则必有 `(T, ⊥) ∈ B_4(≈_β)`。根据 `B_4` 的定义，这要求 `((equiv T ⊥), T) ∈ ≈_β`。

    然而，在**定理 3.6** 的证明中，已通过归纳法证明了 `((equiv T ⊥), T)` 不可能属于任何 `≈_β`，因为这会递归地要求 `(T, ⊥)` 属于一个更早阶段的 `≈_γ`（其中 `γ < β`），从而导致与归纳假设的矛盾。

综上所述，推导 `((equiv T ⊥), (equiv ⊥ T)) ∈ ≈` 的所有可能路径均被阻塞，因为它们都依赖于一个与模型一致性相矛盾的前提。因此，我们最初的假设是错误的。

故 `((equiv T ⊥), (equiv ⊥ T)) ∉ ≈`。 **∎**

### **4.2 结合律 (Associativity)**

**定理 4.2.1 (equiv 的非结合性)**
`equiv` 构造子不满足结合律。即存在项 $a, b, c \in \mathcal{T}$，使得 `(equiv (equiv a b) c) ≈ (equiv a (equiv b c))` 不成立。

**证明**:
我们将通过反例证明此定理。令 $a = T$, $b = \bot$, $c = T$。我们将证明 `((equiv (equiv T ⊥) T), (equiv T (equiv ⊥ T))) ∉ ≈`。

采用反证法。假设 `((equiv (equiv T ⊥) T), (equiv T (equiv ⊥ T))) ∈ ≈`。

令 `α` 为最小的使得此偶对属于 `≈_α` 的序数。与定理 4.1.1 的证明类似，通过排除基础情况和极限序数情况，`α` 必须是一个后继序数 `β+1`。

这意味着 `((equiv (equiv T ⊥) T), (equiv T (equiv ⊥ T))) ∈ ≈_{β+1} = Cong(G(≈_β))`，并且该偶对不在 `≈_β` 中。

我们分析此偶对的来源。
*   该偶对不可能直接存在于生成集 `G(≈_β)` 中，因为 `A` 和 `B(≈_β)` 中没有匹配的语法范式。
*   因此，它必须是通过 **Congruence** 规则从 `G(≈_β)` 推导出来的。这要求其对应的子项偶对必须存在于 `G(≈_β)` 中：
    1.  `((equiv T ⊥), T) ∈ G(≈_β)`
    2.  `(T, (equiv ⊥ T)) ∈ G(≈_β)`

我们集中分析第一个前提：`((equiv T ⊥), T) ∈ G(≈_β)`。
这个偶对是如何进入生成集 `G(≈_β) = ≈_β ∪ A ∪ B(≈_β)` 的？
1.  **来源 A (公理)**: `A` 中形如 `(..., T)` 的公理是 `A_{C1}`，即 `((· (Quote t) t), T)`。` (equiv T ⊥)` 与 `(· (Quote t) t)` 语法不匹配。
2.  **来源 B (规则)**: `B(≈_β)` 中能生成 `(..., T)` 形式偶对的是 `B_3(≈_β)`（对应规则 E1）。根据其定义：
    `((equiv t₁ t₂), T) ∈ B_3(≈_β)` 当且仅当 `(t₁, t₂) ∈ ≈_β`。
    为了生成 `((equiv T ⊥), T)`，必须满足前提 `(T, ⊥) ∈ ≈_β`。
3.  **来源 ≈_β**: 即 `((equiv T ⊥), T) ∈ ≈_β`。但这与 `α = β+1` 是该偶对首次出现的最小序数这一假设相矛盾（除非该偶对是通过其他方式进入 `G(≈_β)` 的，但我们已经排除了其他可能性）。

因此，`((equiv T ⊥), T) ∈ G(≈_β)` 的唯一可能性是 `(T, ⊥) ∈ ≈_β`。

然而，**定理 3.6 (模型的一致性)** 已经证明了对于任何序数 `β`，`(T, ⊥) ∉ ≈_β`。

由于推导结合律所需的核心前提 `((equiv T ⊥), T) ∈ G(≈_β)` 无法在一致的模型中得到满足，我们最初的假设 `((equiv (equiv T ⊥) T), (equiv T (equiv ⊥ T))) ∈ ≈` 必然是错误的。

故 `((equiv (equiv T ⊥) T), (equiv T (equiv ⊥ T))) ∉ ≈`。 **∎**

