### 引用反射逻辑扩展真理版
#### 1. 语法 (Syntax)

##### 1.1 字母表 (Alphabet)

1.  **变量 (Variables):** 一个可数无穷集合 `V = {x, y, z, ...}`。
2.  **常量 (Constants):** 集合 `C = {T, ⊥, Eval}`。
    *   `T`: 真理范式 (Truth Canonical Form)。
    *   `⊥`: 矛盾范式 (Contradiction Canonical Form)。
    *  `Eval`: 求值常量。
3.  **构造子 (Constructors):**
    *   `·` : 二元构造子 (Binary Constructor)。
    *   `Neg` : 一元否定构造子 (Unary Negation Constructor)。
    *   `Quote` : 一元引用构造子 (Unary Quotation Constructor)。
    *    `P` : 一元真理构造子 (Unary Truth Constructor)
4.  **关系符号 (Relational Symbol):**
    *   `≡` : 等价关系符号。
5.  **辅助符号 (Auxiliary Symbols):** `(`, `)`.

##### 1.2 项 (Terms)

项的集合 `Term` 是满足以下条件的最小集合：
1.  **原子项:** 如果 `v ∈ V` 或 `c ∈ C`，则 `v` 和 `c` 都是项。
2.  **复合项:** 如果 `t₁` 和 `t₂` 是项，则以下表达式也是项：
    *   `(· t₁ t₂)`
    *   `(Neg t₁)`
    *   `(Quote t₁)`

*注：我们使用S-表达式风格的前缀表示法来强调构造子的非结合性与非交换性。*

##### 1.3 公式 (Formulae)

系统中唯一的一种公式是等价断言：
*   如果 `t₁` 和 `t₂` 是项，则 `t₁ ≡ t₂` 是一个公式。

#### 2. 推理系统 (Deductive System)

推理系统定义了可证等价关系 `⊢ t₁ ≡ t₂`，意为“`t₁ ≡ t₂` 是一个定理”。它由一组公理模式和推理规则构成。

##### 2.1 A组：等价与同余规则 (Equivalence and Congruence)

*   **A1 (自反性 / Reflexivity):**
    对于任意项 `t`，
    ```
    ⊢ t ≡ t
    ```

*   **A2 (对称性 / Symmetry):**
    若 `⊢ t₁ ≡ t₂`，则
    ```
    ⊢ t₂ ≡ t₁
    ```

*   **A3 (传递性 / Transitivity):**
    若 `⊢ t₁ ≡ t₂` 且 `⊢  t₂ ≡ t₃`，则
    ```
    ⊢ t₁ ≡ t₃
    ```

*   **A4 (同余性 / Congruence):**
    若 `⊢ t₁ ≡ s₁` 且 `⊢ t₂ ≡ s₂`，则
    1.  `⊢ (· t₁ t₂) ≡ (· s₁ s₂)`
    2.  `⊢ (Neg t₁) ≡ (Neg s₁)`
    3.  `⊢ (Quote t₁) ≡ (Quote s₁)`

##### 2.2 B组：真理结构规则 (Truth Structure)

*   **B1 (真理定义公理):**
    ```
    ⊢ (· t T) ≡ t
    ```
    *释义：项的真理断言是其自身，这是真理结构的稳定基础。*

##### 2.3 C组：否定与矛盾规则 (Negation and Contradiction)

*   **C1 (构造性矛盾公理 / Axiom of Constructive Contradiction):**
    对于任意项 `t`，
    ```
    ⊢ (Neg (· t (Neg t))) ≡ ⊥
    ```
    *释义：一个项与其否定的特定组合，再经由否定构造，其结构就是矛盾范式。这定义了否定的核心性质。*

*   **C2 (爆炸规则 / Rule of Explosion):**
	```
	若 ⊢ t ≡ T
	----------- (C2-Rule)
	则 ⊢ (· ⊥ t) ≡ ⊥
	```
    *释义：矛盾范式具有“污染性”，任何与之通过 `·` 运算结合的真的项都会坍缩为矛盾本身。*

*    **C3 (否定异质性公理)**

```
	⊢ (Neg ⊥) ≡ ⊥
```

##### 2.4 D组：引用与反射规则 (Quotation and Reflection)

*   **D1 (引用断言规则 / Rule of Quoted Assertion):**
    对于任意项`t`
    ```
    ⊢ (· (Quote t) t) ≡ T
    ```
    *释义：引用一个项的行为本身如果是忠实的，在外部被视为一个真断言。*

*   **D2 (反射规则 / Rule of Reflection):**
    若 `⊢ t ≡ ⊥`，则
    ```
    ⊢ (Quote t) ≡ ⊥
    ```
    *释义：如果一个项的内部计算（证明）结果是矛盾，那么对该项的引用本身也等价于矛盾。这是连接对象层次和元层次的关键桥梁。*

##### 2.5 E组：求值规则 (Evaluation)

*   **E1 (求值规则)**:
    ```
    若 ⊢ t₁ ≡ (Quote t₂)
    --------------------
    则 ⊢ (· Eval t₁) ≡ t₂
    ```

### 3. 系统定理

#### **定理 1：`T` 是 `Quote` 的不动点。**
```
⊢ (Quote T) ≡ T
```
**证明**:
1.  `⊢ (· (Quote T) T) ≡ T`
    *   **理由**: 公理 **D1** `(· (Quote t) t) ≡ T`，将元变量 `t` 实例化为常量 `T`。

2.  `⊢ (· (Quote T) T) ≡ (Quote T)`
    *   **理由**: 公理 **B1** `(· t T) ≡ t`，将元变量 `t` 实例化为项 `(Quote T)`。

3.  `⊢ (Quote T) ≡ T`
    *   **理由**: 综合步骤 (1) 和 (2) 的结论。根据对称性 **A2**，由 (1) 得 `⊢ T ≡ (· (Quote T) T)`。再结合 (2) `⊢ (· (Quote T) T) ≡ (Quote T)`，应用传递性 **A3**，即得 `⊢ T ≡ (Quote T)`。

#### **定理 2：`⊥` 是 `Quote` 的不动点。**
```
⊢ (Quote ⊥) ≡ ⊥
```
**证明**:
1.  `⊢ ⊥ ≡ ⊥`
    *   **理由**: 公理 **A1** (自反性)。

2.  `⊢ (Quote ⊥) ≡ ⊥`
    *   **理由**: 应用反射规则 **D2** 于步骤 (1) 的结论。规则 **D2** 的前提是 `⊢ t ≡ ⊥`，我们将 `t` 实例化为 `⊥`，前提 `⊢ ⊥ ≡ ⊥` 已由步骤 (1) 满足。

#### **定理 3：`T` 的幂等性 (Idempotence of `T`)**
```
⊢ (· T T) ≡ T
```
**证明**:
1.  `⊢ (· t T) ≡ t`
    *   **理由**: 公理 **B1**。
2.  将元变量 `t` 实例化为常量 `T`，即得 `⊢ (· T T) ≡ T`。

#### **定理 4：矛盾与真的结合 (Combination of Contradiction and Truth)**
```
⊢ (· ⊥ T) ≡ ⊥
```
**证明**:
1.  `⊢ T ≡ T`
    *   **理由**: 公理 **A1**。
2.  步骤 (1) 满足爆炸公理 **C2** 的前提 `⊢ t ≡ T` (其中 `t` 被实例化为 `T`)。
3.  应用 **C2-Rule**，可得 `⊢ (· ⊥ T) ≡ ⊥`。

#### **定理 5：矛盾的自我结合 (Self-Combination of Contradiction)**
```
⊢ (· ⊥ ⊥) ≡ T
```
**证明**:
1.  `⊢ (· (Quote ⊥) ⊥) ≡ T`
    *   **理由**: 公理 **D1** `(· (Quote t) t) ≡ T`，将 `t` 实例化为 `⊥`。

2.  `⊢ (Quote ⊥) ≡ ⊥`
    *   **理由**: **定理 2**。

3.  `⊢ (· (Quote ⊥) ⊥) ≡ (· ⊥ ⊥)`
    *   **理由**: 根据步骤 (2) 的结论 `⊢ (Quote ⊥) ≡ ⊥` 和同余性 **A4**，对 `·` 构造子的第一个参数进行替换。

4.  `⊢ T ≡ (· ⊥ ⊥)`
    *   **理由**: 由步骤 (1) `⊢ T ≡ (· (Quote ⊥) ⊥)` 和步骤 (3) `⊢ (· (Quote ⊥) ⊥) ≡ (· ⊥ ⊥)`，应用传递性 **A3**。

5.  `⊢ (· ⊥ ⊥) ≡ T`
    *   **理由**: 对步骤 (4) 的结论应用对称性 **A2**。

#### **定理 6：求值的基本定理 (Fundamental Theorem of Evaluation)**
对于任意项 `t`，
```
⊢ (· Eval (Quote t)) ≡ t
```
**证明**:
1.  `⊢ (Quote t) ≡ (Quote t)`
    *   **理由**: 公理 **A1** (自反性)。

2.  将步骤 (1) 的结论作为求值规则 **E1** 的前提。在 **E1** 中，令 `t₁ = (Quote t)` 且 `t₂ = t`。前提 `⊢ t₁ ≡ (Quote t₂)` 已被步骤 (1) 满足。

3.  应用 **E1** 规则，即得结论 `⊢ (· Eval (Quote t)) ≡ t`。

#### **定理 7：`Eval` 与 `T` 的等价性**
```
⊢ Eval ≡ T
```
**证明**:
1.  `⊢ (· Eval (Quote T)) ≡ T` (**定理 6**，`t` 实例化为 `T`)
2.  `⊢ (Quote T) ≡ T` (**定理 1**)
3.  `⊢ (· Eval T) ≡ (· Eval (Quote T))` (由 (2) 和同余性 **A4.1**)
4.  `⊢ (· Eval T) ≡ T` (由 (3) 和 (1) 及传递性 **A3**)
5.  `⊢ (· Eval T) ≡ Eval` (公理 **B1**，`t` 实例化为 `Eval`)
6.  `⊢ Eval ≡ T` (由 (4) 和 (5) 及传递性 **A3**、对称性 **A2**)

#### **定理 8：`T` 的否定是 `⊥`**
```
⊢ (Neg T) ≡ ⊥
```
**证明**:
1.  `⊢ (· (Quote ⊥) ⊥) ≡ T` (公理 **D1**，`t` 实例化为 `⊥`)
2.  `⊢ (Neg (· (Quote ⊥) ⊥)) ≡ (Neg T)` (由 (1) 和同余性 **A4.2**)
3.  `⊢ (Quote ⊥) ≡ ⊥` (**定理 2**)
4.  `⊢ (Neg (· ⊥ ⊥)) ≡ (Neg (· (Quote ⊥) ⊥))` (由 (3) 和同余性 **A4**)
5.  `⊢ (Neg (· ⊥ ⊥)) ≡ (Neg T)` (由 (4) 和 (2) 及传递性 **A3**)
6.  `⊢ (Neg (· ⊥ (Neg ⊥))) ≡ ⊥` (公理 **C1**，`t` 实例化为 `⊥`)
7.  `⊢ (Neg ⊥) ≡ ⊥` (公理 **C3**)
8.  `⊢ (Neg (· ⊥ ⊥)) ≡ ⊥` (将 (7) 代入 (6)，由同余性 **A4**)
9.  `⊢ (Neg T) ≡ ⊥` (由 (5) 和 (8) 及传递性 **A3**、对称性 **A2**)

#### **定理 9：`T` 作为左逆 (Left Inverse Property of `T`)**
对于任意项 `t`，
```
⊢ (· T (Quote t)) ≡ t
```
**证明**:
1.  `⊢ (· Eval (Quote t)) ≡ t`
    *   **理由**: **定理 6**。
2.  `⊢ Eval ≡ T`
    *   **理由**: **定理 7**。
3.  `⊢ (· T (Quote t)) ≡ (· Eval (Quote t))`
    *   **理由**: 由步骤 (2) 和 `⊢ (Quote t) ≡ (Quote t)` (公理 **A1**)，应用同余规则 **A4.1**。
4.  `⊢ (· T (Quote t)) ≡ t`
    *   **理由**: 将步骤 (3) 和步骤 (1) 通过传递性 **A3** 连接。

#### **定理 10：双重否定的不对称性 (Asymmetry of Double Negation)**
```
⊢ (Neg (Neg T)) ≡ ⊥
```
**证明**:
1.  `⊢ (Neg T) ≡ ⊥` (定理 8)
2.  `⊢ (Neg (Neg T)) ≡ (Neg ⊥)` (步骤 1, 同余性 A4.2)
3.  `⊢ (Neg ⊥) ≡ ⊥` (公理 C3)
4.  `⊢ (Neg (Neg T)) ≡ ⊥` (步骤 2, 3, 传递性 A3)

#### **定理 11：双重否定下的矛盾不动点 (Fixed Point of Contradiction under Double Negation)**
```
⊢ (Neg (Neg ⊥)) ≡ ⊥
```
**证明**:
1.  `⊢ (Neg ⊥) ≡ ⊥`
    *   **理由**: 公理 **C3**。
2.  `⊢ (Neg (Neg ⊥)) ≡ (Neg ⊥)`
    *   **理由**: 根据步骤 (1) 的结论和同余性规则 **A4.2**。
3.  `⊢ (Neg (Neg ⊥)) ≡ ⊥`
    *   **理由**: 综合步骤 (2) 和步骤 (1)，应用传递性 **A3**。

#### **定理 12：真与矛盾的左结合 (Left Combination of Truth and Contradiction)**
```
⊢ (· T ⊥) ≡ ⊥
```
**证明**:
1.  `⊢ (· T (Quote t)) ≡ t`
    *   **理由**: **定理 9**。
2.  `⊢ (· T (Quote ⊥)) ≡ ⊥`
    *   **理由**: 将步骤 (1) 中的元变量 `t` 实例化为常量 `⊥`。
3.  `⊢ (Quote ⊥) ≡ ⊥`
    *   **理由**: **定理 2**。
4.  `⊢ (· T ⊥) ≡ (· T (Quote ⊥))`
    *   **理由**: 根据步骤 (3) 的结论和同余性规则 **A4.1**。
5.  `⊢ (· T ⊥) ≡ ⊥`
    *   **理由**: 综合步骤 (4) 和步骤 (2)，应用传递性 **A3**。

#### **定理 13：引用与右单位元的交互 (Interaction of Quotation and Right Identity)**
对于任意项 `t`，
```
⊢ (Quote (· t T)) ≡ (Quote t)
```
**证明**:
1.  `⊢ (· t T) ≡ t`
    *   **理由**: 公理 **B1**。
2.  `⊢ (Quote (· t T)) ≡ (Quote t)`
    *   **理由**: 根据步骤 (1) 的结论和同余性规则 **A4.3**。

#### **定理 14：一个关于否定的替换定理 (A Substitution Theorem for Negation)**
对于任意项 `t`，
```
⊢ (Neg (· t ⊥)) ≡ (Neg (· t (Neg T)))
```
**证明**:
1.  `⊢ (Neg T) ≡ ⊥`
    *   **理由**: **定理 8**。
2.  `⊢ (· t ⊥) ≡ (· t (Neg T))`
    *   **理由**: 根据步骤 (1) 的结论和同余性规则 **A4.1**。
3.  `⊢ (Neg (· t ⊥)) ≡ (Neg (· t (Neg T)))`
    *   **理由**: 根据步骤 (2) 的结论和同余性规则 **A4.2**。

### 4. 形式语义与一致性证明

为证明该逻辑系统的一致性，我们通过模型论方法，构造一个可靠的代数模型 `M_E`。一致性是可靠性的直接推论。

#### 4.1 模型构造 (Model Construction)

我们定义一个模型 `M_E = <D_E, [[·]]_E>`，其中 `D_E` 是模型的域，`[[·]]_E` 是一个解释函数。

##### 4.1.1 域 (Domain)
模型的域 `D_E` 是一个包含两个不同元素的集合：
`D_E = {v_T, v_⊥}`
其中 `v_T ≠ v_⊥`。

##### 4.1.2 解释函数 (Interpretation Function)
解释函数 `[[·]]_E` 将系统中的项映射到域 `D_E` 中的元素。
1.  **常量解释**:
    *   `[[T]]_E = v_T`
    *   `[[⊥]]_E = v_⊥`
    *   `[[Eval]]_E = v_T`。此解释由系统定理 7 `⊢ Eval ≡ T` 所保证。
2.  **变量解释**: 对于任意变量赋值函数 `σ: V → D_E`，`[[x]]_E^σ = σ(x)`。
3.  **公式解释**: 公式 `t₁ ≡ t₂` 在模型 `M_E` 中为真，记作 `M_E ⊨ t₁ ≡ t₂`，当且仅当对于所有的变量赋值函数 `σ`，都有 `[[t₁]]_E^σ = [[t₂]]_E^σ`。

##### 4.1.3 构造子的语义 (Semantics of Constructors)
我们将每个构造子解释为 `D_E` 上的一个函数。设 `d, d₁, d₂ ∈ D_E`。
1.  **`Quote` 的解释 (`quote_E`)**: `quote_E: D_E → D_E` 定义为恒等函数。
    *   `quote_E(d) = d`
2.  **`Neg` 的解释 (`neg_E`)**: `neg_E: D_E → D_E` 定义为常数函数。
    *   `neg_E(d) = v_⊥`
3.  **`·` 的解释 (`dot_E`)**: `dot_E: D_E × D_E → D_E` 定义如下表所示：

| `dot_E(d₁, d₂)` | `d₂ = v_T` | `d₂ = v_⊥` |
| :-------------- | :--------- | :--------- |
| **`d₁ = v_T`**  | `v_T`      | `v_⊥`      |
| **`d₁ = v_⊥`**  | `v_⊥`      | `v_T`      |

#### 4.2 模型的可靠性证明 (Soundness Proof of the Model)

我们需证明所有公理在模型 `M_E` 中均为真，并且所有推理规则在 `M_E` 中保真。对于公理模式，我们需证明对于任意变量赋值 `σ`，等式均成立。设 `d = [[t]]_E^σ`。

*   **A组：等价与同余规则**
    *   **A1-A3**: 由于 `≡` 被解释为 `D_E` 上的等号 ` = `，而 ` = ` 是一个标准的等价关系，因此自反性、对称性和传递性自然成立。
    *   **A4**: 由于 `quote_E`, `neg_E`, `dot_E` 都是 `D_E` 上的良定义函数（即输入相同，输出必然相同），同余性得到保证。

*   **B组：真理结构规则**
    *   **B1 (`(· t T) ≡ t`)**: 需验证 `[[(· t T)]]_E^σ = [[t]]_E^σ`，即 `dot_E([[t]]_E^σ, [[T]]_E) = [[t]]_E^σ`。
        令 `d = [[t]]_E^σ`。需验证 `dot_E(d, v_T) = d`。
        *   若 `d = v_T`：`dot_E(v_T, v_T) = v_T`。成立。
        *   若 `d = v_⊥`：`dot_E(v_⊥, v_T) = v_⊥`。成立。
        公理 B1 在模型中有效。

*   **C组：否定与矛盾规则**
    *   **C1 (`(Neg (· t (Neg t))) ≡ ⊥`)**: 需验证 `[[(Neg (· t (Neg t)))]]_E^σ = [[⊥]]_E`，即 `neg_E(dot_E([[t]]_E^σ, neg_E([[t]]_E^σ))) = v_⊥`。
        由于 `neg_E` 被定义为常数函数 `neg_E(d) = v_⊥`，其返回值恒为 `v_⊥`，与输入无关。因此该等式恒成立。
    *   **C2 (规则)**: 需验证若 `M_E ⊨ t ≡ T`，则 `M_E ⊨ (· ⊥ t) ≡ ⊥`。
        语义前提为 `[[t]]_E^σ = [[T]]_E = v_T`。
        需验证 `[[(· ⊥ t)]]_E^σ = [[⊥]]_E`，即 `dot_E([[⊥]]_E, [[t]]_E^σ) = v_⊥`。
        代入前提：`dot_E(v_⊥, v_T) = v_⊥`。查表可知成立。规则 C2 保真。
    *   **C3 (`(Neg ⊥) ≡ ⊥`)**: 需验证 `[[ (Neg ⊥) ]]_E = [[⊥]]_E`，即 `neg_E([[⊥]]_E) = v_⊥`。
        计算：`neg_E(v_⊥) = v_⊥`。根据 `neg_E` 定义成立。

*   **D组：引用与反射规则**
    *   **D1 (`(· (Quote t) t) ≡ T`)**: 需验证 `[[(· (Quote t) t)]]_E^σ = [[T]]_E`，即 `dot_E(quote_E([[t]]_E^σ), [[t]]_E^σ) = v_T`。
        令 `d = [[t]]_E^σ`。需验证 `dot_E(quote_E(d), d) = v_T`。
        *   若 `d = v_T`：`dot_E(quote_E(v_T), v_T) = dot_E(v_T, v_T) = v_T`。成立。
        *   若 `d = v_⊥`：`dot_E(quote_E(v_⊥), v_⊥) = dot_E(v_⊥, v_⊥) = v_T`。成立。
        公理 D1 在模型中有效。
    *   **D2 (规则)**: 需验证若 `M_E ⊨ t ≡ ⊥`，则 `M_E ⊨ (Quote t) ≡ ⊥`。
        语义前提为 `[[t]]_E^σ = [[⊥]]_E = v_⊥`。
        需验证 `[[(Quote t)]]_E^σ = [[⊥]]_E`，即 `quote_E([[t]]_E^σ) = v_⊥`。
        代入前提：`quote_E(v_⊥) = v_⊥`。根据 `quote_E` 定义成立。规则 D2 保真。

*   **E组：求值规则**
    *   **E1 (规则)**: 需验证若 `M_E ⊨ t₁ ≡ (Quote t₂)`，则 `M_E ⊨ (· Eval t₁) ≡ t₂`。
        语义前提为 `[[t₁]]_E^σ = [[(Quote t₂)]]_E^σ`，即 `[[t₁]]_E^σ = quote_E([[t₂]]_E^σ)`。
        需验证 `[[(· Eval t₁)]]_E^σ = [[t₂]]_E^σ`，即 `dot_E([[Eval]]_E, [[t₁]]_E^σ) = [[t₂]]_E^σ`。
        将前提代入需验证的等式左边：`dot_E(v_T, quote_E([[t₂]]_E^σ))`。
        由于 `quote_E` 是恒等函数，上式等于 `dot_E(v_T, [[t₂]]_E^σ)`。
        令 `d₂ = [[t₂]]_E^σ`。我们需验证 `dot_E(v_T, d₂) = d₂`。
        *   若 `d₂ = v_T`：`dot_E(v_T, v_T) = v_T`。成立。
        *   若 `d₂ = v_⊥`：`dot_E(v_T, v_⊥) = v_⊥`。成立。
        规则 E1 保真。

所有公理和规则均在模型 `M_E` 中成立，因此该系统对于模型 `M_E` 是可靠的。

#### 4.3 一致性结论 (Consistency Conclusion)

1.  **可靠性 (Soundness)**: 我们已经严格证明，如果一个公式 `t₁ ≡ t₂` 是系统的一个定理 (即 `⊢ t₁ ≡ t₂`)，那么它在模型 `M_E` 中必然为真 (即 `M_E ⊨ t₁ ≡ t₂`)，这意味着对所有赋值 `σ` 都有 `[[t₁]]_E^σ = [[t₂]]_E^σ`。

2.  **模型中的区分 (Distinction in the Model)**: 在我们的模型 `M_E` 中，根据定义，`[[T]]_E = v_T` 且 `[[⊥]]_E = v_⊥`。域 `D_E` 的构造保证了 `v_T ≠ v_⊥`。

3.  **一致性证明 (Proof of Consistency)**:
    *   以归谬法证明。假设系统是不一致的。根据不一致性的定义，系统可以证明 `T ≡ ⊥`，即 `⊢ T ≡ ⊥`。
    *   根据已证的可靠性，如果 `⊢ T ≡ ⊥`，那么在模型 `M_E` 中必须有 `M_E ⊨ T ≡ ⊥`。
    *   这意味着 `[[T]]_E = [[⊥]]_E` 必须成立。
    *   然而，这与我们在模型中 `[[T]]_E = v_T`、`[[⊥]]_E = v_⊥` 以及 `v_T ≠ v_⊥` 的事实相矛盾。
    *   由于假设系统不一致会导致矛盾，因此该假设必为假。

**最终结论：引用反射逻辑扩展版系统是一致的。**

### 5. 非平凡三值语义与一致性 (Non-Trivial Three-Valued Semantics and Consistency)

为提供一个更具表现力的语义，并对系统的一致性给出更有力的证明，我们构建一个非平凡的三值模型 `M₃`。该模型将为否定构造子 `Neg` 提供一个非 常数函数的解释，同时满足引用反射逻辑扩展版 (RRL-E) 的所有公理与规则。

#### 5.1 模型 `M₃` 的构造

我们定义一个模型 `M₃ = <D₃, [[·]]₃>`，其中 `D₃` 是模型的域，`[[·]]₃` 是解释函数。

##### 5.1.1 域 (Domain)
模型的域 `D₃` 是一个包含三个不同元素的集合：
`D₃ = {v_T, v_⊥, v_U}`
其中 `v_T`, `v_⊥`, `v_U` 两两互不相等。

##### 5.1.2 解释函数 (Interpretation Function)
1.  **常量解释**:
    *   `[[T]]₃ = v_T`
    *   `[[⊥]]₃ = v_⊥`
    *   `[[Eval]]₃ = v_T`
2.  **变量解释**: 对于任意变量赋值函数 `σ: V → D₃`，`[[x]]_3^σ = σ(x)`。
3.  **公式解释**: 公式 `t₁ ≡ t₂` 在模型 `M₃` 中为真，记作 `M₃ ⊨ t₁ ≡ t₂`，当且仅当对于所有变量赋值 `σ`，都有 `[[t₁]]_3^σ = [[t₂]]_3^σ`。

##### 5.1.3 构造子的语义 (Semantics of Constructors)
我们将每个构造子解释为 `D₃` 上的一个函数。设 `d, d₁, d₂ ∈ D₃`。

1.  **`Quote` 的解释 (`quote_3`)**: `quote_3: D₃ → D₃` 定义为恒等函数。
    *   `quote_3(d) = d`

2.  **`Neg` 的解释 (`neg_3`)**: `neg_3: D₃ → D₃` 定义为：
    *   `neg_3(v_T) = v_⊥`
    *   `neg_3(v_⊥) = v_⊥`
    *   `neg_3(v_U) = v_U`

3.  **`·` 的解释 (`dot_3`)**: `dot_3: D₃ × D₃ → D₃` 定义如下表所示：

| `dot_3(d₁, d₂)` | `d₂ = v_T` | `d₂ = v_⊥` | `d₂ = v_U` |
| :-------------- | :--------- | :--------- | :--------- |
| **`d₁ = v_T`**  | `v_T`      | `v_⊥`      | `v_U`      |
| **`d₁ = v_⊥`**  | `v_⊥`      | `v_T`      | `v_U`      |
| **`d₁ = v_U`**  | `v_U`      | `v_U`      | `v_T`      |

#### 5.2 `M₃` 模型的可靠性证明

我们需形式化地证明所有公理和推理规则在模型 `M₃` 中均成立。设 `d = [[t]]_3^σ` 为任意项 `t` 在任意赋值 `σ` 下的解释。

*   **A组：等价与同余规则**
    *   **A1-A3**: `≡` 被解释为 `D₃` 上的等号 ` = `，这是一个标准的等价关系，故自反性、对称性和传递性成立。
    *   **A4**: `quote_3`, `neg_3`, `dot_3` 均为 `D₃` 上的良定义函数，故同余性得到保证。

*   **B组：真理结构规则**
    *   **B1 (`(· t T) ≡ t`)**: 需验证 `dot_3(d, v_T) = d` 对于所有 `d ∈ D₃` 成立。
        *   `d = v_T`: `dot_3(v_T, v_T) = v_T`。成立。
        *   `d = v_⊥`: `dot_3(v_⊥, v_T) = v_⊥`。成立。
        *   `d = v_U`: `dot_3(v_U, v_T) = v_U`。成立。
        公理 B1 在模型中有效。

*   **C组：否定与矛盾规则**
    *   **C1 (`(Neg (· t (Neg t))) ≡ ⊥`)**: 需验证 `neg_3(dot_3(d, neg_3(d))) = v_⊥` 对于所有 `d ∈ D₃` 成立。
        *   `d = v_T`: `neg_3(dot_3(v_T, neg_3(v_T))) = neg_3(dot_3(v_T, v_⊥)) = neg_3(v_⊥) = v_⊥`。成立。
        *   `d = v_⊥`: `neg_3(dot_3(v_⊥, neg_3(v_⊥))) = neg_3(dot_3(v_⊥, v_⊥)) = neg_3(v_T) = v_⊥`。成立。
        *   `d = v_U`: `neg_3(dot_3(v_U, neg_3(v_U))) = neg_3(dot_3(v_U, v_U)) = neg_3(v_T) = v_⊥`。成立。
        公理 C1 在模型中有效。
    *   **C2 (规则)**: 需验证若 `M₃ ⊨ t ≡ T`，则 `M₃ ⊨ (· ⊥ t) ≡ ⊥`。
        语义前提为 `[[t]]_3^σ = v_T`。需验证 `dot_3([[⊥]]_3, [[t]]_3^σ) = [[⊥]]_3`。
        代入前提：`dot_3(v_⊥, v_T) = v_⊥`。查表可知成立。规则 C2 保真。
    *   **C3 (`(Neg ⊥) ≡ ⊥`)**: 需验证 `neg_3([[⊥]]_3) = [[⊥]]_3`。
        计算：`neg_3(v_⊥) = v_⊥`。根据 `neg_3` 定义成立。公理 C3 在模型中有效。

*   **D组：引用与反射规则**
    *   **D1 (`(· (Quote t) t) ≡ T`)**: 需验证 `dot_3(quote_3(d), d) = v_T` 对于所有 `d ∈ D₃` 成立。
        由于 `quote_3` 是恒等函数，这简化为验证 `dot_3(d, d) = v_T`。
        *   `d = v_T`: `dot_3(v_T, v_T) = v_T`。成立。
        *   `d = v_⊥`: `dot_3(v_⊥, v_⊥) = v_T`。成立。
        *   `d = v_U`: `dot_3(v_U, v_U) = v_T`。成立。
        公理 D1 在模型中有效。
    *   **D2 (规则)**: 需验证若 `M₃ ⊨ t ≡ ⊥`，则 `M₃ ⊨ (Quote t) ≡ ⊥`。
        语义前提为 `[[t]]_3^σ = v_⊥`。需验证 `quote_3([[t]]_3^σ) = v_⊥`。
        代入前提：`quote_3(v_⊥) = v_⊥`。根据 `quote_3` 定义成立。规则 D2 保真。

*   **E组：求值规则**
    *   **E1 (规则)**: 需验证若 `M₃ ⊨ t₁ ≡ (Quote t₂)`，则 `M₃ ⊨ (· Eval t₁) ≡ t₂`。
        语义前提为 `[[t₁]]_3^σ = [[(Quote t₂)]]_3^σ`，即 `[[t₁]]_3^σ = quote_3([[t₂]]_3^σ)`。
        由于 `quote_3` 是恒等函数，前提简化为 `[[t₁]]_3^σ = [[t₂]]_3^σ`。
        需验证的结论是 `dot_3([[Eval]]_3, [[t₁]]_3^σ) = [[t₂]]_3^σ`。
        代入前提和 `[[Eval]]_3` 的解释，需验证 `dot_3(v_T, [[t₂]]_3^σ) = [[t₂]]_3^σ`。
        令 `d₂ = [[t₂]]_3^σ`。我们验证 `dot_3(v_T, d₂) = d₂` 对于所有 `d₂ ∈ D₃` 成立。
        *   `d₂ = v_T`: `dot_3(v_T, v_T) = v_T`。成立。
        *   `d₂ = v_⊥`: `dot_3(v_T, v_⊥) = v_⊥`。成立。
        *   `d₂ = v_U`: `dot_3(v_T, v_U) = v_U`。成立。
        规则 E1 保真。

所有公理和规则均在模型 `M₃` 中成立，因此该系统对于模型 `M₃` 是可靠的。

#### 5.3 一致性结论

1.  **可靠性 (Soundness)**: 我们已经严格证明，如果一个公式 `t₁ ≡ t₂` 是系统的一个定理 (即 `⊢ t₁ ≡ t₂`)，那么它在模型 `M₃` 中必然为真 (即 `M₃ ⊨ t₁ ≡ t₂`)，这意味着 `[[t₁]]_3 = [[t₂]]_3`。

2.  **模型中的区分 (Distinction in the Model)**: 在模型 `M₃` 中，根据定义，`[[T]]₃ = v_T` 且 `[[⊥]]₃ = v_⊥`。域 `D₃` 的构造保证了 `v_T ≠ v_⊥`。

3.  **一致性证明 (Proof of Consistency)**:
    *   以归谬法证明。假设系统是不一致的，即系统可以证明 `T ≡ ⊥`。
    *   根据已证的可靠性，如果 `⊢ T ≡ ⊥`，那么在模型 `M₃` 中必须有 `M₃ ⊨ T ≡ ⊥`。
    *   这意味着 `[[T]]₃ = [[⊥]]₃` 必须成立。
    *   然而，这与我们在模型中 `v_T ≠ v_⊥` 的事实相矛盾。
    *   由于假设系统不一致会导致矛盾，因此该假设必为假。

**最终结论：引用反射逻辑扩展版系统是一致的。**


### **6. 关于RRL-E系统中若干公式模式的不可证性证明**

本节旨在通过模型论方法，证明引用反射逻辑扩展版（RRL-E）系统中以下三个公式模式（schemata）并非其定理：
1.  `(Neg t) ≡ ⊥` (否定构造子的常数性)
2.  `(Quote t) ≡ t` (引用坍缩)
3.  `(· T t) ≡ t` (T的左单位元性质)

我们将通过构造满足RRL-E公理系统但使上述公式为假的反例模型来完成证明。

#### **6.1. `(Neg t) ≡ ⊥` 的不可证性**

**命题 6.1.** 公式模式 `⊢ (Neg t) ≡ ⊥` 不是 RRL-E 的一个定理模式。

**证明.**
为证此命题，我们采用已验证为 RRL-E 的一个可靠模型 `M₃`。

#### **6.1.1 反例模型 `M₃` 的定义**

*   **域:** `D₃ = {v_T, v_⊥, v_U}`，其中 `v_T, v_⊥, v_U` 两两互不相等。
*   **常量解释:**
    *   `[[T]]₃ = v_T`
    *   `[[⊥]]₃ = v_⊥`
    *   `[[Eval]]₃ = v_T`
*   **构造子语义:**
    *   `quote_3(d) = d`
    *   `neg_3(v_T) = v_⊥`, `neg_3(v_⊥) = v_⊥`, `neg_3(v_U) = v_U`
    *   `dot_3` 由下表定义:

| `dot_3(d₁, d₂)` | `d₂ = v_T` | `d₂ = v_⊥` | `d₂ = v_U` |
| :-------------- | :--------- | :--------- | :--------- |
| **`d₁ = v_T`**  | `v_T`      | `v_⊥`      | `v_U`      |
| **`d₁ = v_⊥`**  | `v_⊥`      | `v_T`      | `v_U`      |
| **`d₁ = v_U`**  | `v_U`      | `v_U`      | `v_T`      |

该模型 `M₃` 的可靠性已在前述分析中得到完整验证。

#### **6.1.2 证伪**
考虑公式 `(Neg T) ≡ ⊥`。我们在模型 `M₃` 中解释此公式：
1.  左侧解释：`[[(Neg T)]]₃ = neg_3([[T]]₃) = neg_3(v_T) = v_⊥`。
2.  右侧解释：`[[⊥]]₃ = v_⊥`。
在此例中，`[[(Neg T)]]₃ = [[⊥]]₃` 成立。

现在考虑一个变量 `x` 和一个变量赋值函数 `σ` 使得 `σ(x) = v_U`。我们解释公式 `(Neg x) ≡ ⊥`：
1.  左侧解释：`[[(Neg x)]]_3^σ = neg_3([[x]]_3^σ) = neg_3(v_U) = v_U`。
2.  右侧解释：`[[⊥]]₃ = v_⊥`。

由于 `v_U ≠ v_⊥`，故 `[[(Neg x)]]_3^σ ≠ [[⊥]]_3^σ`。
因此，公式 `(Neg x) ≡ ⊥` 在模型 `M₃` 中不为真，即 `M₃ <binary data, 2 bytes> (Neg x) ≡ ⊥`。

根据 RRL-E 对 `M₃` 的可靠性（Soundness），任何在 `M₃` 中不为真的公式都不可能是 RRL-E 的定理。因此，`(Neg t) ≡ ⊥` 并非 RRL-E 的定理模式。 **Q.E.D.**

---

#### **6.2. `(Quote t) ≡ t` 和 `(· T t) ≡ t` 的不可证性**

我们将构造一个四值模型 `M_Q`，它既是 RRL-E 的一个可靠模型，又同时证伪了上述两个公式模式。

#### **6.2.1 模型 `M_Q` 的指称语义**

*   **域:** `D_Q = {v_T, v_⊥, u₁, u₂}`，其中所有元素两两互不相等。
*   **常量解释:**
    *   `[[T]]_Q = v_T`
    *   `[[⊥]]_Q = v_⊥`
    *   `[[Eval]]_Q = v_T`
*   **变量解释:** 对于任意变量赋值 `σ: V → D_Q`，`[[x]]_Q^σ = σ(x)`。
*   **公式解释:** `M_Q ⊨ t₁ ≡ t₂` 当且仅当对于所有 `σ`，`[[t₁]]_Q^σ = [[t₂]]_Q^σ`。
*   **构造子语义:**
    1.  **`Quote` 的解释 (`quote_Q: D_Q → D_Q`)**:
        *   `quote_Q(v_T) = v_T`
        *   `quote_Q(v_⊥) = v_⊥`
        *   `quote_Q(u₁) = u₂`
        *   `quote_Q(u₂) = u₁`
    2.  **`Neg` 的解释 (`neg_Q: D_Q → D_Q`)**:
        *   `neg_Q(v_T) = v_⊥`
        *   `neg_Q(v_⊥) = v_⊥`
        *   `neg_Q(u₁) = u₁`
        *   `neg_Q(u₂) = u₂`
    3.  **`·` 的解释 (`dot_Q: D_Q × D_Q → D_Q`)**:

| `dot_Q(d₁, d₂)` | `d₂ = v_T` | `d₂ = v_⊥` | `d₂ = u₁` | `d₂ = u₂` |
| :-------------- | :--------- | :--------- | :-------- | :-------- |
| **`d₁ = v_T`**  | `v_T`      | `v_⊥`      | `u₂`      | `u₁`      |
| **`d₁ = v_⊥`**  | `v_⊥`      | `v_T`      | `u₂`      | `u₁`      |
| **`d₁ = u₁`**   | `u₁`       | `u₁`       | `v_T`     | `v_T`     |
| **`d₁ = u₂`**   | `u₂`       | `u₂`       | `v_T`     | `v_T`     |

#### **6.2.2 模型 `M_Q` 的可靠性证明**

设 `d`, `d₁`, `d₂` 为 `D_Q` 中的任意元素，`[[t]]` 为任意项 `t` 在任意赋值下的解释。

*   **A组 (等价与同余)**: `≡` 被解释为 `D_Q` 上的等号 ` = `，`quote_Q`, `neg_Q`, `dot_Q` 均为良定义函数。故 **A1-A4** 成立。

*   **B1 (`(· t T) ≡ t`)**: 需验证 `dot_Q(d, v_T) = d`。查阅 `dot_Q` 表的第二列，该等式对所有 `d ∈ D_Q` 均成立。公理 **B1** 有效。

*   **C1 (`(Neg (· t (Neg t))) ≡ ⊥`)**: 需验证 `neg_Q(dot_Q(d, neg_Q(d))) = v_⊥`。
    *   `d = v_T`: `neg_Q(dot_Q(v_T, v_⊥)) = neg_Q(v_⊥) = v_⊥`。
    *   `d = v_⊥`: `neg_Q(dot_Q(v_⊥, v_⊥)) = neg_Q(v_T) = v_⊥`。
    *   `d = u₁`: `neg_Q(dot_Q(u₁, u₁)) = neg_Q(v_T) = v_⊥`。
    *   `d = u₂`: `neg_Q(dot_Q(u₂, u₂)) = neg_Q(v_T) = v_⊥`。
    公理 **C1** 有效。

*   **C2 (规则)**: 若 `[[t]] = v_T`，则 `dot_Q(v_⊥, [[t]]) = v_⊥`。即验证 `dot_Q(v_⊥, v_T) = v_⊥`。查表可知成立。规则 **C2** 保真。

*   **C3 (`(Neg ⊥) ≡ ⊥`)**: `neg_Q(v_⊥) = v_⊥`。根据定义成立。公理 **C3** 有效。

*   **D1 (`(· (Quote t) t) ≡ T`)**: 需验证 `dot_Q(quote_Q(d), d) = v_T`。
    *   `d = v_T`: `dot_Q(v_T, v_T) = v_T`。
    *   `d = v_⊥`: `dot_Q(v_⊥, v_⊥) = v_T`。
    *   `d = u₁`: `dot_Q(u₂, u₁) = v_T`。
    *   `d = u₂`: `dot_Q(u₁, u₂) = v_T`。
    公理 **D1** 有效。

*   **D2 (规则)**: 若 `[[t]] = v_⊥`，则 `quote_Q([[t]]) = v_⊥`。即验证 `quote_Q(v_⊥) = v_⊥`。根据定义成立。规则 **D2** 保真。

*   **E1 (规则)**: 若 `[[t₁]] = quote_Q([[t₂]])`，则 `dot_Q([[Eval]]_Q, [[t₁]]) = [[t₂]]`。
    这等价于验证 `dot_Q(v_T, quote_Q(d)) = d` 对所有 `d ∈ D_Q` 成立。
    *   `d = v_T`: `dot_Q(v_T, quote_Q(v_T)) = dot_Q(v_T, v_T) = v_T`。
    *   `d = v_⊥`: `dot_Q(v_T, quote_Q(v_⊥)) = dot_Q(v_T, v_⊥) = v_⊥`。
    *   `d = u₁`: `dot_Q(v_T, quote_Q(u₁)) = dot_Q(v_T, u₂) = u₁`。
    *   `d = u₂`: `dot_Q(v_T, quote_Q(u₂)) = dot_Q(v_T, u₁) = u₂`。
    规则 **E1** 保真。

所有公理和规则均在 `M_Q` 中成立。故 `M_Q` 是 RRL-E 的一个可靠模型。

#### **6.2.3 定理的不可证性证明**

**定理 6.2.1.** 公式模式 `⊢ (Quote t) ≡ t` 不是 RRL-E 的一个定理模式。

**证明.**
考虑模型 `M_Q`。令 `x` 为一个变量，并考虑一个变量赋值 `σ` 使得 `σ(x) = u₁`。
1.  计算 `(Quote x)` 的解释：
    `[[(Quote x)]]_Q^σ = quote_Q([[x]]_Q^σ) = quote_Q(u₁) = u₂`。
2.  计算 `x` 的解释：
    `[[x]]_Q^σ = u₁`。
3.  由于在 `D_Q` 中 `u₁ ≠ u₂`，故 `[[(Quote x)]]_Q^σ ≠ [[x]]_Q^σ`。
4.  这表明公式 `(Quote x) ≡ x` 在模型 `M_Q` 中不为真。
5.  根据 RRL-E 对 `M_Q` 的可靠性，任何在 `M_Q` 中不为真的公式都不可能是 RRL-E 的定理。
因此，`(Quote t) ≡ t` 并非 RRL-E 的定理模式。 **Q.E.D.**

**定理 6.2.2.** 公式模式 `⊢ (· T t) ≡ t` 不是 RRL-E 的一个定理模式。

**证明.**
考虑模型 `M_Q`。令 `x` 为一个变量，并考虑与前述相同的变量赋值 `σ`，使得 `σ(x) = u₁`。
1.  计算 `(· T x)` 的解释：
    `[[(· T x)]]_Q^σ = dot_Q([[T]]_Q, [[x]]_Q^σ) = dot_Q(v_T, u₁) = u₂`。
2.  计算 `x` 的解释：
    `[[x]]_Q^σ = u₁`。
3.  由于 `u₁ ≠ u₂`，故 `[[(· T x)]]_Q^σ ≠ [[x]]_Q^σ`。
4.  这表明公式 `(· T x) ≡ x` 在模型 `M_Q` 中不为真。
5.  根据 RRL-E 对 `M_Q` 的可靠性，任何在 `M_Q` 中不为真的公式都不可能是 RRL-E 的定理。
因此，`(· T t) ≡ t` 并非 RRL-E 的定理模式。 **Q.E.D.**


### 7. 真理谓词猜想

我们猜想，以下方案的F组公理相容于这个系统。


#### 7.2. F组公理方案二

*   **F3 (真理等价公理 / Axiom of Truth Equivalence):**
    对于任意项 `t`，
    ```
    ⊢ (· t T) ≡ (· (P t) T)
    ```
    *释义：一个项 `t` 和它的真理版本 `(P t)` 在被断言为真（即与 `T` 进行 `·` 运算）时，其结果是等价的。这避免了直接的 `t ≡ (P t)`，但保留了它们在“真值”上下文中的相同行为。*

*   **F4 (真理映射公理 / Axiom of Truth Mapping):**
    对于任意项 `t`，
    ```
    若 ⊢ t ≡ T, 则 ⊢ (P t) ≡ T
    若 ⊢ t ≡ ⊥, 则 ⊢ (P t) ≡ (Neg T)
    ```
    *释义：`P` 构造子正确地将系统的真/矛盾范式映射到其自身的真/假陈述上。*
