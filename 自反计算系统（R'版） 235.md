### **形式系统 R'：迹重建系统 (A Trace Reconstruction System)**

#### **1. 语法 (Syntax)**

**1.1. 基础集合**

*   `A`：一个可数的**原子项 (Atoms)** 集合。
*   `V`：一个可数的**位点标识符 (Site Identifiers)** 集合。
*   `F`：一个带元数（arity）的**函数符号 (Function Symbols)** 集合。
*   `S`：一个非空的**内部状态 (Internal States)** 集合。

**1.2. 项与上下文 (Terms and Contexts)**

*   **位点项 (Site Terms)**：一个位点项 `σ` 是一个元组 `(v, s)`，其中 `v ∈ V` 且 `s ∈ S`。为方便起见，`id(σ)` 表示 `v`，`state(σ)` 表示 `s`。
*   **项 (Terms)**：项的集合 `T` 被归纳定义为：
    1.  `a ∈ A` 是一个项。
    2.  任何位点项 `σ` 都是一个项。
    3.  若 `f ∈ F` 且 `arity(f) = n`，`t₁, ..., tₙ ∈ T`，则 `f(t₁, ..., tₙ)` 是一个项。
*   **上下文 (Contexts)**：上下文的集合 `C` 是带有一个唯一“空位” `[]` 的项。`C[t]` 表示将 `C` 中的空位 `[]` 替换为项 `t` 后得到的项。

**1.3. 核心对象**

*   **规则节点 (Rule Nodes)**：规则节点的集合 `P`。每个 `ρ ∈ P` 是一个三元组 `(σ_lhs, t_rhs, C_trigger)`，其中：
    *   `σ_lhs ∈ T` 是一个位点项。
    *   `t_rhs ∈ T` 是一个项。
    *   `C_trigger ∈ C` 是一个上下文。
*   **迹 (Traces)**：一个迹 `τ` 是 `P` 中规则节点的有穷序列：`τ = [ρ₁, ρ₂, ..., ρₙ]`。空迹记为 `[]`。

#### **2. 核心组件 (Core Components)**

**2.1. 验证位点 (Validation Sites)**

一个验证位点 `ν` 是一个与位点项 `σ` 关联的动态实体，其结构为三元组 `(σ, s_ν, A)`：
*   `σ ∈ T`：该验证位点对应的**源位点项**。
*   `s_ν`：该验证位点的**验证状态**。`s_ν` 从状态集 `S_ν = {AVAILABLE, CONSUMED}` 中取值。
*   `A`：该验证位点的**规则验证函数 (Rule Validation Function)**。

我们使用以下投影函数：`origin(ν) = σ`，`val_state(ν) = s_ν`，`validator(ν) = A`。

**2.2. 规则验证函数 (Rule Validation Function)**

规则验证函数 `A` 的签名为：`A: C → P ∪ {⊥}`。
该函数接收一个上下文 `C`，返回一个唯一确定的规则节点 `ρ ∈ P` 或失败符号 `⊥`。`A` 封装了决定一个位点在特定环境下应触发何种规则的内在逻辑。

#### **3. 系统动力学 (System Dynamics)**

**3.1. 系统格局 (System Configuration)**

一个系统格局由一个元组 `(τ, Σ)` 定义，其中：
*   `τ ∈ Tr` 是当前的迹。
*   `Σ` 是一个从 `V` 到验证位点 `ν` 的映射，记录了系统中所有已出现位点的当前状态。

**3.2. 单步扩展关系 (One-Step Extension Relation)**

系统的单步扩展关系 `↦` 定义了格局之间的转移 `(τ, Σ) ↦ (τ', Σ')`。此关系由以下推导规则给出：

```
(τ, Σ) is the current configuration, with τ = [ρ₁, ..., ρₙ]
t_eff = C_trigger(ρₙ)[t_rhs(ρₙ)]                   (1. 计算上一步的有效结果项)
t_eff = C_sel[σ_sel]                                (2. 在 t_eff 中非确定性地选择一个位点 σ_sel)
ν = Σ(id(σ_sel))                                    (3. 获取对应的验证位点)
val_state(ν) = AVAILABLE                            (4. 检查其状态为 AVAILABLE)
A = validator(ν)                                    (5. 获取其验证函数)
ρ_{n+1} = A(C_sel)                                  (6. 计算下一个规则节点)
ρ_{n+1} ≠ ⊥                                         (7. 验证成功)
-------------------------------------------------------------------------------------------------
                  (τ, Σ) ↦ ( [ρ₁, ..., ρₙ, ρ_{n+1}], Σ' )
```

**3.3. 状态更新 (`Σ'` 的构造)**

新映射 `Σ'` 的构造如下：
1.  `Σ'` 初始化为 `Σ` 的一个副本。
2.  将触发扩展的验证位点 `ν` 的状态更新为 `CONSUMED`：`val_state(Σ'(id(σ_sel))) ← CONSUMED`。
3.  对于在 `t_rhs(ρ_{n+1})` 中出现的任何**新的**位点项 `σ_new`（即其标识符 `id(σ_new)` 不在 `Σ` 的定义域中），在 `Σ'` 中为其创建一个新的验证位点 `ν_new`，并将其状态初始化为 `AVAILABLE`。`ν_new` 的规则验证函数 `A` 由系统预设的初始化函数决定。

一个**完整迹**是一个无法再进行扩展的迹。

---

### **4. 示例**

**4.1. 系统规约**

*   `A = {0, 1}`, `F = {pair(t₁, t₂)}`, `S = {INITIAL, ...}`。
*   **规则验证函数 `A_init`**：所有验证位点共享同一个验证函数模板，该模板基于其源位点项 `σ` 和给定的上下文 `C` 来运作：
    ```
    A_init(σ, C) =
      let v = id(σ) in
      if C = [] then
        // 构造一个分裂规则
        (σ, pair(σ₁, σ₂), C)  // σ₁, σ₂ 是具有新标识符和 INITIAL 状态的新位点
      else
        // 构造一个终止规则
        (σ, 0, C)
    ```
*   **初始格局**: `(τ₀, Σ₀)`，其中 `τ₀ = [ρ₀]`，`ρ₀ = (σ_start, σ₀, [])` (一个特殊的引导规则)。`Σ₀` 包含一个 `id(σ₀)` 到 `ν₀` 的映射，且 `val_state(ν₀) = AVAILABLE`。

**4.2. 推导过程**

**格局 0: `(τ₀, Σ₀)`**
*   `τ₀ = [ρ₀]`
*   `Σ₀ = {v₀ ↦ ν₀}` where `val_state(ν₀) = AVAILABLE`

**扩展 1: `(τ₀, Σ₀) ↦ (τ₁, Σ₁)`**

1.  `t_eff` 来自 `ρ₀`，为 `σ₀`。
2.  选择 `σ₀`，其上下文为 `C_sel = []`。
3.  `ν₀` 的状态为 `AVAILABLE`。
4.  `ρ₁ = A_init(σ₀, []) = (σ₀, pair(σ₁, σ₂), [])`。
5.  `τ₁ = [ρ₀, ρ₁]`。
6.  `Σ₁` 的更新：
    *   `val_state(ν₀)` 变为 `CONSUMED`。
    *   为新位点 `σ₁` 和 `σ₂` 创建验证位点 `ν₁` 和 `ν₂`，状态均为 `AVAILABLE`。
    *   `Σ₁ = {v₀ ↦ ν₀, v₁ ↦ ν₁, v₂ ↦ ν₂}`。

**格局 1: `(τ₁, Σ₁)`**
*   `τ₁ = [ρ₀, (σ₀, pair(σ₁, σ₂), [])]`
*   `val_state(ν₀)=CONSUMED`, `val_state(ν₁)=AVAILABLE`, `val_state(ν₂)=AVAILABLE`

**扩展 2: `(τ₁, Σ₁) ↦ (τ₂, Σ₂)` (选择 `σ₁`)**

1.  `t_eff` 来自 `ρ₁`，为 `pair(σ₁, σ₂)`。
2.  非确定性选择 `σ₁`，其上下文 `C_sel = pair([], σ₂)`。
3.  `ν₁` 的状态为 `AVAILABLE`。
4.  `ρ₂ = A_init(σ₁, C_sel) = (σ₁, 0, C_sel)`。
5.  `τ₂ = [ρ₀, ρ₁, ρ₂]`。
6.  `Σ₂` 的更新：
    *   `val_state(ν₁)` 变为 `CONSUMED`。
    *   `ρ₂` 的结果项 `0` 不含新位点。
    *   `Σ₂` 与 `Σ₁` 相同，只是 `ν₁` 的状态改变。

**格局 2: `(τ₂, Σ₂)`**
*   `τ₂ = [ρ₀, ρ₁, (σ₁, 0, pair([], σ₂))]`
*   `val_state(ν₀)=CONSUMED`, `val_state(ν₁)=CONSUMED`, `val_state(ν₂)=AVAILABLE`

**后续步骤**

下一步将选择 `t_eff = pair(0, σ₂)` 中唯一可用的位点 `σ₂`，并生成其终止规则 `(σ₂, 0, pair(0, []))`。之后，最终的有效项为 `pair(0, 0)`，不含任何 `AVAILABLE` 的验证位点，系统停止扩展。最终的迹完整记录了一次有效的计算历史。