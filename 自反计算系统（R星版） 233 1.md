### **上下文吸收系统 (A Contextual Absorption System R*)**

#### **1. 语法 (Syntax)**

**1.1. 基础集合 (Dual Primitives)**

*   `T`：项的集合。该集合与系统 R 中的定义完全相同，因为它构成了转移的“头”和“尾”。
*   `L`：一个可数的位主标识符 (Locus Identifiers) 集合。`l ∈ L`。
*   `Q`：一个预定义的、非空的状态集 (Locus States)。`q ∈ Q`。

**1.2. 转移 (Transitions)**

转移的集合 `P`（Pool of Transitions）是 R* 系统中的核心数据。一个转移 `τ ∈ P` 是一个有序对：
`τ = (t_in, t_out)`
其中 `t_in, t_out ∈ T`。`t_in` 是转移的**源项 (Source Term)**，`t_out` 是**目标项 (Target Term)**。这对应于 R 中由规则 `σ → t'` 在上下文 `C` 中引发的替换 `C[t_in] → C[t_out]` 中的核心部分 `(t_in, t_out)`。

**1.3. 吸收性位主 (Absorptive Loci)**

吸收性位主 `λ` 是 R* 中的核心操作单元，是对 R 中“上下文”这一概念的实体化和动态化。它是系统 R* 中的“点”。

一个吸收性位主 `λ` 是一个五元组：`λ = (l, q, A, M, E)`，其中：
*   `l ∈ L` 是该位主的唯一标识符。
*   `q ∈ Q` 是该位主的当前内部状态。
*   `A` 是位主的**适用性函数 (Applicability Function)**。
*   `M` 是位主的**状态变形函数 (State Morphing Function)**。
*   `E` 是位主的**转移发射函数 (Transition Emission Function)**。

为了表示方便，我们使用以下投影函数：
*   `id(λ) = l`
*   `state(λ) = q`
*   `app(λ) = A`
*   `morph(λ) = M`
*   `emit(λ) = E`

#### **2. 核心组件 (Core Components)**

**2.1. 适用性函数 (Applicability Function)**

适用性函数 `A` 决定了一个位主是否可以“吸收”一个给定的转移。其签名是：
`A: Q × T × T → Bool`
它接收位主的当前状态 `q` 和一个转移 `τ = (t_in, t_out)`，如果该转移可以在此状态的位主上发生，则返回 `True`。这在功能上对偶于 R 中的规则生成函数 `G`，`G` *生成*规则，而 `A` *选择/过滤*规则。

**2.2. 状态变形函数 (State Morphing Function)**

状态变形函数 `M` 计算位主在吸收一个转移后的新状态。其签名是：
`M: Q × P → Q`
它接收位主的当前状态 `q` 和刚刚被吸收的转移 `τ`，计算出位主的新状态 `q'`。这在功能上对偶于 R 中的状态更新函数 `U`，`U` 根据*外部上下文*更新状态，而 `M` 根据其吸收的*内部动作*（转移）来改变状态。

**2.3. 转移发射函数 (Transition Emission Function)**

转移发射函数 `E` 在位主状态改变后，可能产生一组新的待处理转移。其签名是：
`E: Q → ℘(P)`
其中 `℘(P)` 是转移集合的幂集。它接收位主的新状态 `q'`，并生成一个（可能为空的）新转移集合。这个机制确保了系统的持续演化，对应于 R 中新生成的项 `t'` 中可能包含新的生成性位点 `σ_new`。

#### **3. 系统动力学 (System Dynamics)**

**3.1. 系统格局 (System Configuration)**

一个系统格局 `K` 是一个二元组：`K = (Λ, P)`，其中：
*   `Λ` 是当前活跃的吸收性位主的集合。
*   `P` 是当前待处理的转移池。

**3.2. 单步转移关系 (One-Step Transition Relation)**

系统的单步转移关系 `⇒` 是在格局集合上的一个二元关系，`K ⇒ K'`。其定义由以下推导规则给出：

```
(Λ, P)                               (1. 当前格局)
λ ∈ Λ, τ ∈ P                         (2. 从中非确定性地选择一个位主 λ 和一个转移 τ)
q = state(λ)                         (3. 获取 λ 的当前状态)
A = app(λ)                           (4. 获取 λ 的适用性函数)
M = morph(λ)                           (5. 获取 λ 的状态变形函数)
E = emit(λ)                           (6. 获取 λ 的转移发射函数)
A(q, τ) = True                       (7. 检查转移 τ 对位主 λ 是否适用)
q' = M(q, τ)                         (8. 计算变形后的新状态 q')
P_new = E(q')                        (9. 基于新状态 q' 发射一组新转移)
λ' = (id(λ), q', A, M, E)             (10. 创建更新后的位主 λ')
--------------------------------------------------------------------------------------------------
(Λ, P) ⇒ ( (Λ \ {λ}) ∪ {λ'}, (P \ {τ}) ∪ P_new )      (推论: 系统转移到新格局)
```

*   此规则是非确定性的：任何满足适用性条件的 `(λ, τ)` 对都可以触发一次转移。

---

### **4. 示例 (Dual Example)**

R* 的过程将从代表最终步骤的转移开始，最终生成代表初始步骤的转移。

**4.1. 系统规约**

*   项集 `T`：同 R，包含原子 `0`、`1`，函数 `pair(t₁, t₂)`，以及位点项 `σ₀, σ₁, σ₂` 等。
*   位主标识符集 `L = {l_pair, l_root}`
*   状态集 `Q = {WAIT_2, WAIT_1, EMIT_EXPANSION, DONE}`
*   定义一个核心位主 `λ_pair`，它模拟了在 `pair(_, _)` 结构内的上下文。

    **适用性函数 `A(q, t_in, t_out)`:**
    ```
    A(q, τ) = 
      if q ∈ {WAIT_2, WAIT_1} and t_out = 0 then True
      else False
    ```
    *解读：只有当位主在等待状态，且它遇到的转移是“终止”类型（目标为 `0`）时，才适用。*

    **状态变形函数 `M(q, τ)`:**
    ```
    M(q, τ) =
      if q = WAIT_2 then WAIT_1
      else if q = WAIT_1 then EMIT_EXPANSION
      else DONE
    ```    *解读：每吸收一个终止转移，等待计数减一。当吸收满两个后，进入发射状态。*

    **转移发射函数 `E(q')`:**
    ```
    E(q') =
      if q' = EMIT_EXPANSION then
        { (σ₀, pair(σ₁, σ₂)) } // 发射“展开”转移的逆过程
      else
        ∅ // 其他状态不发射新转移
    ```
    *解读：当位主进入发射状态时，它产生一个代表系统 R 初始步骤的转移。这里源项和目标项的位置与 R 中的规则 `σ₀ → pair(σ₁, σ₂)` 相反，反映了过程的逆转。*


**4.2. 推导过程**

令 R* 的初始格局 `K₀` 包含一个 `pair` 位主和两个“终止”转移（它们是 R 过程的最后两步）：

`K₀ = ( {λ_pair₀}, { (σ₁, 0), (σ₂, 0) } )`
其中 `id(λ_pair₀) = l_pair`，`state(λ_pair₀) = WAIT_2`。

**步骤 1: `K₀ ⇒ K₁` (吸收第一个终止转移)**

1.  从 `K₀` 中选择 `λ = λ_pair₀` 和 `τ = (σ₁, 0)`。
2.  `q = state(λ) = WAIT_2`。
3.  `A(WAIT_2, (σ₁, 0)) = True`，因为 `t_out` 是 `0`。
4.  `q' = M(WAIT_2, (σ₁, 0)) = WAIT_1`。
5.  `P_new = E(WAIT_1) = ∅`。
6.  `λ_pair₁` 是状态更新为 `WAIT_1` 的新位主。
7.  新格局 `K₁ = ( {λ_pair₁}, { (σ₂, 0) } )`。

**步骤 2: `K₁ ⇒ K₂` (吸收第二个终止转移)**

1.  从 `K₁` 中选择 `λ = λ_pair₁` 和 `τ = (σ₂, 0)`。
2.  `q = state(λ) = WAIT_1`。
3.  `A(WAIT_1, (σ₂, 0)) = True`。
4.  `q' = M(WAIT_1, (σ₂, 0)) = EMIT_EXPANSION`。
5.  `P_new = E(EMIT_EXPANSION) = { (σ₀, pair(σ₁, σ₂)) }`。
6.  `λ_pair₂` 是状态更新为 `EMIT_EXPANSION` 的新位主。
7.  新格局 `K₂ = ( {λ_pair₂}, { (σ₀, pair(σ₁, σ₂)) } )`。

系统现在达到了一个状态，其中它已经“吸收”了导致 `pair(0,0)` 的所有子步骤，并作为结果，“发射”了导致 `pair(σ₁, σ₂)` 的那个初始步骤的逆转移。如果系统中还存在一个代表“根上下文”的位主 `λ_root`，它便可以吸收这个最终的转移，完成整个计算的“逆过程”。