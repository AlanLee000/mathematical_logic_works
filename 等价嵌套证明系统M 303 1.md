# **等价嵌套证明系统M**

### **1. 语法 (Syntax)**

**1.1. 函数 (Functions)**

*   `·`：一个二元函数，表示**应用**。记为 `(· a b)`。
*   `equiv`：一个二元函数，表示**等价**。记为 `(equiv a b)`。

**1.2. 常量 (Constants)**

*   `T`：一个零元函数（原子项），代表**已证实的等价性**或**真理**。
*   `F`：一个零元函数（原子项）。

**1.3. 项 (Terms)**

项的集合由以下规则递归定义：
1.  `T` 是项。
2.  `F` 是项。
3.  若 `a` 和 `b` 是项，则 `(· a b)` 是项。
4.  若 `a` 和 `b` 是项，则 `(equiv a b)` 是项。

**1.4. 公式 (Formulas)**

公式的集合如下构成：
1. 若 `a` 和 `b` 是项，则  `a = b`是公式。
### **2. 证明论**

对于任意项 `a`, `b`, `c`, `d`, `f`, `x`：

**核心交互公理模式**

*   **A1: 右动作 (Right Action)**
    `(· (equiv a b) b) = (equiv a (· a b))`

*   **A2: 左动作 (Left Action)**
    `(· a (equiv a b)) = (equiv b (· a b))`


**外化规则**

*    **A3: 外化规则**
```
	若 ⊢ (equiv a b) = T
	-------------------- (A3)
	则 ⊢ a = b
```

*   **A4: 内化规则**
```
	若 ⊢ a = b
	-------------------- (A4)
	则 ⊢ (equiv a b) = T
```

**背景等式逻辑 (Background Equational Logic)**
证明关系 `⊢` 被假定在一个标准的等式逻辑框架内，该框架确保了 ` = ` 作为一个全等关系 (congruence relation)。这意味着以下结构性规则对于任何推导都有效：
**公理模式：**
*   `Refl: a = a`
**推理规则：**
*   `Symm: a = b / b = a` (若 `⊢ a = b` 则 `⊢ b = a`)
*   `Trans: a = b, b = c / a = c`
*   `Cong-·: a = b / (· a c) = (· b c)` and `a = b / (· c a) = (· c b)`
*   `Cong-equiv: a = b / (equiv a c) = (equiv b c)` and `a = b / (equiv c a) = (equiv c b)`

#### **2.1 替换引理 (Substitution Lemma)**

**引理 2.1 (替换引理 - Substitution Lemma)**

若 `⊢ (equiv a b) = T`，则对于任何一元项语境 (unary term context) `C[·]`，我们有 `⊢ (equiv C[a] C[b]) = T`。

*语境 `C[·]` 指一个带“空位”的项，例如 `(· x [·])` 或 `(equiv T (· a [·]))`。`C[a]` 表示将空位填上项 `a`。*

**证明：**

本引理的证明采用对语境 `C[·]` 的结构进行归纳的方法。

**1. 预备步骤：外化假设**
   1. `⊢ (equiv a b) = T`  (引理的假设)
   2. `⊢ a = b`  (根据步骤 1 和 **A3: 外化规则**)

   现在我们的目标是证明，在 `⊢ a = b` 的前提下，对于任何语境 `C[·]`，都有 `⊢ C[a] = C[b]`。一旦证明了这一点，我们就可以通过 **A4: 内化规则** 得到最终结论 `⊢ (equiv C[a] C[b]) = T`。

**2. 归纳基础 (Base Case)**
   当语境 `C[·]` 是最简单的语境，即 `C[·] = [·]` (空语境) 时：
   1. `C[a]` 等同于 `a`。
   2. `C[b]` 等同于 `b`。
   3. 我们需要证明 `⊢ a = b`。
   4. 这在 **预备步骤** 的第 2 步已经得出。
   5. 因此，基础情况成立。

**3. 归纳步骤 (Inductive Step)**
   假设对于语境 `C'[·]` 和 `C''[·]`，该属性成立。即，若 `⊢ a = b`，则 `⊢ C'[a] = C'[b]` 且 `⊢ C''[a] = C''[b]` (此为**归纳假设**)。
   我们必须证明对于由这些语境构造的更复杂的语境，该属性也成立。项的构造规则有两种 (`·` 和 `equiv`)，因此我们有四种情况需要考虑：

   **情况 (i):** `C[·] = (· C'[·] d)`，其中 `d` 是任意项。
   1. `C[a] = (· C'[a] d)`。
   2. `C[b] = (· C'[b] d)`。
   3. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   4. 根据背景等式逻辑的**合同性规则 (Cong-·)** `x = y / (· x z) = (· y z)`，将此规则应用于 `C'[a] = C'[b]`，可得：
      `⊢ (· C'[a] d) = (· C'[b] d)`。
   5. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (ii):** `C[·] = (· d C'[·])`，其中 `d` 是任意项。
   6. `C[a] = (· d C'[a])`。
   7. `C[b] = (· d C'[b])`。
   8. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   9. 根据背景等式逻辑的**合同性规则 (Cong-·)** `x = y / (· z x) = (· z y)`，可得：
      `⊢ (· d C'[a]) = (· d C'[b])`。
   10. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (iii):** `C[·] = (equiv C'[·] d)`，其中 `d` 是任意项。
   11. `C[a] = (equiv C'[a] d)`。
   12. `C[b] = (equiv C'[b] d)`。
   13. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   14. 根据背景等式逻辑的**合同性规则 (Cong-equiv)** `x = y / (equiv x z) = (equiv y z)`，可得：
      `⊢ (equiv C'[a] d) = (equiv C'[b] d)`。
   15. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (iv):** `C[·] = (equiv d C'[·])`，其中 `d` 是任意项。
   16. `C[a] = (equiv d C'[a])`。
   17. `C[b] = (equiv d C'[b])`。
   18. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   19. 根据背景等式逻辑的**合同性规则 (Cong-equiv)** `x = y / (equiv z x) = (equiv z y)`，可得：
      `⊢ (equiv d C'[a]) = (equiv d C'[b])`。
   20. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

**4. 结论**
   通过对 `C[·]` 的结构归纳，我们证明了若 `⊢ a = b`，则对于任意语境 `C[·]`，`⊢ C[a] = C[b]` 恒成立。

   1. `⊢ C[a] = C[b]` (如上所示)
   2. `⊢ (equiv C[a] C[b]) = T` (根据步骤 1 和 **A4: 内化规则**)

引理 2.1 证毕。∎

---

### **3. 操作语义 (Operational Semantics)**

#### 3.1 操作语义

为了分析系统 M 的计算行为，我们将其核心公理 A1 和 A2 解释为一个有向的项重写系统 (Term Rewriting System, TRS)。该系统定义了项如何通过计算进行化简。

##### **定义 3.1 (重写系统 R)**
项重写系统 `R` 由以下两个重写规则模式组成，对任意项 `a`, `b` 成立：
*   **R1**: `(· (equiv a b) b) → (equiv a (· a b))`
*   **R2**: `(· a (equiv a b)) → (equiv b (· a b))`

##### **定义 3.2 (重写关系)**
1.  **一步重写 (One-Step Reduction)**: 我们称项 `t` 可以一步重写为项 `s`，记作 `t → s`，如果 `s` 是通过在 `t` 的某个子项位置上应用 R1 或 R2 中的一个规则实例得到的。
2.  **重写序列 (Reduction Sequence)**: `t →* s` 表示 `t` 可以通过零步或多步重写得到 `s`。它是 `→` 关系的自反传递闭包。
3.  **可约项 (Reducible Term / Redex)**: 一个项 `t` 如果可以被重写 (即存在 `s` 使得 `t → s`)，则称 `t` 是可约的。匹配规则左部的子项被称为可约式 (redex)。
4.  **正规形式 (Normal Form)**: 一个项 `t` 如果不可再被重写，则称 `t` 处于**正规形式**。

在背景等式逻辑下，系统 M 中的可证等式 `M ⊢ a = b` 等价于 `a` 和 `b` 在 `R` 中存在一个共同的可达项（即 `a` 与 `b` 的 `↔*` 关系，其中 `↔` 是 `→` 的对称闭包）。

---

#### **3.2 证明论与操作语义的等价性**

在本节中，我们建立一个关键的元理论结果，它将系统M的证明论与第3节中定义的操作语义（项重写系统 `R`）精确地联系起来。我们将证明，在M的纯等式子系统（记为 M'，包含背景等式逻辑和公理A1、A2）中，一个等式是可证的，当且仅当它的两边在重写系统 `R` 中可以相互转换。

**定义 3.2.1 (关系 `↔*`)**
关系 `↔` 是 `→` 的对称闭包，即 `a ↔ b` 当且仅当 `a → b` 或 `b → a`。关系 `↔*` 是 `↔` 的自反传递闭包。因此，`a ↔* b` 意味着存在一个序列 `t_0, t_1, ..., t_n` (n ≥ 0) 使得 `a = t_0`, `b = t_n`，并且对于所有的 `i` 从 `0` 到 `n-1`，都有 `t_i ↔ t_{i+1}`。

**定理 3.2.2 (Birkhoff 完全性定理 for M')**
对于系统 M'（即系统 M 排除规则 A3 和 A4），对于任意项 `a`, `b`，我们有：
`M' ⊢ a = b` 当且仅当 `a ↔* b`。

**证明：**
本证明分为两个部分：可靠性 (⇒) 和 完备性 (⇐)。

##### **Part 1: 可靠性 (Soundness)**
**目标：** 证明若 `M' ⊢ a = b`，则 `a ↔* b`。

本证明采用对 `M' ⊢ a = b` 的推导结构进行归纳。我们必须证明 M' 的所有公理模式都满足 `↔*` 关系，并且所有推理规则都保持此关系。

**1. 基础情况 (Axioms)**
   *   **`Refl: a = a`**: 我们需要证明 `a ↔* a`。根据 `↔*` 的定义，它是自反的，因此该情况成立。
   *   **`A1: (· (equiv a b) b) = (equiv a (· a b))`**: 我们需要证明 `(· (equiv a b) b) ↔* (equiv a (· a b))`。根据重写规则 `R1`，我们有 `(· (equiv a b) b) → (equiv a (· a b))`。由 `→ ⊆ ↔*`，该情况成立。
   *   **`A2: (· a (equiv a b)) = (equiv b (· a b))`**: 我们需要证明 `(· a (equiv a b)) ↔* (equiv b (· a b))`。根据重写规则 `R2`，我们有 `(· a (equiv a b)) → (equiv b (· a b))`。由 `→ ⊆ ↔*`，该情况成立。

**2. 归纳步骤 (Inference Rules)**
   *   **`Symm: a = b / b = a`**: 归纳假设为 `a ↔* b`。我们需要证明 `b ↔* a`。根据 `↔*` 的定义，它是对称的，因此该情况成立。
   *   **`Trans: a = b, b = c / a = c`**: <em>归纳</em>假设为 `a ↔* b` 且 `b ↔* c`。我们需要证明 `a ↔* c`。根据 `↔*` 的定义，它是传递的，因此该情况成立。
   *   **`Cong-·` and `Cong-equiv`**: 我们以 `Cong-·` 的 `a = b / (· a c) = (· b c)` 为例。归纳假设为 `a ↔* b`。我们需要证明 `(· a c) ↔* (· b c)`。
      1. `a ↔* b` 意味着存在一个序列 `a = t_0, t_1, ..., t_n = b` 使得 `t_i ↔ t_{i+1}`。
      2. 重写关系 `→` 的定义是在任意项语境下应用的。因此，若 `t_i → t_{i+1}`，则 `(· t_i c) → (· t_{i+1} c)`。若 `t_{i+1} → t_i`，则 `(· t_{i+1} c) → (· t_i c)`。
      3. 在所有情况下，`t_i ↔ t_{i+1}` 蕴含 `(· t_i c) ↔ (· t_{i+1} c)`。
      4. 这就构成了一个序列 `(· a c) = (· t_0 c), (· t_1 c), ..., (· t_n c) = (· b c)`，其中相邻项满足 `↔` 关系。
      5. 因此，`(· a c) ↔* (· b c)`。其他合同性规则的证明完全类似。

由于所有公理和推理规则都在 `↔*` 关系下成立，我们得出结论：若 `M' ⊢ a = b`，则 `a ↔* b`。

##### **Part 2: 完备性 (Completeness)**
**目标：** 证明若 `a ↔* b`，则 `M' ⊢ a = b`。

为了证明这一点，我们首先定义一个关系 `~`，`a ~ b` 当且仅当 `M' ⊢ a = b`。然后我们证明 `~` 是一个包含 `R` 的全等关系。

**1. 证明 `~` 是一个等价关系 (Equivalence Relation)**
   *   **自反性 (Reflexivity)**: `a ~ a` 因为 `M' ⊢ a = a` 是公理 `Refl`。
   *   **对称性 (Symmetry)**: 若 `a ~ b`，则 `M' ⊢ a = b`。根据规则 `Symm`，`M' ⊢ b = a`，因此 `b ~ a`。
   *   **传递性 (Transitivity)**: 若 `a ~ b` 且 `b ~ c`，则 `M' ⊢ a = b` 且 `M' ⊢ b = c`。根据规则 `Trans`，`M' ⊢ a = c`，因此 `a ~ c`。

**2. 证明 `~` 是一个全等关系 (Congruence Relation)**
   我们需要证明 `~` 在所有项构造器下都保持不变。
   *   若 `a ~ b`，即 `M' ⊢ a = b`。根据规则 `Cong-·`，`M' ⊢ (· a c) = (· b c)` 和 `M' ⊢ (· c a) = (· c b)`。因此 `(· a c) ~ (· b c)` 且 `(· c a) ~ (· c b)`。
   *   若 `a ~ b`，即 `M' ⊢ a = b`。根据规则 `Cong-equiv`，`M' ⊢ (equiv a c) = (equiv b c)` 和 `M' ⊢ (equiv c a) = (equiv c b)`。因此 `(equiv a c) ~ (equiv b c)` 且 `(equiv c a) ~ (equiv c b)`。
   *   综上，`~` 是一个全等关系。

**3. 证明 `R ⊆ ~`**
   我们需要证明对于 `R` 中的每一条规则 `l → r`，都有 `l ~ r`。
   *   对于规则 `R1`: `l = (· (equiv a b) b)`, `r = (equiv a (· a b))`。公理 `A1` 断言 `M' ⊢ l = r`。因此，`l ~ r`。
   *   对于规则 `R2`: `l = (· a (equiv a b))`, `r = (equiv b (· a b))`。公理 `A2` 断言 `M' ⊢ l = r`。因此，`l ~ r`。
   *   这表明由 `R` 定义的重写关系被 `~` 所包含。

**4. 结论**
   我们已经证明了 `~` (即 `M' ⊢ _ = _`) 是一个包含所有重写规则 `R` 的全等关系。
   根据定义，`↔*` 是包含 `R` 的**最小**全等关系。
   因此，`↔*` 必须是 `~` 的一个子集，即 `(a ↔* b) ⇒ (a ~ b)`。
   这等价于：若 `a ↔* b`，则 `M' ⊢ a = b`。

两部分证毕。∎

---

### **4. 系统性质证明 (Proof of System Properties)**

本节我们证明重写系统 `R` 具备两个关键性质：终止性和合流性。

#### **4.1. 终止性 (Termination)**

我们通过构造一个严格的良基序 (well-founded ordering) 来证明 `R` 的终止性，确保不存在无限的重写序列。

##### **定义 4.1 (度量函数 φ)**
对于任意项 `t`，我们定义其度量 `φ(t)` 为一个二元组 `(U(t), size(t))`，其构成如下：

1.  `size(t)`: 项 `t` 中符号 (常量与函数) 的总数，递归定义为：
    *   `size(T) = 1`
    *   `size(F) = 1`
    *   `size((· a b)) = 1 + size(a) + size(b)`
    *   `size((equiv a b)) = 1 + size(a) + size(b)`

2.  `U(t)`: 一个递归定义的多重集 (multiset)，其元素为自然数。
    *   首先，定义一个辅助函数 `f(t)`：
        *   若 `t` 的形式为 `(equiv u v)`，则 `f(t) = {size(t)}` (包含 `t` 的大小的单元多重集)。
        *   否则, `f(t) = ∅` (空多重集)。
    *   `U(t)` 的递归定义如下：
        *   `U(T) = ∅`
        *   `U(F) = ∅`
        *   `U((equiv a b)) = U(a) ∪ U(b)` (多重集并集)
        *   `U((· a b)) = f(a) ∪ f(b) ∪ U(a) ∪ U(b)`

我们使用词典序 (lexicographical order) `>` 来比较度量二元组。对于 `(U_1, s_1)` 和 `(U_2, s_2)`，`(U_1, s_1) > (U_2, s_2)` 当且仅当：
*   `U_1 >_mul U_2`，或者
*   `U_1 = U_2` 且 `s_1 > s_2`。
其中 `>_mul` 是标准的多重集序。由于自然数上的标准序 `>` 和在其上的多重集序 `>_mul` 都是良基的，因此该词典序 `>` 也是良基的。

##### **引理 4.1 (终止性)**
重写系统 `R` 是终止的 (terminating)。

**证明：**
我们必须证明对于 `R` 中的任意规则 `l → r`，均有 `φ(l) > φ(r)`，其中 `>` 是对二元组 `(U(t), size(t))` 定义的词典序。为此，我们只需证明对于每条规则，第一个分量满足 `U(l) >_mul U(r)`。`>_mul` 是标准的多重集序。

**情况 1: 规则 R1: `l = (· (equiv a b) b) → r = (equiv a (· a b))`**

1.  **计算 `U(l)`**:
    `U(l) = U((· (equiv a b) b))`
    `     = f((equiv a b)) ∪ f(b) ∪ U((equiv a b)) ∪ U(b)` (根据 `U` 对 `·` 的定义)
    `     = {size((equiv a b))} ∪ f(b) ∪ U((equiv a b)) ∪ U(b)` (根据 `f` 对 `equiv` 的定义)
    `     = {1 + size(a) + size(b)} ∪ f(b) ∪ (U(a) ∪ U(b)) ∪ U(b)` (根据 `size` 和 `U` 对 `equiv` 的定义)
    `     = {1 + size(a) + size(b)} ∪ f(b) ∪ U(a) ∪ U(b) ∪ U(b)`

2.  **计算 `U(r)`**:
    `U(r) = U((equiv a (· a b)))`
    `     = U(a) ∪ U((· a b))` (根据 `U` 对 `equiv` 的定义)
    `     = U(a) ∪ (f(a) ∪ f(b) ∪ U(a) ∪ U(b))` (根据 `U` 对 `·` 的定义)
    `     = f(a) ∪ f(b) ∪ U(a) ∪ U(a) ∪ U(b)`

3.  **比较**:
    为了证明 `U(l) >_mul U(r)`，我们根据多重集序的定义，需构造多重集 `X` 和 `Y`，使得：
    (i) `X` 是 `U(l)` 的一个非空子多重集。
    (ii) `U(r) = (U(l) \ X) ∪ Y` (其中 `\` 是多重集差)。
    (iii) 对于 `Y` 中的任意元素 `y`，`X` 中都存在一个元素 `x`，使得 `x > y`。

    *   令公共部分 `C = f(b) ∪ U(a) ∪ U(b)`。
    *   `U(l) = C ∪ {1 + size(a) + size(b)} ∪ U(b)`
    *   `U(r) = C ∪ f(a) ∪ U(a)`
    *   我们选择：
        *   `X = {1 + size(a) + size(b)} ∪ U(b)`
        *   `Y = f(a) ∪ U(a)`
    *   现在验证上述三个条件：
        (i) 因为 `size` 函数的值总是正整数，`1 + size(a) + size(b) ≥ 3`，所以 `X` 是非空的。
        (ii) `(U(l) \ X) ∪ Y = C ∪ (f(a) ∪ U(a)) = U(r)`。此条件成立。
        (iii) 令 `k = 1 + size(a) + size(b)`。`k` 是 `X` 中的一个元素。对于 `Y` 中的任意元素 `y`：
            *   若 `y ∈ f(a)`，则 `y = size(a)`。显然 `size(a) < 1 + size(a) + size(b) = k`。
            *   若 `y ∈ U(a)`，则 `y` 是 `a` 的某个 `equiv` 形式的真子项的大小。根据项的结构，`y < size(a)`。因此，`y < size(a) < k`。
            该条件成立。

    由于条件 (i), (ii), (iii) 均满足，我们得出 `U(l) >_mul U(r)`。根据词典序的定义，`φ(l) > φ(r)`。

**情况 2: 规则 R2: `l = (· a (equiv a b)) → r = (equiv b (· a b))`**

1.  **计算 `U(l)`**:
    `U(l) = U((· a (equiv a b)))`
    `     = f(a) ∪ f((equiv a b)) ∪ U(a) ∪ U((equiv a b))` (根据 `U` 对 `·` 的定义)
    `     = f(a) ∪ {size((equiv a b))} ∪ U(a) ∪ (U(a) ∪ U(b))` (根据 `f` 和 `U` 的定义)
    `     = {1 + size(a) + size(b)} ∪ f(a) ∪ U(a) ∪ U(a) ∪ U(b)`

2.  **计算 `U(r)`**:
    `U(r) = U((equiv b (· a b)))`
    `     = U(b) ∪ U((· a b))` (根据 `U` 对 `equiv` 的定义)
    `     = U(b) ∪ (f(a) ∪ f(b) ∪ U(a) ∪ U(b))` (根据 `U` 对 `·` 的定义)
    `     = f(a) ∪ f(b) ∪ U(a) ∪ U(b) ∪ U(b)`

3.  **比较**:
    我们采用与情况1相同的策略。
    *   令公共部分 `C = f(a) ∪ U(a) ∪ U(b)`。
    *   `U(l) = C ∪ {1 + size(a) + size(b)} ∪ U(a)`
    *   `U(r) = C ∪ f(b) ∪ U(b)`
    *   我们选择：
        *   `X = {1 + size(a) + size(b)} ∪ U(a)`
        *   `Y = f(b) ∪ U(b)`
    *   现在验证条件：
        (i) `X` 是非空的。
        (ii) `(U(l) \ X) ∪ Y = C ∪ (f(b) ∪ U(b)) = U(r)`。此条件成立。
        (iii) 令 `k = 1 + size(a) + size(b)`。`k` 是 `X` 中的一个元素。对于 `Y` 中的任意元素 `y`：
            *   若 `y ∈ f(b)`，则 `y = size(b)`。显然 `size(b) < 1 + size(a) + size(b) = k`。
            *   若 `y ∈ U(b)`，则 `y` 是 `b` 的某个 `equiv` 形式的真子项的大小，因此 `y < size(b)`。我们有 `y < size(b) < k`。
            该条件成立。

    因此 `U(l) >_mul U(r)`，进而 `φ(l) > φ(r)`。

由于对于 `R` 中的所有规则，左项的度量均严格大于右项的度量，且该度量所基于的词典序是良基的，因此系统 `R` 是终止的。∎

#### **4.2. 合流性 (Confluence)**

##### **引理 4.2 (局部合流性 / 菱形引理)**
重写系统 `R` 是局部合流的 (locally confluent)。

**定义 4.2.1 (局部合流性)**
一个重写系统是局部合流的，如果对于任意项 `t`, `s_1`, `s_2`，若 `t → s_1` 且 `t → s_2`，则存在一个项 `s_3`，使得 `s_1 →* s_3` 且 `s_2 →* s_3`。
这个性质可以用下图来表示：
```
    t
   / \
  ↓   ↓
s_1   s_2
  \   /
   *↓ ↓*
    s_3
```

**证明策略：**
根据临界对引理 (Critical Pair Lemma)，一个项重写系统是局部合流的，当且仅当它的所有临界对都是可汇合的 (joinable)。临界对捕捉了所有可能导致不合流的基本情况。

**定义 4.2.2 (临界对)**
一个临界对产生于两条规则 `l_1 → r_1` 和 `l_2 → r_2` 的左部 `l_1` 和 `l_2` 发生重叠。具体而言，若 `l_1` 在非变量位置 `p` 处有一个子项 `l_1|p`，它可以与 `l_2` 通过最一般合一子 (most general unifier, mgu) `σ` 合一，则 `<σ(r_1), σ(l_1[r_2]_p)>` 构成一个临界对。其中 `l_1[r_2]_p` 表示将 `l_1` 在位置 `p` 的子项替换为 `r_2`。

**分析系统 R 的临界对：**
系统 `R` 的规则为：
*   **R1**: `l_1 = (· (equiv a b) b) → r_1 = (equiv a (· a b))`
*   **R2**: `l_2 = (· a (equiv a b)) → r_2 = (equiv b (· a b))`

1.  **临界对**:
    我们检查一条规则的左部是否能与另一条规则左部的非变量子项合一。
    *   `l_1` 的非变量子项只有其自身和 `(equiv a b)`。`l_2` 的非变量子项只有其自身和 `(equiv a b)`。
    *   `l_1` 和 `l_2` 的根符号均为 `·`，而其子项 `(equiv ...)` 的根符号为 `equiv`。由于根符号不同，`l_1` 或 `l_2` 无法与对方的子项 `(equiv ...)` 合一。
    *   因此，本系统中不存在由非变量重叠产生的临界对。

2.  **重叠的可约式**:
    当一条规则的左部实例成为另一条规则左部中变量的替换实例时，就会出现重叠。这种情况下的“分叉”也必须被证明是可汇合的。我们系统性地检查所有此类情况。

为避免变量名混淆，我们将外部规则的变量记为 `a, b`，内部规则（作为子项）的变量记为 `x, y`。

---
**情况 A: R1 规则的变量中包含可约式**

`l_1 = (· (equiv a b) b)`

**A.1: 变量 `a` 包含 R1 的实例**
令 `a = (· (equiv x y) y)`。构造项 `t`：
`t = (· (equiv (· (equiv x y) y) b) b)`
此项 `t` 在根部是一个 R1 实例，并且其子项 `a` 也是一个 R1 实例。

*   **路径 1 (外部优先重写)**: 对 `t` 应用 R1 规则。
    `t → (equiv (· (equiv x y) y) (· (· (equiv x y) y) b)) = s_1`

*   **路径 2 (内部优先重写)**: 先重写 `t` 的子项 `a`。
    `a = (· (equiv x y) y) → (equiv x (· x y))`
    `t → (· (equiv (equiv x (· x y)) b) b) = s_2'`
    项 `s_2'` 本身是 R1 的一个实例，对其应用 R1：
    `s_2' → (equiv (equiv x (· x y)) (· (equiv x (· x y)) b)) = s_2`

*   **汇合**: `s_1` 中包含子项 `(· (equiv x y) y)`，它可以通过 R1 重写为 `(equiv x (· x y))`。对 `s_1` 中的两个 `a` 进行此重写：
    `s_1 = (equiv (· (equiv x y) y) (· (· (equiv x y) y) b))`
    `→ (equiv (equiv x (· x y)) (· (equiv x (· x y)) b)) = s_2`
    因此 `s_1 →* s_2`。两个分支汇合于 `s_2`。

**A.2: 变量 `b` 包含 R1 的实例**
令 `b = (· (equiv x y) y)`。构造项 `t`：
`t = (· (equiv a (· (equiv x y) y)) (· (equiv x y) y))`

*   **路径 1**: `t → (equiv a (· a (· (equiv x y) y))) = s_1`
*   **路径 2**: `t → (· (equiv a (equiv x (· x y))) (equiv x (· x y))) = s_2'`
    `s_2'` 是 R1 的实例，重写得到:
    `s_2' → (equiv a (· a (equiv x (· x y)))) = s_2`
*   **汇合**: `s_1` 的子项 `(· (equiv x y) y)` 可重写为 `(equiv x (· x y))`。
    `s_1 = (equiv a (· a (· (equiv x y) y))) → (equiv a (· a (equiv x (· x y)))) = s_2`
    两个分支汇合于 `s_2`。

**A.3: 变量 `a` 包含 R2 的实例**
令 `a = (· x (equiv x y))`。构造项 `t`：
`t = (· (equiv (· x (equiv x y)) b) b)`

*   **路径 1**: `t → (equiv (· x (equiv x y)) (· (· x (equiv x y)) b)) = s_1`
*   **路径 2**: `t → (· (equiv (equiv y (· x y)) b) b) = s_2'`
    `s_2' → (equiv (equiv y (· x y)) (· (equiv y (· x y)) b)) = s_2`
*   **汇合**: `s_1` 包含两个子项 `(· x (equiv x y))`，均可重写为 `(equiv y (· x y))`。
    `s_1 →* (equiv (equiv y (· x y)) (· (equiv y (· x y)) b)) = s_2`
    两个分支汇合于 `s_2`。

**A.4: 变量 `b` 包含 R2 的实例**
令 `b = (· x (equiv x y))`。构造项 `t`：
`t = (· (equiv a (· x (equiv x y))) (· x (equiv x y)))`

*   **路径 1**: `t → (equiv a (· a (· x (equiv x y)))) = s_1`
*   **路径 2**: `t → (· (equiv a (equiv y (· x y))) (equiv y (· x y))) = s_2'`
    `s_2' → (equiv a (· a (equiv y (· x y)))) = s_2`
*   **汇合**: `s_1` 的子项 `(· x (equiv x y))` 可重写为 `(equiv y (· x y))`。
    `s_1 → (equiv a (· a (equiv y (· x y)))) = s_2`
    两个分支汇合于 `s_2`。

---
**情况 B: R2 规则的变量中包含可约式**

`l_2 = (· a (equiv a b))`

**B.1: 变量 `a` 包含 R1 的实例**
令 `a = (· (equiv x y) y)`。构造项 `t`：
`t = (· (· (equiv x y) y) (equiv (· (equiv x y) y) b))`

*   **路径 1**: `t → (equiv b (· (· (equiv x y) y) b)) = s_1`
*   **路径 2**: `t → (· (equiv x (· x y)) (equiv (equiv x (· x y)) b)) = s_2'`
    `s_2'` 是 R2 的实例，重写得到:
    `s_2' → (equiv b (· (equiv x (· x y)) b)) = s_2`
*   **汇合**: `s_1` 的子项 `(· (equiv x y) y)` 可重写为 `(equiv x (· x y))`。
    `s_1 → (equiv b (· (equiv x (· x y)) b)) = s_2`
    两个分支汇合于 `s_2`。

**B.2: 变量 `b` 包含 R1 的实例**
令 `b = (· (equiv x y) y)`。构造项 `t`：
`t = (· a (equiv a (· (equiv x y) y)))`

*   **路径 1**: `t → (equiv (· (equiv x y) y) (· a (· (equiv x y) y))) = s_1`
*   **路径 2**: `t → (· a (equiv a (equiv x (· x y)))) = s_2'`
    `s_2'` 是 R2 的实例，重写得到:
    `s_2' → (equiv (equiv x (· x y)) (· a (equiv x (· x y)))) = s_2`
*   **汇合**: 我们证明 `s_1` 和 `s_2` 可汇合于 `s_2`，即 `s_1 →* s_2`。
    项 `s_1 = (equiv (· (equiv x y) y) (· a (· (equiv x y) y)))` 包含两个子项 `(· (equiv x y) y)`，它们均为 R1 规则的可约式。我们可以通过一个两步的重写序列将 `s_1` 化简为 `s_2`：
    1.  `s_1 = (equiv (· (equiv x y) y) (· a (· (equiv x y) y)))`
    2.  `→ (equiv (equiv x (· x y)) (· a (· (equiv x y) y)))`
        （通过对 `s_1` 的第一个参数 `(· (equiv x y) y)` 应用 R1 规则）
    3.  `→ (equiv (equiv x (· x y)) (· a (equiv x (· x y))))`
        （通过对步骤 2 结果中子项 `(· (equiv x y) y)` 应用 R1 规则）

    步骤 3 的最终项与 `s_2` 完全相同。因此，我们证明了 `s_1 →* s_2`。两个分支在此处汇合。

**B.3: 变量 `a` 包含 R2 的实例**
令 `a = (· x (equiv x y))`。构造项 `t`：
`t = (· (· x (equiv x y)) (equiv (· x (equiv x y)) b))`

*   **路径 1**: `t → (equiv b (· (· x (equiv x y)) b)) = s_1`
*   **路径 2**: `t → (· (equiv y (· x y)) (equiv (equiv y (· x y)) b)) = s_2'`
    `s_2' → (equiv b (· (equiv y (· x y)) b)) = s_2`
*   **汇合**: `s_1` 的子项 `(· x (equiv x y))` 可重写为 `(equiv y (· x y))`。
    `s_1 → (equiv b (· (equiv y (· x y)) b)) = s_2`
    两个分支汇合于 `s_2`。

**B.4: 变量 `b` 包含 R2 的实例**
令 `b = (· x (equiv x y))`。构造项 `t`：
`t = (· a (equiv a (· x (equiv x y))))`

*   **路径 1**: `t → (equiv (· x (equiv x y)) (· a (· x (equiv x y)))) = s_1`
*   **路径 2**: `t → (· a (equiv a (equiv y (· x y)))) = s_2'`
    `s_2' → (equiv (equiv y (· x y)) (· a (equiv y (· x y)))) = s_2`
*   **汇合**: 我们证明 `s_1` 和 `s_2` 可汇合于 `s_2`，即 `s_1 →* s_2`。
    项 `s_1 = (equiv (· x (equiv x y)) (· a (· x (equiv x y))))` 包含两个子项 `(· x (equiv x y))`，它们均为 R2 规则的可约式。我们可以通过一个两步的重写序列将 `s_1` 化简为 `s_2`：
    1.  `s_1 = (equiv (· x (equiv x y)) (· a (· x (equiv x y))))`
    2.  `→ (equiv (equiv y (· x y)) (· a (· x (equiv x y))))`
        （通过对 `s_1` 的第一个参数 `(· x (equiv x y))` 应用 R2 规则）
    3.  `→ (equiv (equiv y (· x y)) (· a (equiv y (· x y))))`
        （通过对步骤 2 结果中子项 `(· x (equiv x y))` 应用 R2 规则）

    步骤 3 的最终项与 `s_2` 完全相同。因此，我们证明了 `s_1 →* s_2`。两个分支在此处汇合。

**结论:**
我们已经系统性地检查了所有可能的重叠（在此系统中仅由可约式重叠产生）。在每种情况下，由不同重写选择产生的两个分支 `s_1` 和 `s_2` 都被证明是可汇合的。因此，重写系统 `R` 是局部合流的。∎

##### **定理 4.3 (合流性)**
重写系统 `R` 是合流的 (confluent)。

**证明：**
根据**纽曼引理 (Newman's Lemma)**，一个终止的项重写系统是合流的，当且仅当它是局部合流的。
1.  由引理 4.1，我们证明了 `R` 是终止的。
2.  由引理 4.2，我们证明了 `R` 是局部合流的。
因此，系统 `R` 是合流的。∎

##### **推论 4.4 (唯一正规形式)**
对于任意项 `t`，存在一个唯一的正规形式 `s` 使得 `t →* s`。我们将这个唯一的正规形式记为 `NF(t)`。

### **5. 句法性质与一致性 (Syntactic Properties and Consistency)**

本节将分析系统 M 的两个关键元理论性质：一个关于应用函数 `·` 数量的句法不变量，以及系统的非平凡一致性。

#### **5.1. 应用数守恒性质 (Conservation Property of Application Count)**

我们首先定义一个度量函数，用于计算项中应用函数 `·` 的出现次数，并证明一个与此度量相关的关键引理。

##### **定义 5.1.1 (应用函数计数)**
函数 `C_·(t)`，表示项 `t` 中函数符号 `·` 的出现总次数，其递归定义如下：
1.  `C_·(T) = 0`
2.  `C_·(F) = 0`
3.  `C_·((equiv a b)) = C_·(a) + C_·(b)`
4.  `C_·((· a b)) = 1 + C_·(a) + C_·(b)`

##### **引理 5.1.2 (应用数1-集在 ↔\* 下的封闭性)**
令 `S_1` 为所有满足 `C_·(t) = 1` 的项 `t` 的集合。若 `t ∈ S_1` 且 `t ↔* s`，则 `s ∈ S_1`。

**证明：**
为了证明 `S_1` 在自反传递闭包 `↔*` 下是封闭的，我们仅需证明它在单步对称关系 `↔` 下是封闭的。即，若 `t ∈ S_1` 且 `t ↔ s`，则 `s ∈ S_1`。这需要考虑 `t → s` 和 `s → t` 两种情况。

**情况 1: `t → s`，其中 `t ∈ S_1`**
1.  根据定义 5.1.1，若 `C_·(t) = 1`，则项 `t` 的顶层结构必须是 `(· X Y)`，且其直接子项 `X` 和 `Y` 必须不含 `·` 函数，即 `C_·(X) = 0` 且 `C_·(Y) = 0`。
2.  因为 `t → s`，项 `t` 必须包含一个可约式。由于重写规则 R1 和 R2 的左部都以 `·` 为根，而 `X` 和 `Y` 是 `·`-自由的，所以 `X` 和 `Y` 不可能包含可约式。因此，唯一可能的可约式就是 `t` 本身。
3.  项 `t = (· X Y)` 必须匹配规则 R1 或 R2 的左部模式。
    *   **子情况 (a):** `t` 匹配 `(· (equiv a b) b)` (R1)。
        此时 `X = (equiv a b)` 且 `Y = b`。由 `C_·(X) = 0` 和 `C_·(Y) = 0`，可推得 `C_·(a) = 0` 且 `C_·(b) = 0`。
        重写后的项为 `s = (equiv a (· a b))`。
        我们计算 `s` 的应用数：
        `C_·(s) = C_·((equiv a (· a b))) = C_·(a) + C_·((· a b)) = C_·(a) + (1 + C_·(a) + C_·(b))`
        代入 `C_·(a) = 0` 和 `C_·(b) = 0`，得 `C_·(s) = 0 + (1 + 0 + 0) = 1`。
        故 `s ∈ S_1`。
    *   **子情况 (b):** `t` 匹配 `(· a (equiv a b))` (R2)。
        此时 `X = a` 且 `Y = (equiv a b)`。由 `C_·(X) = 0` 和 `C_·(Y) = 0`，可推得 `C_·(a) = 0` 且 `C_·(b) = 0`。
        重写后的项为 `s = (equiv b (· a b))`。
        我们计算 `s` 的应用数：
        `C_·(s) = C_·((equiv b (· a b))) = C_·(b) + C_·((· a b)) = C_·(b) + (1 + C_·(a) + C_·(b))`
        代入 `C_·(a) = 0` 和 `C_·(b) = 0`，得 `C_·(s) = 0 + (1 + 0 + 0) = 1`。
        故 `s ∈ S_1`。
此两种子情况表明，若 `t ∈ S_1` 且 `t → s`，则 `s ∈ S_1`。

**情况 2: `s → t`，其中 `t ∈ S_1`**
1.  若 `s → t`，则 `t` 必须是规则 R1 或 R2 右部的一个实例。
2.  若 `t` 是 `(equiv a (· a b))` 的实例，则 `C_·(t) = C_·(a) + C_·((· a b)) = 1 + 2·C_·(a) + C_·(b)`。
3.  若 `t` 是 `(equiv b (· a b))` 的实例，则 `C_·(t) = C_·(b) + C_·((· a b)) = 1 + C_·(a) + 2·C_·(b)`。
4.  我们已知 `t ∈ S_1`，即 `C_·(t) = 1`。在上述两种表达式中，由于 `C_·` 函数的值是非负整数，这都必然要求 `C_·(a) = 0` 且 `C_·(b) = 0`。
5.  项 `s` 必定是对应规则左部的实例。
    *   若 `t` 是 R1 右部的实例，则 `s = (· (equiv a b) b)`。我们计算 `s` 的应用数：
        `C_·(s) = 1 + C_·((equiv a b)) + C_·(b) = 1 + (C_·(a) + C_·(b)) + C_·(b) = 1 + 0 + 0 + 0 = 1`。
        故 `s ∈ S_1`。
    *   若 `t` 是 R2 右部的实例，则 `s = (· a (equiv a b))`。我们计算 `s` 的应用数：
        `C_·(s) = 1 + C_·(a) + C_·((equiv a b)) = 1 + C_·(a) + (C_·(a) + C_·(b)) = 1 + 0 + 0 + 0 = 1`。
        故 `s ∈ S_1`。
此情况表明，若 `t ∈ S_1` 且 `s → t`，则 `s ∈ S_1`。

**结论：**
由于 `S_1` 在 `→` 及其逆关系 `←` 下都是封闭的，因此它在 `↔` 下是封闭的。根据归纳法，`S_1` 在 `↔` 的自反传递闭包 `↔*` 下也是封闭的。∎

#### **5.2. 非平凡一致性 (Non-trivial Consistency)**

我们将利用系统 `R` 的终止性和合流性来证明系统 M 的一致性，即它不能证明所有公式。一个标准的判据是证明 `T = F` 是不可证的。

##### **定理 5.2.1 (非平凡一致性)**
系统 M 是非平凡一致的，即公式 `T = F` 在系统 M 中是不可证的。记为 `M ⊬ T = F`。

**证明：**
采用反证法。
1.  假设 `M ⊢ T = F` 是系统 M 的一个定理。
2.  若 `M ⊢ T = F` 可证，其推导的最后一步必须是**A3: 外化规则**的应用，否则该等式在 M' 中就可证。
    *   (附注：若 `M' ⊢ T = F`，根据**定理 3.2.2**，这意味着 `T ↔* F`。然而，根据**推论 4.4**，这要求 `NF(T) = NF(F)`。由于 `T` 和 `F` 都是不含 `·` 的项，它们自身即为正规形式，且 `T ≠ F`。这是一个矛盾。因此 `M' ⊬ T = F`。)
3.  根据步骤 2，`M ⊢ T = F` 必然是由 `M ⊢ (equiv T F) = T` 作为前提，通过应用 A3 得到的。

4.  现在我们考察前提 `M ⊢ (equiv T F) = T`。我们将证明，此公式在系统 `M` 中可证的唯一可能性是，它已经在子系统 `M'` 中可证。

    我们采用反证法。假设 `M ⊢ (equiv T F) = T` 成立，但 `M' ⊬ (equiv T F) = T`。

    这个假设意味着，任何对 `(equiv T F) = T` 的 `M`-证明都必须至少使用一次规则 A3 或 A4，因为若不使用，该证明就完全位于 `M'` 内部，与假设矛盾。

    考虑所有此类 `M`-证明。根据良基归纳法原理，必然存在一个证明长度最短的 `M`-证明，其结论 `u=v` 满足 `M ⊢ u=v` 但 `M' ⊬ u=v`。令 `D` 为这样一个最小证明，其结论为 `u=v`。

    分析 `D` 的最后一步推理：
    *   **情况 (i):** 最后一步是 `M'` 的推理规则（如 `Symm`, `Trans`, `Cong-*`）。以 `Trans` 为例，`u=v` 是由 `u=w` 和 `w=v` 推导出的。`u=w` 和 `w=v` 的证明长度都比 `D` 短。根据 `D` 的最小性假设，`u=w` 和 `w=v` 必须都在 `M'` 中可证，即 `M' ⊢ u=w` 且 `M' ⊢ w=v`。但由于 `M'` 本身闭合在 `Trans` 规则下，这意味着 `M' ⊢ u=v`，这与 `u=v` 是一个非 `M'`-定理的假设相矛盾。其他 `M'` 规则的分析也得出相同矛盾。
    *   **情况 (ii):** 最后一步是规则 A4，`a=b / (equiv a b)=T`。此时 `u=(equiv a b)` 且 `v=T`。其前提 `a=b` 的证明长度比 `D` 短。根据 `D` 的最小性，前提必须在 `M'` 中可证，即 `M' ⊢ a=b`。
    *   **情况 (iii):** 最后一步是规则 A3，`(equiv a b)=T / a=b`。此时 `u=a` 且 `v=b`。其前提 `(equiv a b)=T` 的证明长度比 `D` 短。根据 `D` 的最小性，前提必须在 `M'` 中可证，即 `M' ⊢ (equiv a b)=T`。

    该分析表明，任何在 `M` 中可证但在 `M'` 中不可证的定理，都必须可以通过对一个 **`M'`-可证定理** 应用单步 A3 或 A4 推导出来。

    现在，将此结论应用于我们的前提 `M ⊢ (equiv T F) = T`，同时假设 `M' ⊬ (equiv T F) = T`。根据上述分析，`(equiv T F) = T` 的证明必然满足情况 (ii) 的结构（因为它不匹配情况 (iii) 的结论形式）。这意味着存在一个前提 `T=F`，使得 `M' ⊢ T=F`。然而，正如附注中所论证的，`M' ⊬ T=F`（因为 `NF(T) = T ≠ F = NF(F)`）。

    这个矛盾证明了我们的初始假设（“`M ⊢ (equiv T F) = T` 但 `M' ⊬ (equiv T F) = T`”）是错误的。因此，从 `M ⊢ (equiv T F) = T` 唯一能得出的有效结论是 `M' ⊢ (equiv T F) = T`。
1.  根据**定理 3.2.2**，`M' ⊢ (equiv T F) = T` 等价于 `(equiv T F) ↔* T`。
2.  根据**推论 4.4 (唯一正规形式)**，` (equiv T F) ↔* T` 蕴含 `NF((equiv T F)) = NF(T)`。
3.  我们分析两个项的正规形式：
    *   项 `T` 不含任何可约式（其根不是 `·`），因此 `T` 处于正规形式。`NF(T) = T`。
    *   项 `(equiv T F)` 也不含任何可约式，因此它也处于正规形式。`NF((equiv T F)) = (equiv T F)`。
4.  将步骤 7 的结果代入步骤 6 的等式中，我们得到 `(equiv T F) = T`。
5.  这是一个句法上的矛盾，因为 `(equiv T F)` 和 `T` 是两个不同的项。
6. 由于我们的初始假设 `M ⊢ T = F` 导出了一个矛盾，故该假设为假。
7. 因此，`M ⊬ T = F`，系统 M 是非平凡一致的。∎

#### **5.3. 通过句法不变量证明一致性 (Consistency via Syntactic Invariant)**

本节利用第 5.1 节建立的应用数守恒性质来提供系统 M 非平凡一致性的一个直接证明。我们将证明一个特定的、结构上不匹配的等式是不可证的。

**5.3.1. 将 M-可证性归约至 M'-可证性 (Reduction of M-provability to M'-provability)**

**命题 5.3.1.** 若 `M ⊢ T = (· T T)`，则必有 `M' ⊢ T = (· T T)`。

**证明：**
为证明此命题，我们首先建立一个关于系统 M 和 M' 之间关系的一般性引理。

**引理 5.3.1.1.** 令 `u = v` 为任意公式。若 `M ⊢ u = v` 但 `M' ⊬ u = v`，则 `u = v` 的证明必然可以转化为以下两种结构之一：
   (a) 存在项 `a, b` 使得 `u = (equiv a b)` 且 `v = T`，并且 `M' ⊢ a = b`。
   (b) 存在项 `a, b` 使得 `u = a` 且 `v = b`，并且 `M' ⊢ (equiv a b) = T`。

**引理证明：**
我们采用反证法。假设存在一个公式集合 `S = { φ | M ⊢ φ 且 M' ⊬ φ }`，该集合非空。由于任何证明的长度都是一个正整数，根据自然数的良序原理，必然存在一个 `φ ∈ S`，其在 `M` 中的证明 `D` 具有**最小长度**。令 `φ` 为 `u = v`。我们分析推导出 `u = v` 的 `D` 的最后一步推理规则：

*   **情况 (i): 最后一步是 M' 的推理规则之一** (即 `Symm`, `Trans`, `Cong-*`)。
    以 `Trans` 为例：`u = v` 是由前提 `u = w` 和 `w = v` 推导得出。这两个前提的证明长度严格小于 `D` 的长度。根据 `D` 长度的最小性，这两个前提公式不能属于集合 `S`。因此，必有 `M' ⊢ u = w` 且 `M' ⊢ w = v`。然而，由于 `M'` 对其自身的推理规则（包括 `Trans`）是封闭的，故可立即推得 `M' ⊢ u = v`。但这与 `u = v ∈ S` 的假设相矛盾。对于其他 `M'` 规则的分析将导出同样的矛盾。因此，`D` 的最后一步不可能是 `M'` 的规则。

*   **情况 (ii): 最后一步是 M 的规则 (A3 或 A4)**。
    由于情况 (i) 已被排除，`D` 的最后一步必然是 A3 或 A4。
    *   **子情况 (ii-a): 最后一步是 A4: 内化规则**，`a = b / (equiv a b) = T`。
        此时，`u = (equiv a b)` 且 `v = T`。其前提 `a = b` 的证明长度严格小于 `D`。根据 `D` 长度的最小性，`a = b` 不属于 `S`，因此 `M' ⊢ a = b`。这完全符合引理结论 (a) 的结构。
    *   **子情况 (ii-b): 最后一步是 A3: 外化规则**，`(equiv a b) = T / a = b`。
        此时，`u = a` 且 `v = b`。其前提 `(equiv a b) = T` 的证明长度严格小于 `D`。根据 `D` 长度的最小性，`(equiv a b) = T` 不属于 `S`，因此 `M' ⊢ (equiv a b) = T`。这完全符合引理结论 (b) 的结构。

综上所述，任何在 `M` 中可证但在 `M'` 中不可证的公式，其最小长度证明的结构必然符合引理所述。引理证毕。∎

**应用引理完成命题 5.3.1 的证明：**

现在，我们应用此引理来证明原命题。我们再次使用反证法。

1.  **假设** `M ⊢ T = (· T T)` 成立，但 `M' ⊬ T = (· T T)` 不成立。
2.  根据此假设，公式 `T = (· T T)` 满足引理 5.3.1.1 的条件。因此，它必须符合该引理描述的两种结构之一。
3.  **检验结构 (a):** 此结构要求 `T = (equiv a b)` 且 `(· T T) = T`。第二个等式 `(· T T) = T` 在句法上为假。因此，该公式不符合结构 (a)。
4.  **检验结构 (b):** 此结构要求存在项 `a, b` 使得 `T = a` 且 `(· T T) = b`，并且 `M' ⊢ (equiv a b) = T`。代入 `a` 和 `b`，这意味着必须有 `M' ⊢ (equiv T (· T T)) = T`。
5.  然而，`M' ⊢ (equiv T (· T T)) = T` 这一结论自身导致了矛盾。根据**定理 3.2.2 (Birkhoff)**，它等价于 `(equiv T (· T T)) ↔* T`。
6.  根据**推论 4.4 (唯一正规形式)**，此关系蕴含 `NF((equiv T (· T T))) = NF(T)`。
7.  项 `(equiv T (· T T))` 不包含任何可约式（其根符号为 `equiv`），故其自身即为正规形式。项 `T` 亦是正规形式。
8.  因此，我们得到 `(equiv T (· T T)) = T`，这是一个句法上的矛盾。
9.  由于两种可能结构均被排除（结构(a)因句法形式不匹配，结构(b)导致逻辑矛盾），我们最初的假设“`M ⊢ T = (· T T)` 但 `M' ⊬ T = (· T T)`”必然为假。
10. 唯一的可能性是，如果 `M ⊢ T = (· T T)`，那么 `M' ⊢ T = (· T T)` 必须也成立。

命题 5.3.1 证毕。∎

##### **定理 5.3.2 (非平凡一致性)**
系统 M 是非平凡一致的，具体而言，公式 `T = (· T T)` 在系统 M 中是不可证的。即 `M ⊬ T = (· T T)`。

**证明：**
本证明采用反证法。

1.  **假设** `M ⊢ T = (· T T)`。

2.  **证明 `M' ⊢ T = (· T T)`**。由引理5.3.1可知。

3.  **应用 Birkhoff 定理与对称性**。
    由 `M' ⊢ T = (· T T)`，根据**定理 3.2.2**，我们有 `T ↔* (· T T)`。
    由于 `↔*` 关系是对称的，我们亦有 `(· T T) ↔* T`。

4.  **利用引理 5.1.2 导出矛盾**。
    1.  令项 `u = (· T T)`。根据**定义 5.1.1**，计算其应用函数数：
        `C_·(u) = C_·((· T T)) = 1 + C_·(T) + C_·(T) = 1 + 0 + 0 = 1`。
    2.  根据定义，`u ∈ S_1` (应用数为 1 的项的集合)。
    3.  令项 `v = T`。我们在步骤 3 中已确立 `u ↔* v`。
    4.  根据**引理 5.1.2**，若 `u ∈ S_1` 且 `u ↔* v`，则必有 `v ∈ S_1`。
    5.  `v ∈ S_1` 意味着 `C_·(v) = 1`。
    6.  然而，根据**定义 5.1.1** 直接计算 `v` 的应用函数数：
        `C_·(v) = C_·(T) = 0`。
    7.  步骤 4.5 和 4.6 的结论 `1 = 0` 构成了一个算术矛盾。

5.  **结论**。
    我们的初始假设 `M ⊢ T = (· T T)` 导出了一个矛盾。因此，该假设为假。
    故 `M ⊬ T = (· T T)`。
    由于存在一个在系统 M 中不可证的公式，系统 M 被证明是非平凡一致的。

∎
