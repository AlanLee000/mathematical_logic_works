### **反思性生成系统 (A Reflexive Generative System R)**

#### **1. 语法 (Syntax)**

**1.1. 基础集合**

*   `A`：一个可数的原子项（Atoms）集合。`a ∈ A`。
*   `V`：一个可数的位点标识符（Site Identifiers）集合。`v ∈ V`。
*   `F`：一个带元数（arity）的函数符号（Function Symbols）集合。`f ∈ F`，`arity(f) ∈ ℕ`。

**1.2. 项 (Terms)**

项的集合 `T` 被归纳定义如下：
1.  如果 `a ∈ A`，那么 `a ∈ T`。（原子项）
2.  如果 `σ` 是一个生成性位点（见 2.1 定义），那么 `σ ∈ T`。（位点项）
3.  如果 `f ∈ F`，`arity(f) = n`，并且 `t₁, ..., tₙ ∈ T`，那么 `f(t₁, ..., tₙ) ∈ T`。（复合项）

**1.3. 上下文 (Contexts)**

上下文的集合 `C` 是带有一个唯一“空位” `[]` 的项。其归纳定义如下：
1.  `[]` 是一个上下文。
2.  如果 `f ∈ F`，`arity(f) = n`，`t₁, ..., tᵢ₋₁, tᵢ₊₁, ..., tₙ ∈ T`，并且 `Cᵢ` 是一个上下文，那么 `f(t₁, ..., tᵢ₋₁, Cᵢ, tᵢ₊₁, ..., tₙ)` 是一个上下文。

若 `C ∈ C` 且 `t ∈ T`，则 `C[t]` 表示将 `C` 中的空位 `[]` 替换为项 `t` 后得到的项。

#### **2. 核心组件 (Core Components)**

**2.1. 生成性位点 (Generative Sites)**

一个生成性位点 `σ` 是一个四元组：`σ = (v, s, U, G)`，其中：
*   `v ∈ V` 是该位点的唯一标识符。
*   `s ∈ S` 是该位点的当前内部状态（State），`S` 是一个预定义的、非空的状态集。
*   `U` 是该位点的状态更新函数（State Update Function）。
*   `G` 是该位点的规则生成函数（Rule Generator Function）。

为方便表示，对于位点 `σ = (v, s, U, G)`，我们使用以下投影函数：
*   `id(σ) = v`
*   `state(σ) = s`
*   `update(σ) = U`
*   `gen(σ) = G`

**2.2. 状态更新函数 (State Update Function)**

状态更新函数 `U` 的签名为：
`U: S × C → S`
它接收位点当前的状态 `s` 和其所处的上下文 `C`，计算出位点的新状态 `s'`。

**2.3. 规则生成函数 (Rule Generator Function)**

规则生成函数 `G` 的签名为：
`G: S × C → R`
其中 `R` 是重写规则（Rewrite Rules）的集合。`G` 接收一个状态 `s` 和上下文 `C`，生成一条形式为 `σ → t'` 的重写规则，其中 `t' ∈ T`。`t'` 中可以包含新的生成性位点。新生成的位点 `σ_new` 的初始状态由系统的一个初始化函数 `Init: V → (S × (S×C→S) × (S×C→R))` 决定。

#### **3. 系统动力学 (System Dynamics)**

**3.1. 系统格局 (System Configuration)**

一个系统格局（Configuration）就是一个项 `t ∈ T`。

**3.2. 单步转移关系 (One-Step Transition Relation)**

系统的单步转移关系 `→` 是在项集合 `T` 上的一个二元关系，`t → t'`。其定义由以下推导规则给出：

```
t = C[σ]                                  (1. 项 t 包含位点 σ)
s = state(σ)                                (2. 获取 σ 的当前状态)
U = update(σ)                               (3. 获取 σ 的状态更新函数)
G = gen(σ)                                  (4. 获取 σ 的规则生成函数)
s' = U(s, C)                                (5. 计算新状态 s')
(σ → t') = G(s', C)                         (6. 基于新状态 s' 生成重写规则)
-----------------------------------------------------------------------
              t → C[t']                     (推论: t 转移到 C[t'])
```

*   此规则是非确定性的：如果一个项 `t` 中包含多个位点，则任何一个位点都可以被选择用于触发转移。
*   `→*` 是 `→` 的自反传递闭包，表示多步转移。

---

### **4. 示例 (Example)**

**4.1. 系统规约**

*   原子集 `A = {0, 1}`
*   位点标识符集 `V = {v₀, v₁, v₂, ...}`
*   函数符号集 `F = {pair(t₁, t₂)}`
*   状态集 `S = {INITIAL, EXPAND, TERMINATE}`
*   位点 `σ = (v, s, U, G)` 的 `U` 和 `G` 定义如下：

    **状态更新函数 `U(s, C)`:**
    ```
    U(s, C) = 
      if C = [] then EXPAND
      else TERMINATE
    ```
    *解读：如果位点处于根位置（空上下文），则其状态变为 EXPAND；否则变为 TERMINATE。*

    **规则生成函数 `G(s', C)`:**
    ```
    G(s', C) =
      if s' = EXPAND then
        σ → pair(σ₁, σ₂)  // σ₁ 和 σ₂ 是具有新标识符和 INITIAL 状态的新位点
      else if s' = TERMINATE then
        σ → 0
      else // 包括 s' = INITIAL 的情况
        σ → σ // 空操作规则
    ```    *解读：若状态为 EXPAND，位点分裂为一对新位点。若为 TERMINATE，位点变为原子 `0`。否则不变。*

**4.2. 推导过程**

令初始格局为 `t₀ = σ₀`，其中 `id(σ₀) = v₀`，`state(σ₀) = INITIAL`。

**步骤 1: `t₀ → t₁`**

1.  `t₀ = C[σ₀]`，其中 `C = []` (空上下文)。
2.  `s = state(σ₀) = INITIAL`。
3.  `s' = U(s, C) = U(INITIAL, []) = EXPAND`。
4.  `(σ₀ → t') = G(s', C) = G(EXPAND, []) = (σ₀ → pair(σ₁, σ₂))`。
5.  应用规则，得到 `t₁ = C[t'] = [] [pair(σ₁, σ₂)] = pair(σ₁, σ₂)`。

所以，`σ₀ → pair(σ₁, σ₂)`。

**步骤 2: `t₁ → t₂` (选择 `σ₁` 进行展开)**

1.  `t₁ = C[σ₁]`，其中 `C = pair([], σ₂)`。
2.  `s = state(σ₁) = INITIAL` (新生成的位点)。
3.  `s' = U(s, C) = U(INITIAL, pair([], σ₂)) = TERMINATE`。
4.  `(σ₁ → t') = G(s', C) = G(TERMINATE, pair([], σ₂)) = (σ₁ → 0)`。
5.  应用规则，得到 `t₂ = C[t'] = pair([], σ₂)[0] = pair(0, σ₂)`。

所以，`pair(σ₁, σ₂) → pair(0, σ₂)`。

通过类似步骤展开 `σ₂`，最终系统会达到稳定状态 `pair(0, 0)`。