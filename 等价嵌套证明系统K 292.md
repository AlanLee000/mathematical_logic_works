# **等价嵌套证明系统K**

### **1. 语法 (Syntax)**

**1.1. 函数 (Functions)**

*   `·`：一个二元函数，表示**应用**。记为 `(· a b)`。
*   `equiv`：一个二元函数，表示**等价**。记为 `(equiv a b)`。

**1.2. 常量 (Constants)**

*   `T`：一个零元函数（原子项），代表**已证实的等价性**或**真理**。
*   `F`：一个零元函数（原子项）。

**1.3. 项 (Terms)**

项的集合由以下规则递归定义：
1.  `T` 是项。
2.  `F` 是项。
3.  若 `a` 和 `b` 是项，则 `(· a b)` 是项。
4.  若 `a` 和 `b` 是项，则 `(equiv a b)` 是项。

**1.4. 公式 (Formulas)**

公式的集合如下构成：
1. 若 `a` 和 `b` 是项，则  `a = b`是公式。
### **2. 证明论**

对于任意项 `a`, `b`, `c`, `d`, `f`, `x`：

**核心交互公理模式**

*   **A1: 右动作 (Right Action)**
    `(· (equiv a b) b) = (equiv a (· a b))`

*   **A2: 左动作 (Left Action)**
    `(· a (equiv a b)) = (equiv b (· a b))`


**外化规则**

*    **A3: 外化规则**
```
	若 ⊢ (equiv a b) = T
	-------------------- (A3)
	则 ⊢ a = b
```

*   **A4: 内化规则**
```
	若 ⊢ a = b
	-------------------- (A4)
	则 ⊢ (equiv a b) = T
```

**证明原则公理**

*   **A5: 单位元律**
	`(equiv x T) = x`

**背景等式逻辑 (Background Equational Logic)**
证明关系 `⊢` 被假定在一个标准的等式逻辑框架内，该框架确保了 ` = ` 作为一个全等关系 (congruence relation)。这意味着以下结构性规则对于任何推导都有效：
**公理模式：**
*   `Refl: a = a`
**推理规则：**
*   `Symm: a = b / b = a` (若 `⊢ a = b` 则 `⊢ b = a`)
*   `Trans: a = b, b = c / a = c`
*   `Cong-·: a = b / (· a c) = (· b c)` and `a = b / (· c a) = (· c b)`
*   `Cong-equiv: a = b / (equiv a c) = (equiv b c)` and `a = b / (equiv c a) = (equiv c b)`

#### **2.1 替换引理 (Substitution Lemma)**

**引理 2.1 (替换引理 - Substitution Lemma)**

若 `⊢ (equiv a b) = T`，则对于任何一元项语境 (unary term context) `C[·]`，我们有 `⊢ (equiv C[a] C[b]) = T`。

*语境 `C[·]` 指一个带“空位”的项，例如 `(· x [·])` 或 `(equiv T (· a [·]))`。`C[a]` 表示将空位填上项 `a`。*

**证明：**

本引理的证明采用对语境 `C[·]` 的结构进行归纳的方法。

**1. 预备步骤：外化假设**
   1. `⊢ (equiv a b) = T`  (引理的假设)
   2. `⊢ a = b`  (根据步骤 1 和 **A3: 外化规则**)

   现在我们的目标是证明，在 `⊢ a = b` 的前提下，对于任何语境 `C[·]`，都有 `⊢ C[a] = C[b]`。一旦证明了这一点，我们就可以通过 **A4: 内化规则** 得到最终结论 `⊢ (equiv C[a] C[b]) = T`。

**2. 归纳基础 (Base Case)**
   当语境 `C[·]` 是最简单的语境，即 `C[·] = [·]` (空语境) 时：
   1. `C[a]` 等同于 `a`。
   2. `C[b]` 等同于 `b`。
   3. 我们需要证明 `⊢ a = b`。
   4. 这在 **预备步骤** 的第 2 步已经得出。
   5. 因此，基础情况成立。

**3. 归纳步骤 (Inductive Step)**
   假设对于语境 `C'[·]` 和 `C''[·]`，该属性成立。即，若 `⊢ a = b`，则 `⊢ C'[a] = C'[b]` 且 `⊢ C''[a] = C''[b]` (此为**归纳假设**)。
   我们必须证明对于由这些语境构造的更复杂的语境，该属性也成立。项的构造规则有两种 (`·` 和 `equiv`)，因此我们有四种情况需要考虑：

   **情况 (i):** `C[·] = (· C'[·] d)`，其中 `d` 是任意项。
   1. `C[a] = (· C'[a] d)`。
   2. `C[b] = (· C'[b] d)`。
   3. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   4. 根据背景等式逻辑的**合同性规则 (Cong-·)** `x = y / (· x z) = (· y z)`，将此规则应用于 `C'[a] = C'[b]`，可得：
      `⊢ (· C'[a] d) = (· C'[b] d)`。
   5. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (ii):** `C[·] = (· d C'[·])`，其中 `d` 是任意项。
   6. `C[a] = (· d C'[a])`。
   7. `C[b] = (· d C'[b])`。
   8. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   9. 根据背景等式逻辑的**合同性规则 (Cong-·)** `x = y / (· z x) = (· z y)`，可得：
      `⊢ (· d C'[a]) = (· d C'[b])`。
   10. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (iii):** `C[·] = (equiv C'[·] d)`，其中 `d` 是任意项。
   11. `C[a] = (equiv C'[a] d)`。
   12. `C[b] = (equiv C'[b] d)`。
   13. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   14. 根据背景等式逻辑的**合同性规则 (Cong-equiv)** `x = y / (equiv x z) = (equiv y z)`，可得：
      `⊢ (equiv C'[a] d) = (equiv C'[b] d)`。
   15. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (iv):** `C[·] = (equiv d C'[·])`，其中 `d` 是任意项。
   16. `C[a] = (equiv d C'[a])`。
   17. `C[b] = (equiv d C'[b])`。
   18. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   19. 根据背景等式逻辑的**合同性规则 (Cong-equiv)** `x = y / (equiv z x) = (equiv z y)`，可得：
      `⊢ (equiv d C'[a]) = (equiv d C'[b])`。
   20. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

**4. 结论**
   通过对 `C[·]` 的结构归纳，我们证明了若 `⊢ a = b`，则对于任意语境 `C[·]`，`⊢ C[a] = C[b]` 恒成立。

   1. `⊢ C[a] = C[b]` (如上所示)
   2. `⊢ (equiv C[a] C[b]) = T` (根据步骤 1 和 **A4: 内化规则**)

引理 2.1 证毕。∎

---

### **3. 系统内定理推演**

#### **引理 3.1**

对于任意项 `x`，`⊢ (· x T) = (· T x)`。

**证明:**

1.  `⊢ x = x`
    *   来源: **Refl** (背景等式逻辑的自反性公理)

2.  `⊢ (equiv x x) = T`
    *   来源: 步骤 1, **A4: 内化规则**

3.  `(· (equiv x x) x) = (equiv x (· x x))`
    *   来源: **A1: 右动作** (令 `a=x`, `b=x`)

4.  `⊢ (· T x) = (equiv x (· x x))`
    *   来源: 步骤 2, 步骤 3, **Cong-·** (在步骤 3 的左侧用 `T` 替换 `(equiv x x)`)

5.  `(· x (equiv x x)) = (equiv x (· x x))`
    *   来源: **A2: 左动作** (令 `a=x`, `b=x`)

6.  `⊢ (· x T) = (equiv x (· x x))`
    *   来源: 步骤 2, 步骤 5, **Cong-·** (在步骤 5 的左侧用 `T` 替换 `(equiv x x)`)

7.  `⊢ (· T x) = (· x T)`
    *   来源: 步骤 4, 步骤 6, **Symm** (对称性) 应用于步骤 6，然后与步骤 4 进行 **Trans** (传递性)
    *   详细过程:
        a. `⊢ (equiv x (· x x)) = (· x T)` (步骤 6, **Symm**)
        b. `⊢ (· T x) = (· x T)` (步骤 4, 步骤 7a, **Trans**)

**引理 3.1 证毕。∎**

---

#### **定理 3.2**

对于任意项 `x`，`⊢ (· x T) = (equiv x (· x T))`。

**证明:**

1.  `(· (equiv a b) b) = (equiv a (· a b))`
    *   来源: **A1: 右动作** (公理模式)

2.  `(· (equiv x T) T) = (equiv x (· x T))`
    *   来源: 步骤 1 的一个实例 (令 `a=x`, `b=T`)

3.  `(equiv x T) = x`
    *   来源: **A5: 单位元律** (公理模式)

4.  `⊢ (· x T) = (equiv x (· x T))`
    *   来源: 步骤 2, 步骤 3, **Cong-·** (在步骤 2 的左侧用 `x` 替换 `(equiv x T)`)

**定理 3.2 证毕。∎**

---

#### **定理 3.3**

对于任意项 `x`，`⊢ (· x x) = (equiv T (· x T))`。

**证明:**

1.  `(· a (equiv a b)) = (equiv b (· a b))`
    *   来源: **A2: 左动作** (公理模式)

2.  `(· x (equiv x T)) = (equiv T (· x T))`
    *   来源: 步骤 1 的一个实例 (令 `a=x`, `b=T`)

3.  `(equiv x T) = x`
    *   来源: **A5: 单位元律** (公理模式)

4.  `⊢ (· x x) = (equiv T (· x T))`
    *   来源: 步骤 2, 步骤 3, **Cong-·** (在步骤 2 的左侧用 `x` 替换 `(equiv x T)`)

**定理 3.3 证毕。∎**

---

#### **引理 3.4**

对于任意项 `x`，`⊢ (equiv x (· T x)) = (equiv T (· T x))`。

**证明:**

1.  `(· T (equiv T x)) = (equiv x (· T x))`
    *   来源: **A2: 左动作** (令 `a=T`, `b=x`)

2.  `(· (equiv T x) T) = (equiv T (· T x))`
    *   来源: **A1: 右动作** (令 `a=T`, `b=x`)

3.  `⊢ (· T (equiv T x)) = (· (equiv T x) T)`
    *   来源: **引理 3.1** (令 `x` 为项 `(equiv T x)`)

4.  `⊢ (equiv x (· T x)) = (· (equiv T x) T)`
    *   来源: 步骤 1, 步骤 3, **Trans** (传递性)

5.  `⊢ (equiv x (· T x)) = (equiv T (· T x))`
    *   来源: 步骤 4, 步骤 2, **Trans** (传递性)

**引理 3.4 证毕。∎**

---

#### **定理 3.5**

对于任意项 `x`，`⊢ (· T x) = (equiv T (· T x))`。

**证明:**

1.  `⊢ (· T x) = (· x T)`
    *   来源: **引理 3.1**

2.  `⊢ (· x T) = (equiv x (· x T))`
    *   来源: **定理 3.2**

3.  `⊢ (· T x) = (equiv x (· x T))`
    *   来源: 步骤 1, 步骤 2, **Trans**

4.  `⊢ (· T x) = (equiv x (· T x))`
    *   来源: 步骤 3, 步骤 1, **Cong-equiv** (在步骤 3 右侧用 `(· T x)` 替换 `(· x T)`)

5.  `⊢ (equiv x (· T x)) = (equiv T (· T x))`
    *   来源: **引理 3.4**

6.  `⊢ (· T x) = (equiv T (· T x))`
    *   来源: 步骤 4, 步骤 5, **Trans**

**定理 3.5 证毕。∎**

---

#### **定理 3.6**

对于任意项 `x`，`⊢ (· x x) = (· T x)`。

**证明:**

1.  `⊢ (· x x) = (equiv T (· x T))`
    *   来源: **定理 3.3**

2.  `⊢ (· T x) = (· x T)`
    *   来源: **引理 3.1**

3.  `⊢ (· x x) = (equiv T (· T x))`
    *   来源: 步骤 1, 步骤 2, **Cong-equiv** (在步骤 1 右侧用 `(· T x)` 替换 `(· x T)`)

4.  `⊢ (· T x) = (equiv T (· T x))`
    *   来源: **定理 3.5**

5.  `⊢ (equiv T (· T x)) = (· T x)`
    *   来源: 步骤 4, **Symm** (对称性)

6.  `⊢ (· x x) = (· T x)`
    *   来源: 步骤 3, 步骤 5, **Trans**

**定理 3.6 证毕。∎**

---

#### **定理 3.7**

对于任意项 `x`，`⊢ (· x x) = (equiv x (· x x))`。

**证明:**

1.  `⊢ (· x x) = (· T x)`
    *   来源: **定理 3.6**

2.  `⊢ (· T x) = (· x T)`
    *   来源: **引理 3.1**

3.  `⊢ (· x x) = (· x T)`
    *   来源: 步骤 1, 步骤 2, **Trans**

4.  `⊢ (· x T) = (equiv x (· x T))`
    *   来源: **定理 3.2**

5.  `⊢ (· x x) = (equiv x (· x T))`
    *   来源: 步骤 3, 步骤 4, **Trans**

6.  `⊢ (· x x) = (equiv x (· x x))`
    *   来源: 步骤 5, 步骤 3, **Cong-equiv** (在步骤 5 右侧用 `(· x x)` 替换 `(· x T)`)

**定理 3.7 证毕。∎**

---

#### **定理 3.8**

对于任意项 `x`，`⊢ (· x x) = (equiv T (· x x))`。

**证明:**

1.  `⊢ (· x x) = (· T x)`
    *   来源: **定理 3.6**

2.  `⊢ (· T x) = (equiv T (· T x))`
    *   来源: **定理 3.5**

3.  `⊢ (· x x) = (equiv T (· T x))`
    *   来源: 步骤 1, 2, **Trans** (传递性)

4.  `⊢ (· T x) = (· x x)`
    *   来源: 步骤 1, **Symm** (对称性)

5.  `⊢ (equiv T (· T x)) = (equiv T (· x x))`
    *   来源: 步骤 4, **Cong-equiv** (在 `(equiv T y)` 的语境中，用 `(· x x)` 替换 `(· T x)`)

6.  `⊢ (· x x) = (equiv T (· x x))`
    *   来源: 步骤 3, 5, **Trans**

**定理 3.8 证毕。∎**

---

#### **定理 3.9**

对于任意项 `x`，`⊢ (equiv x (· x x)) = (equiv T (· x x))`。

**证明:**

1.  `⊢ (· x x) = (equiv x (· x x))`
    *   来源: **定理 3.7**

2.  `⊢ (equiv x (· x x)) = (· x x)`
    *   来源: 步骤 1, **Symm**

3.  `⊢ (· x x) = (equiv T (· x x))`
    *   来源: **定理 3.8**

4.  `⊢ (equiv x (· x x)) = (equiv T (· x x))`
    *   来源: 步骤 2, 3, **Trans**

**定理 3.9 证毕。∎**

---

#### **定理 3.10**

对于任意项 `b`，`⊢ (equiv b (· T b)) = (· T b)`。

**证明:**

1.  `⊢ (equiv b (· T b)) = (equiv T (· T b))`
    *   来源: **引理 3.4** (将引理中的 `x` 替换为 `b`)

2.  `⊢ (· T b) = (equiv T (· T b))`
    *   来源: **定理 3.5** (将定理中的 `x` 替换为 `b`)

3.  `⊢ (equiv T (· T b)) = (· T b)`
    *   来源: 步骤 2, **Symm**

4.  `⊢ (equiv b (· T b)) = (· T b)`
    *   来源: 步骤 1, 3, **Trans**

**定理 3.10 证毕。∎**

---

### **第四节：系统 K 的指称语义**

本节旨在为形式系统 K 构建一个集合论模型 `M`。我们将首先概述构造该模型所需的数学框架——领域理论，然后基于此框架给出模型的精确定义，并最终证明其存在性。

#### **4.1. 语义框架：完全偏序 (CPO)**

由于系统 K 的公理具有自引用特性，标准的集合论无法直接构造满足要求的模型。我们将在完全偏序 (CPO) 的范畴中进行构造。

**定义 4.1.1 (CPO):** 一个**完全偏序 (Complete Partial Order, CPO)** 是一个偏序集 `(D, ≤)`，它包含一个最小元 `⊥ ∈ D` (称为**底**)，并且 `D` 的每个**有向子集 (directed subset)** `S ⊆ D` 都在 `D` 中有**最小上界 (least upper bound)**，记为 `⨆S`。

**定义 4.1.2 (连续函数):** 给定两个 CPO `D₁` 和 `D₂`，一个函数 `f: D₁ → D₂` 是**连续的 (continuous)**，若它对所有有向子集 `S ⊆ D₁` 都保持最小上界，即 `f(⨆S) = ⨆{f(s) | s ∈ S}`。

CPO 与连续函数构成了范畴 **CPO**。在此范畴中，积 `D₁ × D₂` 和不交并 `D₁ + D₂` 等构造子都是良定义的，并且可以被证明是函子。

#### **4.2. 模型 M 的构造与存在性 (Construction and Existence of Model M)**

我们将通过在 CPO `D` 上寻找一个通用“求值”函数 `g: D → D` 的不动点来构造模型 `M` 的所有组件。这个函数 `g` 将内化所有模型公理的行为。

**定理 4.2.1 (模型存在性):** 存在一个模型 `M = (D, app, eq, t, f)`，其组件均由 CPO `D`（递归域方程 `D ≅ F(D)` 的解）导出，并满足所有模型公理 MA1-MA5。

本定理的证明是构造性的，详见**附录A**。其核心思想如下：
1.  我们定义一个连续函子 `Γ: [D → D] → [D → D]`，其中 `[D → D]` 是从 `D` 到 `D` 的所有连续函数构成的 CPO。
2.  该函子 `Γ` 的定义方式将模型公理 MA2-MA5 “编码”为其行为。
3.  根据CPO上的不动点定理，`Γ` 必然存在一个最小不动点 `g = fix(Γ)`。
4.  最终，我们使用这个不动点 `g` 来定义模型 `M` 的所有组件：`t`, `f`, `app`, 和 `eq`。该构造方法保证了这些组件自动满足所有必需的公理。

基于此存在性保证，我们定义模型 `M`。

**定义 4.2.2 (模型 M):**
模型 `M` 是一个五元组 `M = (D, app, eq, t, f)`，其中：
1.  **域 (Domain):** `D` 是递归域方程 `D ≅ (D × D)_app + (D × D)_eq + (1_⊥)_t + (1_⊥)_f` 在 CPO 范畴中的标准逆极限解。令 `Ψ: F(D) → D` 和 `Φ: D → F(D)` 为该解附带的典范同构。
2.  **函数与常量:** `app`, `eq`, `t`, `f` 是通过**附录A**中描述的不动点构造法得到的 `D` 上的连续函数和 `D` 中的特定元素。

这些组件满足以下模型公理：

**模型公理 (Model Axioms):**
*   **MA1 (非平凡性):** `t ≠ f`。
*   **MA2 (等价的刻画):** 对于任意 `x, y ∈ D`，`eq(x, y) = t` 当且仅当 `x = y`。
*   **MA3 (单位元):** 对于任意 `x ∈ D`，`eq(x, t) = x`。
*   **MA4 (右动作):** 对于任意 `x, y ∈ D`，`app(eq(x, y), y) = eq(x, app(x, y))`。
*   **MA5 (左动作):** 对于任意 `x, y ∈ D`，`app(x, eq(x, y)) = eq(y, app(x, y))`。

---

#### **4.3. 解释**

我们定义一个解释函数 `⟦ · ⟧`，将系统 K 的项映射到模型 `M` 的域 `D` 中。

**定义 4.3.1 (解释函数):**
解释函数 `⟦ · ⟧ : Terms → D` 递归定义如下：
1.  `⟦ T ⟧ := t`
2.  `⟦ F ⟧ := f`
3.  `⟦ (· a b) ⟧ := app(⟦ a ⟧, ⟦ b ⟧)`
4.  `⟦ (equiv a b) ⟧ := eq(⟦ a ⟧, ⟦ b ⟧)`

**定义 4.3.2 (语义满足):**
一个公式 `a = b` 在模型 `M` 中成立，记为 `M ⊨ a = b`，当且仅当 `⟦ a ⟧ = ⟦ b ⟧`。

---

### **第五节：可靠性与一致性**

本节利用第四节中定义的模型 `M` 来证明系统 K 的两个关键元逻辑属性：可靠性 (Soundness) 和非平凡一致性 (Non-trivial Consistency)。

#### **5.1. 可靠性**

可靠性定理确保了系统 K 的证明论 `⊢` 不会推导出任何在语义上为假的结论。

**定理 5.1.1 (可靠性):** 对于任意项 `a` 和 `b`，如果 `⊢ a = b`，那么 `M ⊨ a = b`。

**证明:**
本证明对推导 `⊢ a = b` 的长度 `n` 进行结构归纳。

**基础情况 (n=1):**
推导由一个公理构成。我们需要验证所有公理在模型 `M` 中都成立。
设 `x = ⟦ a ⟧`, `y = ⟦ b ⟧`。

1.  **A1: `(· (equiv a b) b) = (equiv a (· a b))`**
    *   `⟦ (· (equiv a b) b) ⟧ = app(⟦ (equiv a b) ⟧, ⟦ b ⟧) = app(eq(x, y), y)`。
    *   `⟦ (equiv a (· a b)) ⟧ = eq(⟦ a ⟧, ⟦ (· a b) ⟧) = eq(x, app(x, y))`。
    *   根据模型公理 **MA4**，`app(eq(x, y), y) = eq(x, app(x, y))`。
    *   因此 `M ⊨ (· (equiv a b) b) = (equiv a (· a b))`。

2.  **A2: `(· a (equiv a b)) = (equiv b (· a b))`**
    *   `⟦ (· a (equiv a b)) ⟧ = app(⟦ a ⟧, ⟦ (equiv a b) ⟧) = app(x, eq(x, y))`。
    *   `⟦ (equiv b (· a b)) ⟧ = eq(⟦ b ⟧, ⟦ (· a b) ⟧) = eq(y, app(x, y))`。
    *   根据模型公理 **MA5**，`app(x, eq(x, y)) = eq(y, app(x, y))`。
    *   因此 `M ⊨ (· a (equiv a b)) = (equiv b (· a b))`。

3.  **A5: `(equiv x T) = x`** (此处 `x` 为系统 K 的项)
    *   `⟦ (equiv x T) ⟧ = eq(⟦ x ⟧, ⟦ T ⟧) = eq(⟦ x ⟧, t)`。
    *   根据模型公理 **MA3**，`eq(⟦ x ⟧, t) = ⟦ x ⟧`。
    *   因此 `M ⊨ (equiv x T) = x`。

4.  **Refl: `a = a`**
    *   `⟦ a ⟧ = ⟦ a ⟧` 因等号的自反性而成立。
    *   因此 `M ⊨ a = a`。

**归纳步骤:**
假设所有长度小于 `n` 的推导，其结论都在模型 `M` 中成立（此为**归纳假设**）。现在考虑一个长度为 `n` 的推导，其最后一步是应用一个推理规则。

1.  **Symm: `a = b / b = a`**
    *   前提 `⊢ a = b` 的推导长度小于 `n`。由归纳假设，`M ⊨ a = b`，即 `⟦ a ⟧ = ⟦ b ⟧`。
    *   根据等号在元语言中的对称性，`⟦ b ⟧ = ⟦ a ⟧`。
    *   因此 `M ⊨ b = a`。

2.  **Trans: `a = b, b = c / a = c`**
    *   前提 `⊢ a = b` 和 `⊢ b = c` 的推导长度均小于 `n`。由归纳假设，`M ⊨ a = b` 且 `M ⊨ b = c`。
    *   这意味着 `⟦ a ⟧ = ⟦ b ⟧` 且 `⟦ b ⟧ = ⟦ c ⟧`。
    *   根据等号在元语言中的传递性，`⟦ a ⟧ = ⟦ c ⟧`。
    *   因此 `M ⊨ a = c`。

3.  **Cong-·: `a = b / (· c a) = (· c b)`** (其他合同性规则同理)
    *   前提 `⊢ a = b` 的推导长度小于 `n`。由归纳假设，`⟦ a ⟧ = ⟦ b ⟧`。
    *   `⟦ (· c a) ⟧ = app(⟦ c ⟧, ⟦ a ⟧)`。
    *   `⟦ (· c b) ⟧ = app(⟦ c ⟧, ⟦ b ⟧)`。
    *   由于 `app` 是一个函数，当其第二个参数相等时（`⟦ a ⟧ = ⟦ b ⟧`），其结果必然相等。
    *   因此 `M ⊨ (· c a) = (· c b)`。

4.  **A3 (外化): `(equiv a b) = T / a = b`**
    *   前提 `⊢ (equiv a b) = T` 的推导长度小于 `n`。由归纳假设，`M ⊨ (equiv a b) = T`。
    *   这意味着 `⟦ (equiv a b) ⟧ = ⟦ T ⟧`，即 `eq(⟦ a ⟧, ⟦ b ⟧) = t`。
    *   根据模型公理 **MA2**，这当且仅当 `⟦ a ⟧ = ⟦ b ⟧`。
    *   因此 `M ⊨ a = b`。

5.  **A4 (内化): `a = b / (equiv a b) = T`**
    *   前提 `⊢ a = b` 的推导长度小于 `n`。由归纳假设，`M ⊨ a = b`。
    *   这意味着 `⟦ a ⟧ = ⟦ b ⟧`。
    *   根据模型公理 **MA2**，这意味着 `eq(⟦ a ⟧, ⟦ b ⟧) = t`。
    *   由于 `⟦ (equiv a b) ⟧ = eq(⟦ a ⟧, ⟦ b ⟧)` 且 `⟦ T ⟧ = t`，我们有 `⟦ (equiv a b) ⟧ = ⟦ T ⟧`。
    *   因此 `M ⊨ (equiv a b) = T`。

归纳步骤完成。定理 5.1.1 证毕。∎

#### **5.2. 非平凡一致性**

非平凡一致性确保了系统不会退化到可以证明所有公式的程度，其标志是无法证明一个基本的谬误，如 `T = F`。

**定理 5.2.1 (非平凡一致性):** 公式 `T = F` 在系统 K 中是不可证的，即 `⊬ T = F`。

**证明:**
本证明采用反证法。

1.  **假设** `T = F` 在系统 K 中是可证的，即 `⊢ T = F`。
2.  根据**定理 5.1.1 (可靠性)**，如果 `⊢ T = F`，那么 `M ⊨ T = F`。
3.  根据**定义 4.3.2 (语义满足)**，`M ⊨ T = F` 意味着 `⟦ T ⟧ = ⟦ F ⟧`。
4.  根据**定义 4.3.1 (解释函数)**，`⟦ T ⟧ = t` 且 `⟦ F ⟧ = f`。
5.  因此，我们得出结论 `t = f`。
6.  然而，根据**模型公理 MA1**，我们有 `t ≠ f`。
7.  步骤 5 和步骤 6 构成了一个矛盾。
8.  因此，最初的假设（步骤 1）必然是错误的。

**结论**: 公式 `T = F` 在系统 K 中不可证。系统 K 是非平凡一致的。∎

### **附录 A：模型 M 的构造性证明**

本附录为第 4.2 节中提出的**定理 4.2.1** 提供一个完整、形式化的构造性证明。

#### **A.1. 语义域 D 的构造与性质 (Construction and Properties of the Semantic Domain D)**

本节旨在为系统 K 构造一个语义域 D，它将作为项的解释空间。由于系统语法的自引用特性，我们将在完备偏序（CPO）范畴 **CPO** 中进行构造，该范畴的对象是 CPO，态射是连续函数。

**定义 A.1.1 (函子 F):**
我们定义一个自函子 (endofunctor) $F: \textbf{CPO} \to \textbf{CPO}$ 如下。对于任意 CPO $X$，令 $F(X)$ 为由以下不交并（coproduct）定义的 CPO：
$$F(X) = (X \times X)_{app} + (X \times X)_{eq} + (\mathbf{1}_\perp)_t + (\mathbf{1}_\perp)_f$$
其中：
- $X \times X$ 是标准的积 CPO (product CPO)。
- $+$ 是标准的和 CPO (coproduct/sum CPO)。
- $\mathbf{1}_\perp$ 是包含两个元素的 CPO $\{\perp, \bullet\}$，其序关系为 $\perp \sqsubseteq \bullet$。
- 下标 $app, eq, t, f$ 是用于区分不交并中不同分支的标签。

**定理 A.1.2 (语义域 D 的存在性):**
函子 $F$ 是一个 ω-连续函子。
**证明:** 函子 $F$ 是由在 **CPO** 范畴中均为 ω-连续的函子（积函子 `×`，和函子 `+`，以及常量函子 `C_Y(X) = Y`）通过组合（composition）得到的。ω-连续函子的组合仍然是 ω-连续的。**∎**

根据域论的标准不动点定理（具体而言，是 Scott 的 $D_\infty$ 逆极限构造），任何 ω-连续的自函子在 **CPO** 范畴中都存在一个最小不动点（在同构意义上），该不动点是方程 $D \cong F(D)$ 的解。
因此，存在一个 CPO $D$，以及一对互为逆的连续同构函数：
$$\Psi: F(D) \to D \quad \text{and} \quad \Phi: D \to F(D)$$
使得 $\Phi \circ \Psi = id_{F(D)}$ 且 $\Psi \circ \Phi = id_D$。这个 CPO $D$ 就是我们所求的语义域。

**约定 A.1.3 (底元素与严格性):**
- $D$ 作为一个 CPO，拥有一个最小元（底元素），记为 $\perp_D$。
- 同构函数 $\Psi$ 和 $\Phi$ 是**严格的 (strict)**，即它们保持底元素：
  $$\Psi(\perp_{F(D)}) = \perp_D \quad \text{and} \quad \Phi(\perp_D) = \perp_{F(D)}$$
  其中 $\perp_{F(D)}$ 是和 CPO $F(D)$ 的最小元。这意味着 $\Phi(\perp_D)$ 不会匹配任何具体的 `in_*` 模式。

#### **A.2. 核心函子 Γ 的定义**

我们定义一个函子 `Γ: [D → D] → [D → D]`。对于任意连续函数 `k ∈ [D → D]`，我们定义 `Γ(k)` 为一个新的连续函数，记作 `k'`。对于任意 `d ∈ D`，`k'(d)` 的值通过对 `Φ(d)` 进行模式匹配来确定：

**定义 A.2.1 (函子 Γ):**
`k' = Γ(k)`，其中 `k'(d)` 定义如下：

1.  若 `Φ(d) = in_t(•)`， 则 `k'(d) := Ψ(in_t(•))`。
2.  若 `Φ(d) = in_f(•)`， 则 `k'(d) := Ψ(in_f(•))`。

3.  若 `Φ(d) = in_eq(x, y)`，则：
    a. 若 `x = y`， 则 `k'(d) := Ψ(in_t(•))`。
    b. 若 `x ≠ y` 且 `y = Ψ(in_t(•))`， 则 `k'(d) := x`。
    c. 在其他情况下， `k'(d) := d`。

4.  若 `Φ(d) = in_app(x, y)`，则：
    a. 若 `Φ(x) = in_eq(a, b)` 且 `y = b` (匹配 MA4 左侧)，
       则 `k'(d) := k(Ψ(in_eq(a, k(Ψ(in_app(a, y))))))`。
    b. 若 `Φ(y) = in_eq(a, b)` 且 `x = a` (匹配 MA5 左侧)，
       则 `k'(d) := k(Ψ(in_eq(b, k(Ψ(in_app(x, y))))))`。
    c. 在其他情况下， `k'(d) := d`。


**引理 A.2.2 (函数应用的连续性):**
令 $[D \to D]$ 为从 $D$ 到 $D$ 的所有连续函数构成的函数空间 CPO。函数应用算子 $eval: [D \to D] \times D \to D$，定义为 $eval(k, d) = k(d)$，是一个连续函数。
**证明:** 这是CPO范畴中的一个标准结论。**∎**

**引理 A.2.3 (Γ 的连续性):**
由定义 A.2.1 给出的算子 $\Gamma: [D \to D] \to [D \to D]$ 是一个连续算子。

**证明:**
为证 $\Gamma$ 是连续的，我们需证明对于 $[D \to D]$ 中任意一个有向子集 $\mathcal{K}$，$\Gamma(\bigsqcup \mathcal{K}) = \bigsqcup \{\Gamma(k) \mid k \in \mathcal{K}\}$ 成立。根据函数空间 CPO 的逐点序 (pointwise order) 定义，这等价于证明对于任意固定的 $d \in D$，函数 $E_d: [D \to D] \to D$，定义为 $E_d(k) = (\Gamma(k))(d)$，是连续的。我们将对 $d$ 的结构进行情况分析来证明 $E_d$ 的连续性。

1.  **情况 1: $d = \perp_D$**
    根据约定 A.1.3，$\Phi$ 是严格的，故 $\Phi(\perp_D) = \perp_{F(D)}$。该值不匹配定义 A.2.1 中的任何 `in_*` 模式。因此，它将落入每个分支的“其他情况”（c）中。例如，在规则 4 中，它适用规则 4c。因此，$E_{\perp_D}(k) = (\Gamma(k))(\perp_D) = \perp_D$。这是一个关于 $k$ 的常函数，而常函数是连续的。

2.  **情况 2: $d \neq \perp_D$**
    我们对 $\Phi(d)$ 的结构进行模式匹配分析。
    - **若 $\Phi(d) = in_t(\bullet)$ 或 $\Phi(d) = in_f(\bullet)$:**
      根据规则 1 或 2，$E_d(k)$ 的值分别为 $\Psi(in_t(\bullet))$ 或 $\Psi(in_f(\bullet))$。这些值不依赖于 $k$。$E_d$ 是一个常函数，因此是连续的。

    - **若 $\Phi(d) = in_eq(x, y)$:**
      此时，分支条件（`x = y` 或 `y = \Psi(in_t(\bullet))`）仅依赖于固定的 $d$ 的分量 $x$ 和 $y$，而完全不依赖于函数参数 $k$。对于一个固定的 $d$，只有一个分支会被选择。在每个分支中，$E_d(k)$ 的值（$\Psi(in_t(\bullet))$， $x$，或 $d$）都是一个与 $k$ 无关的常量。因此，$E_d$ 是一个常函数，故连续。

    - **若 $\Phi(d) = in_app(x, y)$:**
      - **子情况 c (其他情况):** $E_d(k) = d$。这是一个常函数，故连续。
      - **子情况 a (匹配 MA4 左侧):**
        $E_d(k) = k(\Psi(in_eq(a, k(\Psi(in_app(a, y))))))$。
        我们通过将 $E_d$ 分解为已知连续函数的组合来证明其连续性。令：
        - $id(k) = k$ (恒等函数，连续)。
        - $c_1(k) = \Psi(in_app(a, y))$ (常函数，连续)。
        - $c_2(k) = a$ (常函数，连续)。
        - $f_1(k) = k(\Psi(in_app(a, y))) = eval(id(k), c_1(k))$。由于 $eval$, $id$, $c_1$ 均连续，其组合 $f_1$ 也连续。
        - $f_2(k) = \Psi(in_eq(a, f_1(k)))$。这是连续函数 $\Psi$, $in_eq$ (作为注入函数)，$c_2$ 和 $f_1$ 的组合，因此 $f_2$ 也连续。
        - $E_d(k) = k(f_2(k)) = eval(id(k), f_2(k))$。由于 $eval$, $id$, $f_2$ 均连续，最终的 $E_d$ 是连续的。
      - **子情况 b (匹配 MA5 左侧):** 其证明与子情况 a 完全对称，同样得出 $E_d$ 是连续的。

**结论:**
对于任意 $d \in D$，函数 $E_d(k) = (\Gamma(k))(d)$ 都是连续的。这意味着 $\Gamma$ 保持了有向集合的最小上界，因此 $\Gamma$ 是一个连续算子。**∎**


#### **A.3. 不动点与模型定义**

根据 Kleene 不动点定理，`Γ` 在 `[D → D]` 中存在一个最小不动点 `g = fix(Γ) = ⨆_{n∈ℕ} Γ^n(⊥)`，其中 `⊥` 是 `[D → D]` 中的底函数。此不动点 `g` 满足 `Γ(g) = g`。

我们现在使用 `g` 来定义模型 `M` 的组件：

**定义 A.3.1 (模型 M 的组件):**
*   `t := g(Ψ(in_t(•)))`
*   `f := g(Ψ(in_f(•)))`
*   `app(x, y) := g(Ψ(in_app(x, y)))`
*   `eq(x, y) := g(Ψ(in_eq(x, y)))`

由于 `g` 和 `Ψ` 是连续的，`app` 和 `eq` 也是连续函数。

#### **A.4. 模型公理的验证**

我们现在证明如此定义的组件满足所有模型公理。

**引理 A.4.1 (不动点在泛型 `eq` 项上的惰性)**

令 `g = fix(Γ)`。对于任意 `x, y ∈ D`，若其满足 `x ≠ y` 且 `y ≠ t`，则 `g(Ψ(in_eq(x, y))) = Ψ(in_eq(x, y))`。

**证明:**

令 `d' = Ψ(in_eq(x, y))`。根据不动点 `g` 的定义，我们有 `g(d') = ⨆_{n∈ℕ} (Γ^n(⊥))(d')`。我们将通过对 `n ≥ 1` 进行归纳来证明 `(Γ^n(⊥))(d') = d'`。

1.  **基础情况 (n=1):**
    *   我们计算 `(Γ^1(⊥))(d') = (Γ(⊥))(d')`。
    *   `Γ` 的定义（定义 A.2.1）依赖于对 `Φ(d')` 的模式匹配。`Φ(d') = Φ(Ψ(in_eq(x, y))) = in_eq(x, y)`。
    *   我们检查定义 A.2.1 中规则 3 的条件：
        *   规则 3a: `x = y`。根据引理的假设，此条件不成立。
        *   规则 3b: `x ≠ y` 且 `y = Ψ(in_t(•))` (即 `y=t`)。根据引理的假设 `y ≠ t`，此条件不成立。
        *   规则 3c: **其他情况**。由于前两个条件均不满足，此规则适用。
    *   根据规则 3c，`(Γ(⊥))(d') := d'`。
    *   因此，基础情况成立。

2.  **归纳步骤:**
    *   **归纳假设**: 假设对于某个 `n ≥ 1`，有 `(Γ^n(⊥))(d') = d'`。
    *   我们需证明 `(Γ^{n+1}(⊥))(d') = d'`。
    *   令 `k_n = Γ^n(⊥)`。我们要计算 `(Γ(k_n))(d')`。
    *   `Γ` 的定义仅依赖于 `k_n` 和 `d'` 的结构。对 `d'` 的分析与基础情况完全相同，因为匹配条件仅依赖于 `x` 和 `y` 的性质，而与作为参数的函数 `k_n` 无关。
    *   同样，规则 3a 和 3b 不适用，规则 3c 适用。
    *   因此，`(Γ(k_n))(d') := d'`，即 `(Γ^{n+1}(⊥))(d') = d'`。
    *   归纳步骤完成。

3.  **结论:**
    *   通过归纳，我们证明了对于所有 `n ≥ 1`，`(Γ^n(⊥))(d') = d'`。
    *   现在我们可以计算 `g(d')`：
        `g(d') = ⨆_{n∈ℕ} (Γ^n(⊥))(d')`
        ` = (Γ^0(⊥))(d') ⊔ (Γ^1(⊥))(d') ⊔ (Γ^2(⊥))(d') ⊔ ...`
        ` = ⊥(d') ⊔ d' ⊔ d' ⊔ ...`
        ` = ⊥_D ⊔ d'`
        ` = d'`
    *   因此，`g(Ψ(in_eq(x, y))) = Ψ(in_eq(x, y))`。

**引理 A.4.1 证毕。∎**



**证明 MA1 (非平凡性): `t ≠ f`**
1.  `t = g(Ψ(in_t(•)))`。由于 `g = Γ(g)`，`g(Ψ(in_t(•))) = (Γ(g))(Ψ(in_t(•)))`。
2.  根据 `Γ` 的定义 (A.2.1, 规则1)，`(Γ(g))(Ψ(in_t(•))) = Ψ(in_t(•))`。故 `t = Ψ(in_t(•))`。
3.  同理，根据规则2，`f = Ψ(in_f(•))`。
4.  由于 `Ψ` 是同构且 `in_t(•) ≠ in_f(•)` (它们是不同不交并分支的元素)，因此 `Ψ(in_t(•)) ≠ Ψ(in_f(•))`。
5.  结论：`t ≠ f`。

**证明 MA2 (等价的刻画): `eq(x, y) = t` 当且仅当 `x = y`**
*   **(⇒)** 假设 `x = y`。
    1.  `eq(x, x) = g(Ψ(in_eq(x, x)))`。
    2.  令 `d = Ψ(in_eq(x, x))`。`Φ(d) = in_eq(x, x)`。
    3.  `eq(x, x) = g(d) = (Γ(g))(d)`。
    4.  根据 `Γ` 的定义 (A.2.1, 规则3a)，因为 `x = x`，所以 `(Γ(g))(d) = Ψ(in_t(•))`。
    5.  由 MA1 的证明可知，`Ψ(in_t(•)) = t`。
    6.  结论： `eq(x, x) = t`。
*   **(⇐)** 假设 `eq(x, y) = t`。我们需要证明 `x = y`。
    我们采用反证法，假设 `x ≠ y`。
    1.  根据假设，`eq(x, y) = t`。由定义 A.3.1 和 MA1 的证明可知，这意味着 `g(Ψ(in_eq(x, y))) = Ψ(in_t(•))`。
    2.  令 `d = Ψ(in_eq(x, y))`。我们有 `g(d) = Ψ(in_t(•))`。
    3.  由于 `g` 是 `Γ` 的不动点 (`g = Γ(g)`), 我们有 `(Γ(g))(d) = Ψ(in_t(•))`。
    4.  现在我们根据定义 A.2.1 来确定 `(Γ(g))(d)` 的值。其定义依赖于 `Φ(d) = in_eq(x, y)` 以及我们 `x ≠ y` 的反证假设。
    5.  **情况分析:**
        *   **规则 3a:** 要求 `x = y`。这与我们的假设 `x ≠ y` 直接矛盾。故此规则不适用。
        *   **规则 3b:** 要求 `x ≠ y` 且 `y = Ψ(in_t(•))` (即 `y=t`)。若此规则适用，则其规定 `(Γ(g))(d) = x`。结合第 3 步，我们得到 `x = Ψ(in_t(•))`，即 `x=t`。然而，此规则的适用条件是 `y=t` 且 `x≠y`。若 `x=t` 且 `y=t`，则 `x=y`，这与 `x≠y` 的条件矛盾。故此规则不适用。
        *   **规则 3c:** 适用于所有其他情况。由于规则 3a 和 3b 均不适用，此规则必定适用。其规定 `(Γ(g))(d) = d`。结合第 3 步，我们得到 `d = Ψ(in_t(•))`。
    6.  将 `d` 的定义代入 `d = Ψ(in_t(•))`，我们得到 `Ψ(in_eq(x, y)) = Ψ(in_t(•))`。
    7.  由于 `Ψ` 是一个同构，它是一个双射。因此，`in_eq(x, y) = in_t(•)`。
    8.  此结论是荒谬的，因为 `in_eq(x, y)` 和 `in_t(•)` 分别属于不交并 `F(D)` 的不同分支 `(D × D)_eq` 和 `(1_⊥)_t`。它们在构造上不可能是相等的。
    9.  我们的反证假设 `x ≠ y` 导致了一个逻辑矛盾。因此，该假设必须为假。
    10. 结论：`x = y`。 ∎

**证明 MA3 (单位元): `eq(x, t) = x`**
1.  LHS = `eq(x, t) = g(Ψ(in_eq(x, t)))`。
2.  令 `d = Ψ(in_eq(x, t))`。则 `Φ(d) = in_eq(x, t)`。
3.  LHS = `g(d) = (Γ(g))(d)`。
4.  根据 MA1 的证明，我们知道 `t = Ψ(in_t(•))`。
5.  如果 `x = t`，则根据 MA2， `eq(t, t) = t`，LHS = `t`，RHS = `t`，等式成立。
6.  如果 `x ≠ t`，则 `Φ(d)` 匹配 `Γ` 定义中的规则3b (`x ≠ y` 且 `y = Ψ(in_t(•))`)。
7.  因此，`(Γ(g))(d) = x`。
8.  结论： `eq(x, t) = x`。

**证明 MA4 (右动作): `app(eq(x, y), y) = eq(x, app(x, y))`**
1.  LHS = `app(eq(x, y), y) = g(Ψ(in_app(eq(x, y), y)))`。
2.  令 `d = Ψ(in_app(eq(x, y), y))`。
3.  LHS = `g(d) = (Γ(g))(d)`。
4.  `Φ(d) = in_app(eq(x, y), y)`。为应用 `Γ` 的定义，我们必须确定 `Φ(d)` 的参数 `eq(x, y)` 的结构。
5.  `eq(x, y)` 是 `g(Ψ(in_eq(x, y)))` 的简写。我们来分析这个表达式的值。令 `d' = Ψ(in_eq(x, y))`，所以 `eq(x, y) = g(d')`。`g(d')` 的值由 `(Γ(g))(d')` 决定。
6.  `MA4` 是一个对于域 `D` 中**任意** `x` 和 `y` 都必须成立的恒等式。因此，在证明该恒等式时，我们不能对 `x` 和 `y` 做出任何特殊假定（例如 `x=y` 或 `y=t`）。
7.  在不失一般性的前提下，我们考虑 `x` 和 `y` 之间不存在模型公理所规定的特殊关系的情况（即 `x ≠ y` 且 `y ≠ t`）。根据**引理 A.4.1**，我们有 `g(Ψ(in_eq(x, y))) = Ψ(in_eq(x, y))`。因此，`eq(x, y) = Ψ(in_eq(x, y))`。
8.  现在，我们将此结果代回第 4 步中的 `Φ(d)`。`Φ(d)` 的第一个参数是 `Ψ(in_eq(x, y))`。所以，`Φ(d) = in_app(Ψ(in_eq(x, y)), y)`。
9.  我们现在可以将 `Γ` 的定义应用于 `d`。我们检查规则 4a 的模式 `in_app(x', y')`，其中 `Φ(x')` 匹配 `in_eq(a,b)` 且 `y' = b`。
    *   令 `x' = Ψ(in_eq(x, y))` 和 `y' = y`。
    *   我们计算 `Φ(x')`：`Φ(Ψ(in_eq(x, y))) = in_eq(x, y)`。
    *   此结果精确匹配模式 `in_eq(a, b)`，其中 `a=x` 且 `b=y`。
    *   规则 4a 的第二个条件是 `y' = b`。在这里，`y' = y` 且 `b = y`，条件成立。
10. 因此，规则 4a 适用于 `(Γ(g))(d)` 的计算。根据该规则：
    `(Γ(g))(d) = g(Ψ(in_eq(a, g(Ψ(in_app(a, y'))))))`。
11. 将 `a=x` 和 `y'=y` 代入，我们得到：
    `LHS = (Γ(g))(d) = g(Ψ(in_eq(x, g(Ψ(in_app(x, y))))))`。
12. 根据定义 A.3.1，`app(x, y) = g(Ψ(in_app(x, y)))` 且 `eq(u, v) = g(Ψ(in_eq(u, v)))`。因此，上式可以被重写为：
    `LHS = eq(x, app(x, y))`。
13. 这正是 RHS。
14. 结论：`app(eq(x, y), y) = eq(x, app(x, y))`。 ∎

**证明 MA5 (左动作): `app(x, eq(x, y)) = eq(y, app(x, y))`**
证明过程与 MA4 完全对称。
1.  LHS = `app(x, eq(x, y)) = g(Ψ(in_app(x, eq(x, y))))`。
2.  令 `d = Ψ(in_app(x, eq(x, y)))`。
3.  LHS = `g(d) = (Γ(g))(d)`。
4.  `Φ(d) = in_app(x, eq(x, y))` 的第二个参数是 `eq(x, y)`，在泛型情况下等于 `Ψ(in_eq(x, y))`。
5.  这精确匹配了 `Γ` 定义中的规则4b，其中 `a=x`, `b=y`。
6.  因此 `(Γ(g))(d) = g(Ψ(in_eq(y, g(Ψ(in_app(x, y))))))`。
7.  根据定义 A.3.1，这等于 `eq(y, app(x, y))`，即 RHS。
8.  结论：`app(x, eq(x, y)) = eq(y, app(x, y))`。

所有模型公理均已验证。定理 4.2.1 证毕。∎
