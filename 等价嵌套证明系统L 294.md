# **等价嵌套证明系统L**

### **1. 语法 (Syntax)**

**1.1. 函数 (Functions)**

*   `·`：一个二元函数，表示**应用**。记为 `(· a b)`。
*   `equiv`：一个二元函数，表示**等价**。记为 `(equiv a b)`。

**1.2. 常量 (Constants)**

*   `T`：一个零元函数（原子项），代表**已证实的等价性**或**真理**。
*   `F`：一个零元函数（原子项）。

**1.3. 项 (Terms)**

项的集合由以下规则递归定义：
1.  `T` 是项。
2.  `F` 是项。
3.  若 `a` 和 `b` 是项，则 `(· a b)` 是项。
4.  若 `a` 和 `b` 是项，则 `(equiv a b)` 是项。

**1.4. 公式 (Formulas)**

公式的集合如下构成：
1. 若 `a` 和 `b` 是项，则  `a = b`是公式。
### **2. 证明论** 

对于任意项 `a`, `b`, `c`, `d`, `f`, `x`：

**核心交互公理模式**

*   **A1: 右动作 (Right Action)**
    `(· (equiv a b) b) = (equiv a (· a b))`

*   **A2: 单位元律**
	`(equiv x T) = x`


**外化规则**

*    **A3: 外化规则**
```
	若 ⊢ (equiv a b) = T
	-------------------- (A3)
	则 ⊢ a = b
```

*   **A4: 内化规则**
```
	若 ⊢ a = b
	-------------------- (A4)
	则 ⊢ (equiv a b) = T
```

**背景等式逻辑 (Background Equational Logic)**
证明关系 `⊢` 被假定在一个标准的等式逻辑框架内，该框架确保了 ` = ` 作为一个全等关系 (congruence relation)。这意味着以下结构性规则对于任何推导都有效：
**公理模式：**
*   `Refl: a = a`
**推理规则：**
*   `Symm: a = b / b = a` (若 `⊢ a = b` 则 `⊢ b = a`)
*   `Trans: a = b, b = c / a = c`
*   `Cong-·: a = b / (· a c) = (· b c)` and `a = b / (· c a) = (· c b)`
*   `Cong-equiv: a = b / (equiv a c) = (equiv b c)` and `a = b / (equiv c a) = (equiv c b)`

#### **2.1 替换引理 (Substitution Lemma)**

**引理 2.1 (替换引理 - Substitution Lemma)**

若 `⊢ (equiv a b) = T`，则对于任何一元项语境 (unary term context) `C[·]`，我们有 `⊢ (equiv C[a] C[b]) = T`。

*语境 `C[·]` 指一个带“空位”的项，例如 `(· x [·])` 或 `(equiv T (· a [·]))`。`C[a]` 表示将空位填上项 `a`。*

**证明：**

本引理的证明采用对语境 `C[·]` 的结构进行归纳的方法。

**1. 预备步骤：外化假设**
   1. `⊢ (equiv a b) = T`  (引理的假设)
   2. `⊢ a = b`  (根据步骤 1 和 **A3: 外化规则**)

   现在我们的目标是证明，在 `⊢ a = b` 的前提下，对于任何语境 `C[·]`，都有 `⊢ C[a] = C[b]`。一旦证明了这一点，我们就可以通过 **A4: 内化规则** 得到最终结论 `⊢ (equiv C[a] C[b]) = T`。

**2. 归纳基础 (Base Case)**
   当语境 `C[·]` 是最简单的语境，即 `C[·] = [·]` (空语境) 时：
   1. `C[a]` 等同于 `a`。
   2. `C[b]` 等同于 `b`。
   3. 我们需要证明 `⊢ a = b`。
   4. 这在 **预备步骤** 的第 2 步已经得出。
   5. 因此，基础情况成立。

**3. 归纳步骤 (Inductive Step)**
   假设对于语境 `C'[·]` 和 `C''[·]`，该属性成立。即，若 `⊢ a = b`，则 `⊢ C'[a] = C'[b]` 且 `⊢ C''[a] = C''[b]` (此为**归纳假设**)。
   我们必须证明对于由这些语境构造的更复杂的语境，该属性也成立。项的构造规则有两种 (`·` 和 `equiv`)，因此我们有四种情况需要考虑：

   **情况 (i):** `C[·] = (· C'[·] d)`，其中 `d` 是任意项。
   1. `C[a] = (· C'[a] d)`。
   2. `C[b] = (· C'[b] d)`。
   3. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   4. 根据背景等式逻辑的**合同性规则 (Cong-·)** `x = y / (· x z) = (· y z)`，将此规则应用于 `C'[a] = C'[b]`，可得：
      `⊢ (· C'[a] d) = (· C'[b] d)`。
   5. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (ii):** `C[·] = (· d C'[·])`，其中 `d` 是任意项。
   6. `C[a] = (· d C'[a])`。
   7. `C[b] = (· d C'[b])`。
   8. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   9. 根据背景等式逻辑的**合同性规则 (Cong-·)** `x = y / (· z x) = (· z y)`，可得：
      `⊢ (· d C'[a]) = (· d C'[b])`。
   10. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (iii):** `C[·] = (equiv C'[·] d)`，其中 `d` 是任意项。
   11. `C[a] = (equiv C'[a] d)`。
   12. `C[b] = (equiv C'[b] d)`。
   13. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   14. 根据背景等式逻辑的**合同性规则 (Cong-equiv)** `x = y / (equiv x z) = (equiv y z)`，可得：
      `⊢ (equiv C'[a] d) = (equiv C'[b] d)`。
   15. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (iv):** `C[·] = (equiv d C'[·])`，其中 `d` 是任意项。
   16. `C[a] = (equiv d C'[a])`。
   17. `C[b] = (equiv d C'[b])`。
   18. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   19. 根据背景等式逻辑的**合同性规则 (Cong-equiv)** `x = y / (equiv z x) = (equiv z y)`，可得：
      `⊢ (equiv d C'[a]) = (equiv d C'[b])`。
   20. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

**4. 结论**
   通过对 `C[·]` 的结构归纳，我们证明了若 `⊢ a = b`，则对于任意语境 `C[·]`，`⊢ C[a] = C[b]` 恒成立。

   1. `⊢ C[a] = C[b]` (如上所示)
   2. `⊢ (equiv C[a] C[b]) = T` (根据步骤 1 和 **A4: 内化规则**)

引理 2.1 证毕。∎

### **3. 语义学 (Semantics)**

本节为形式系统 **L** 定义一个代数模型，并基于此模型证明其可靠性与非平凡一致性。

#### **3.1 代数模型 M**

我们定义一个代数模型 **M**，它由一个语义域 `D` 和一个解释函数 `llbracket · rrbracket` 组成。

**定义 3.1.1 (语义域)**
模型的语义域 `D` 是整数模 3 的环 `ℤ₃`，即 `D = {0, 1, 2}`，其上定义有标准的模 3 加法 `+` 和乘法 `·`。

**定义 3.1.2 (解释函数)**
解释函数 `llbracket · rrbracket : Terms → ℤ₃` 将系统 **L** 中的项映射到 `ℤ₃` 中的元素，定义如下：

1.  **常量解释:**
    *   `llbracket T rrbracket = 0`
    *   `llbracket F rrbracket = 1`

2.  **函数解释:**
    对于任意项 `a`, `b`，令 `x = llbracket a rrbracket` 且 `y = llbracket b rrbracket`：
    *   `llbracket (· a b) rrbracket = (2x + y) mod 3`
    *   `llbracket (equiv a b) rrbracket = (x - y) mod 3`

**定义 3.1.3 (语义有效性)**
一个公式 `a = b` 在模型 **M** 中是有效的（记为 `M ⊨ a = b`），当且仅当 `llbracket a rrbracket = llbracket b rrbracket` 在 `ℤ₃` 中成立。

#### **3.2 可靠性 (Soundness)**

**定理 3.2.1 (可靠性定理)**
对于系统 **L** 中的任意项 `a`, `b`，若 `⊢ a = b`，则 `M ⊨ a = b`。

**证明:**
本证明通过对推导 `⊢ a = b` 的结构进行归纳。我们只需证明所有公理在模型 **M** 中均有效，并且所有推理规则都能保持有效性。

**1. 公理模式的有效性**

令 `a, b` 为任意项，并令 `x = llbracket a rrbracket`, `y = llbracket b rrbracket`。

*   **A1: `(· (equiv a b) b) = (equiv a (· a b))`**
    *   左侧 (LHS) 解释:
        `llbracket (· (equiv a b) b) rrbracket = (2 · llbracket(equiv a b)rrbracket + llbracket b rrbracket) mod 3`
        ` = (2(x - y) + y) mod 3`
        ` = (2x - 2y + y) mod 3`
        ` = (2x - y) mod 3`
    *   右侧 (RHS) 解释:
        `llbracket (equiv a (· a b)) rrbracket = (llbracket a rrbracket - llbracket(· a b)rrbracket) mod 3`
        ` = (x - (2x + y)) mod 3`
        ` = (x - 2x - y) mod 3`
        ` = (-x - y) mod 3`
    *   由于在 `ℤ₃` 中 `2 ≡ -1`，故 `2x ≡ -x`。因此 `(2x - y) ≡ (-x - y) mod 3`。
    *   LHS = RHS，故 `M ⊨ (· (equiv a b) b) = (equiv a (· a b))`。

*   **A2: `(equiv a T) = a`**
    *   左侧 (LHS) 解释:
        `llbracket (equiv a T) rrbracket = (llbracket a rrbracket - llbracket T rrbracket) mod 3`
        ` = (x - 0) mod 3 = x`
    *   右侧 (RHS) 解释:
        `llbracket a rrbracket = x`
    *   LHS = RHS，故 `M ⊨ (equiv a T) = a`。

*   **Refl: `a = a`**
    *   `llbracket a rrbracket = x` 且 `llbracket a rrbracket = x`。
    *   `x = x` 显然成立，故 `M ⊨ a = a`。

**2. 推理规则的有效性保持**

*   **A3 (外化规则): `(equiv a b) = T / a = b`**
    *   假设前提有效: `M ⊨ (equiv a b) = T`。
    *   根据定义 3.1.3，这意味着 `llbracket (equiv a b) rrbracket = llbracket T rrbracket`。
    *   即 `(x - y) mod 3 = 0`。
    *   这蕴含 `x = y` 在 `ℤ₃` 中成立。
    *   根据定义 3.1.3，`x = y` 意味着 `M ⊨ a = b`。
    *   因此，该规则保持有效性。

*   **A4 (内化规则): `a = b / (equiv a b) = T`**
    *   假设前提有效: `M ⊨ a = b`。
    *   这意味着 `llbracket a rrbracket = llbracket b rrbracket`，即 `x = y`。
    *   这蕴含 `(x - y) mod 3 = 0`。
    *   `llbracket (equiv a b) rrbracket = (x - y) mod 3 = 0`。
    *   `llbracket T rrbracket = 0`。
    *   因此 `llbracket (equiv a b) rrbracket = llbracket T rrbracket`，即 `M ⊨ (equiv a b) = T`。
    *   因此，该规则保持有效性。

*   **Symm: `a = b / b = a`**
    *   假设 `M ⊨ a = b`，即 `x = y`。
    *   `y = x` 显然成立，故 `M ⊨ b = a`。

*   **Trans: `a = b, b = c / a = c`**
    *   假设 `M ⊨ a = b` 且 `M ⊨ b = c`，即 `x = y` 且 `y = z`。
    *   `x = z` 显然成立，故 `M ⊨ a = c`。

*   **Cong-·: `a = b / (· a c) = (· b c)`**
    *   假设 `M ⊨ a = b`，即 `x = y`。
    *   `llbracket (· a c) rrbracket = (2x + z) mod 3`。
    *   `llbracket (· b c) rrbracket = (2y + z) mod 3`。
    *   由于 `x = y`，故 `2x + z = 2y + z`。因此 `M ⊨ (· a c) = (· b c)`。
    *   `a = b / (· c a) = (· c b)` 的情况同理可证。

*   **Cong-equiv: `a = b / (equiv a c) = (equiv b c)`**
    *   假设 `M ⊨ a = b`，即 `x = y`。
    *   `llbracket (equiv a c) rrbracket = (x - z) mod 3`。
    *   `llbracket (equiv b c) rrbracket = (y - z) mod 3`。
    *   由于 `x = y`，故 `x - z = y - z`。因此 `M ⊨ (equiv a c) = (equiv b c)`。
    *   `a = b / (equiv c a) = (equiv c b)` 的情况同理可证。

由于所有公理在模型 **M** 中均有效，且所有推理规则都能保持有效性，因此通过对推导长度的归纳，任何可证的等式 `a = b` 在模型 **M** 中都有效。

证毕。∎

#### **3.3 非平凡一致性 (Non-trivial Consistency)**

**定理 3.3.1 (非平凡一致性定理)**
系统 **L** 是非平凡一致的。

**证明:**

一个系统是一致的，如果它不能证明一个矛盾，例如 `T = F`。

1.  **证明一致性:**
    *   采用反证法。假设系统 **L** 不一致，即 `⊢ T = F`。
    *   根据定理 3.2.1 (可靠性定理)，如果 `⊢ T = F`，那么 `M ⊨ T = F`。
    *   根据定义 3.1.3，`M ⊨ T = F` 意味着 `llbracket T rrbracket = llbracket F rrbracket`。
    *   根据定义 3.1.2，这意味着 `0 = 1` 在 `ℤ₃` 中成立。
    *   这是一个矛盾。
    *   因此，初始假设 `⊢ T = F` 必定为假。
    *   结论：`⊬ T = F`，故系统 **L** 是一致的。

2.  **证明非平凡性:**
    *   在模型 **M** 中，`T` 和 `F` 被解释为不同的元素（`0` 和 `1`）。
    *   由于系统是一致的，它不能证明 `T = F`，这意味着至少存在两个在理论上不等价的项。
    *   因此，系统 **L** 是非平凡的。

结合以上两点，系统 **L** 是非平凡一致的。

证毕。∎