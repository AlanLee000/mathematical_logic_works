## **原群等价逻辑 (Magmatic Equivalance Logic, MEL): 形式化规范**

## **第 1 节 语法 (Syntax)**

**定义 1.1 (字母表)**
系统的字母表 $\Sigma$ 由以下不相交的集合构成：

1.  一个可数的**变量符号集** $\mathcal{V} = \{x, y, z, ...\}$。
2.  一个包含两个**常量符号**的集合 $\mathcal{C} = \{T, \bot\}$。
3.  一个包含二元**组合构造子**的集合 $\{\cdot\}$。
4.  一个包含二元**等价构造子**的集合 $\{\text{equiv}\}$。
5.  一个包含一元**引用构造子**的集合 $\{\text{Quote\}}$。   
6.  辅助符号 `(`, `)`。

**定义 1.2 (项)**
项的集合 $\mathcal{T}$ 是满足以下条件的最小集合：

1.  **原子项**: 若 $v \in \mathcal{V}$ 或 $c \in \mathcal{C}$，则 $v$ 和 $c$ 都是项。
2.  **复合项**: 若 $t_1, t_2 \in \mathcal{T}$，则以下表达式也是项：
    *   `(· t₁ t₂)`  (组合项)
    *   `(equiv t₁ t₂)` (等价项)
    *    `(Quote t₁)` (引用项)

*我们使用S-表达式风格的前缀表示法。*

**定义 1.3 (判断)**
系统中唯一的一种判断形式是**可证等价判断**，其形式为 `t₁ ≡ t₂`，其中 $t_1, t_2 \in \mathcal{T}$。

---

## **第 2 节 证明论 (Proof Theory)**

### 2.1 规则集合

一个判断 `t₁ ≡ t₂` 是可证的（记为 `⊢ t₁ ≡ t₂`），当且仅当它可以从以下公理模式和推理规则推导得出。

#### **A. 结构与同余规则 (Structural and Congruence Rules)**

这些规则确保 `≡` 是一个同余关系。

*   **(Reflexivity)**: $\dfrac{}{\vdash t \equiv t}$
*   **(Symmetry)**: $\dfrac{\vdash t_1 \equiv t_2}{\vdash t_2 \equiv t_1}$
*   **(Transitivity)**: $\dfrac{\vdash t_1 \equiv t_2 \quad \vdash t_2 \equiv t_3}{\vdash t_1 \equiv t_3}$
*   **(Congruence)**: $\dfrac{\vdash t_1 \equiv s_1 \quad \vdash t_2 \equiv s_2}{\vdash (· \ t_1 \ t_2) \equiv (· \ s_1 \ s_2) \qquad \vdash (Quote\ t_1 ) \equiv (Quote \ s_1) \qquad \vdash (\text{equiv } t_1 \ t_2) \equiv (\text{equiv } s_1 \ s_2)}$

#### **B. 计算与数据公理 (Axioms of Computation and Data)**

*   **公理 B1 (真即计算 / Truth as Computation):**
    ```
    ⊢ (· t T) ≡ t
    ```
    *释义：常量 `T` 作为组合运算 `·` 的右单位元。将其应用于任何项 `t`，都会“执行”一个保持 `t` 不变的计算。*
*   **公理 B2 (求值规则)**:
    ```
    若 ⊢ t₁ ≡ (Quote t₂)
    --------------------
    则 ⊢ (· T t₁) ≡ t₂
    ```

#### **C. 引用与矛盾公理 (Axioms of Quotation and Contradiction)**

*   **公理 C1 (矛盾的引用 / Quote of Contradiction):**
    ```
    ⊢ (Quote ⊥) ≡ ⊥
    ```
    *释义：对矛盾 `⊥` 的引用操作，其结果仍然是矛盾 `⊥` 本身。这直接形式化了思想 3：“矛盾的引用还是矛盾”。*

*   **公理 C2 (忠实引用 / Faithful Quotation):**
    ```
    ⊢ (· (Quote t) t) ≡ T
    ```
    *释义：将一个项 `t` 的引用 `(Quote t)` 应用于 `t` 本身，这个行为在系统内被断言为真 `T`。

*   **规则 C3 (爆炸规则 / Rule of Explosion):**
	```
	若 ⊢ t ≡ T
	----------- (C3-Rule)
	则 ⊢ (· ⊥ t) ≡ ⊥
	```
    *释义：矛盾范式具有“污染性”，任何与之通过 `·` 运算结合的真的项都会坍缩为矛盾本身。*

#### **D. 原群等价公理 (Axioms of Magmatic Equivalence)**

*   **公理 D1 (等价之解引用):**
    ```
    ⊢ (· (equiv a b) a) ≡ b
    ```

*   **公理 D2 (等价之组合性):**
    ```
    ⊢ (· (equiv a b) (equiv c d)) ≡ (equiv (· a c) (· b d))
    ```

#### **E. 内化与外化规则 (Internalization and Externalization Rules)**

这组规则在元语言层面的可证等价判断 `⊢` 和对象语言层面的证明项 `(equiv ...)` 与真值 `T` 之间的关系上建立了一座关键的桥梁。它们确保了内部的证明代数与外部的证明论是忠实对应、互为镜像的。

*   **规则 E1 (内化 / Reflection)**:
    ```
    若 ⊢ t₁ ≡ t₂
    ----------- (E1-Rule)
    则 ⊢ (equiv t₁ t₂) ≡ T
    ```
    *   **释义**: 此规则将外部的可证性“内化”到系统中。它断言：如果在元语言层面我们可以构造一个从 `t₁` 到 `t₂` 的证明，那么在对象语言层面，代表该证明路径的项 `(equiv t₁ t₂)` 本身就等价于真值 `T`。换言之，一个有效的外部证明对应于一个内部被断定为“真”的证明对象。

*   **规则 E2 (外化 / Reification)**:
    ```
    若 ⊢ (equiv t₁ t₂) ≡ T
    ----------- (E2-Rule)
    则 ⊢ t₁ ≡ t₂
    ```
    *   **释义**: 此规则将内部的真值断言“外化”为外部的可证性。它确保了内部证明代数的可靠性：如果一个代表证明路径的项在系统内部被证明等价于 `T`，那么这条路径所连接的两个项 `t₁` 和 `t₂` 确实是（在外部）可证等价的。这防止了系统内部产生“虚假”的证明。


### **2.2 替换引理 (Substitution Lemma)**

**引理 2.2 (替换引理)**
如果 `⊢ t₁ ≡ t₂`，那么对于任意变量 $x_1, ..., x_n$ 和任意项 $s_1, ..., s_n$，令 $\sigma$ 为替换 $[s_1/x_1, ..., s_n/x_n]$，则 `⊢ t₁σ ≡ t₂σ` 也是可证的。

**证明**:
我们对 `⊢ t₁ ≡ t₂` 的证明推导的长度（或结构）进行归纳。

**1. 基础情况 (Base Case): 证明长度为 1**
此时，`t₁ ≡ t₂` 必然是一个公理的实例。我们必须表明，对任何公理应用替换 `σ`，其结果仍然是一个可证的判断（通常是该公理的另一个实例）。

*   **公理模式 A (结构与同余)**:
    *   **(Reflexivity)**: `t ≡ t`。应用 `σ` 得到 `tσ ≡ tσ`，这本身就是自反性公理的一个实例，因此是可证的。
*   **公理模式 B, C, D**:
    这些公理都是模式（schemata），其中包含元变量（例如 `t`, `a`, `b`）。将一个具体的公理实例 `P ≡ Q` 进行替换 `σ`，相当于将构成该实例的项进行替换。其结果 `Pσ ≡ Qσ` 仍然是同一个公理模式的一个（可能更复杂的）实例。
    *   例如，考虑 **公理 B1**: `(· t T) ≡ t`。一个实例可能是 `(· x T) ≡ x`。应用替换 `σ = [s/x]` 得到 `(· s T) ≡ s`，这仍然是公理 B1 的一个有效实例。
    *   例如，考虑 **公理 D1**: `(· (equiv a b) a) ≡ b`。一个实例可能是 `(· (equiv x y) x) ≡ y`。应用替换 `σ = [s₁/x, s₂/y]` 得到 `(· (equiv s₁ s₂) s₁) ≡ s₂`，这仍然是公理 D1 的一个有效实例。
    所有其他公理模式 (B2 的公理部分, C1, C2, D2) 都遵循相同的逻辑。

**2. 归纳步骤 (Inductive Step): 证明长度大于 1**
此时，`⊢ t₁ ≡ t₂` 是通过一个推理规则从一个或多个前提推导出来的。我们假设替换引理对所有前提都成立（归纳假设），并证明它对结论也成立。

*   **(Symmetry)**:
    $\dfrac{\vdash P \equiv Q}{\vdash Q \equiv P}$
    归纳假设 `⊢ Pσ ≡ Qσ` 是可证的。对其应用 (Symmetry) 规则，我们直接得到 `⊢ Qσ ≡ Pσ`，而 `Qσ ≡ Pσ` 正是 `(Q ≡ P)σ`。引理成立。

*   **(Transitivity)**:
    $\dfrac{\vdash P \equiv Q \quad \vdash Q \equiv R}{\vdash P \equiv R}$
    归纳假设 `⊢ Pσ ≡ Qσ` 和 `⊢ Qσ ≡ Rσ` 是可证的。对其应用 (Transitivity) 规则，我们直接得到 `⊢ Pσ ≡ Rσ`，即 `(P ≡ R)σ`。引理成立。

*   **(Congruence)**:
    $\dfrac{\vdash P_1 \equiv Q_1 \quad \vdash P_2 \equiv Q_2}{\vdash (· \ P_1 \ P_2) \equiv (· \ Q_1 \ Q_2)}$
    归纳假设 `⊢ P₁σ ≡ Q₁σ` 和 `⊢ P₂σ ≡ Q₂σ` 是可证的。对其应用 (Congruence) 规则，我们得到 `⊢ (· P₁σ P₂σ) ≡ (· Q₁σ Q₂σ)`。根据替换的定义，`(· P₁σ P₂σ)` 就是 `(· P₁ P₂)σ`，`(· Q₁σ Q₂σ)` 就是 `(· Q₁ Q₂)σ`。因此结论 `⊢ (· P₁ P₂)σ ≡ (· Q₁ Q₂)σ` 成立。对于 `equiv` 和 `Quote` 构造子，论证完全相同。

*   **规则 B2, C3, E1, E2**:
    这些规则具有 `若 ⊢ 前提, 则 ⊢ 结论` 的形式。
    以 **规则 E1 (内化)** 为例: $\dfrac{\vdash P \equiv Q}{\vdash (\text{equiv } P \ Q) \equiv \top}$
    归纳假设 `⊢ Pσ ≡ Qσ` 是可证的。将 E1 规则应用于这个新的可证前提，我们推导出 `⊢ (equiv Pσ Qσ) ≡ T`。由于 `T` 是常量，`Tσ = T`。而 `(equiv Pσ Qσ)` 等于 `(equiv P Q)σ`。因此，我们得到了 `⊢ ((equiv P Q) ≡ T)σ`。引理对该规则成立。
    所有其他类似形式的规则都遵循完全相同的推理模式。

由于替换引理对所有公理（基础情况）和所有推理规则（归纳步骤）都成立，我们通过对证明推导的结构归纳，得出结论：替换引理对 MEL 系统中所有可证的判断都成立。

**Q.E.D. (∎)**

---

## **第 3 节 语义与一致性 (Semantics and Consistency)**

本节旨在为原群等价逻辑（MEL）提供一个形式化的指称语义模型，并基于此模型证明系统的可靠性（Soundness）与一致性（Consistency）。

### **3.1 指称语义 (Denotational Semantics)**

我们构建一个具体的数学模型 M，为 MEL 的语法结构赋予明确的语义解释。

**定义 3.1 (语义模型 M)**
模型 M 由一个论域 $D$ 和一组解释函数构成：

1.  **论域 (Domain)**: $D = \{\mathbf{T}, \mathbf{F}\}$。其中 $\mathbf{T}$ 和 $\mathbf{F}$ 是两个不同的形式对象，分别代表“真”与“假”。

2.  **常量解释 (Interpretation of Constants)**:
    *   $I(\top) = \mathbf{T}$
    *   $I(\bot) = \mathbf{F}$

3.  **构造子解释 (Interpretation of Constructors)**:
    MEL 的构造子 `·`, `equiv`, `Quote` 被解释为定义在论域 $D$ 上的三个确定性函数 `app`, `eq`, `quote`。
    *   **组合函数 `app`: $D \times D \to D$**
        *   `app(x, y)` 定义为：若 $x = \mathbf{T}$，则结果为 $y$；若 $x = \mathbf{F}$，则结果为 $\neg y$ (其中 $\neg\mathbf{T}=\mathbf{F}, \neg\mathbf{F}=\mathbf{T}$)。
        *   真值表:
            | `app` | $\mathbf{T}$ | $\mathbf{F}$ |
            | :---: | :---: | :---: |
            | $\mathbf{T}$ | $\mathbf{T}$ | $\mathbf{F}$ |
            | $\mathbf{F}$ | $\mathbf{F}$ | $\mathbf{T}$ |

    *   **等价函数 `eq`: $D \times D \to D$**
        *   `eq(x, y)` 定义为：若 $x = y$，则结果为 $\mathbf{T}$；若 $x \neq y$，则结果为 $\mathbf{F}$。
        *   真值表:
            | `eq` | $\mathbf{T}$ | $\mathbf{F}$ |
            | :--: | :--: | :--: |
            | $\mathbf{T}$ | $\mathbf{T}$ | $\mathbf{F}$ |
            | $\mathbf{F}$ | $\mathbf{F}$ | $\mathbf{T}$ |

    *   **引用函数 `quote`: $D \to D$**
        *   `quote(x)` 定义为恒等函数：`quote(x) = x`。

**定义 3.2 (赋值与解释函数)**
1.  **赋值 (Valuation)**: 一个赋值 $v$ 是一个从变量符号集 $\mathcal{V}$ 到论域 $D$ 的函数，即 $v: \mathcal{V} \to D$。
2.  **解释函数 (Interpretation Function)**: 对于任意给定的赋值 $v$，解释函数 $I_v: \mathcal{T} \to D$ 将任意项 $t \in \mathcal{T}$ 映射到论域 $D$ 中的一个值。其定义如下：
    *   $I_v(c) = I(c)$，其中 $c \in \{T, \bot\}$
    *   $I_v(x) = v(x)$，其中 $x \in \mathcal{V}$
    *   $I_v((· \ t_1 \ t_2)) = \text{app}(I_v(t_1), I_v(t_2))$
    *   $I_v((\text{equiv } t_1 \ t_2)) = \text{eq}(I_v(t_1), I_v(t_2))$
    *   $I_v((\text{Quote } t_1)) = \text{quote}(I_v(t_1))$

**定义 3.3 (语义有效性)**
一个判断 $t_1 \equiv t_2$ 在模型 M 中是**有效的 (valid)**，记为 $M \vDash t_1 \equiv t_2$，当且仅当对于任意赋值 $v: \mathcal{V} \to D$，都有 $I_v(t_1) = I_v(t_2)$。

### **3.2 可靠性定理 (Soundness Theorem)**

可靠性定理断言，在 MEL 中任何可证的判断在其语义模型 M 中都是有效的。

**定理 3.1 (可靠性)**
若 $\vdash t_1 \equiv t_2$，则 $M \vDash t_1 \equiv t_2$。

**证明**:
我们通过对 MEL 证明推导的结构进行归纳来证明此定理。我们需要证明所有公理在模型 M 中都是有效的，并且所有推理规则都保持有效性。对于任意赋值 $v$，我们将证明等式成立。

**A. 结构与同余规则**
*   **(Reflexivity)**: $I_v(t) = I_v(t)$，由等号的自反性保证。
*   **(Symmetry)**: 归纳假设 $M \vDash t_1 \equiv t_2$，即 $I_v(t_1) = I_v(t_2)$。则 $I_v(t_2) = I_v(t_1)$ 成立，故 $M \vDash t_2 \equiv t_1$。
*   **(Transitivity)**: 归纳假设 $M \vDash t_1 \equiv t_2$ 且 $M \vDash t_2 \equiv t_3$，即 $I_v(t_1) = I_v(t_2)$ 且 $I_v(t_2) = I_v(t_3)$。则 $I_v(t_1) = I_v(t_3)$ 成立，故 $M \vDash t_1 \equiv t_3$。
*   **(Congruence)**: 归纳假设 $M \vDash t_1 \equiv s_1$ 且 $M \vDash t_2 \equiv s_2$，即 $I_v(t_1) = I_v(s_1)$ 且 $I_v(t_2) = I_v(s_2)$。
    *   $I_v((· \ t_1 \ t_2)) = \text{app}(I_v(t_1), I_v(t_2)) = \text{app}(I_v(s_1), I_v(s_2)) = I_v((· \ s_1 \ s_2))$。
    *   $I_v((\text{equiv } t_1 \ t_2)) = \text{eq}(I_v(t_1), I_v(t_2)) = \text{eq}(I_v(s_1), I_v(s_2)) = I_v((\text{equiv } s_1 \ s_2))$。
    *   $I_v((\text{Quote } t_1)) = \text{quote}(I_v(t_1)) = \text{quote}(I_v(s_1)) = I_v((\text{Quote } s_1))$。
    规则保持有效性。

**B. 计算与数据公理**
*   **公理 B1**: $\vdash (· \ t \ \top) \equiv t$
    $I_v((· \ t \ \top)) = \text{app}(I_v(t), I_v(\top)) = \text{app}(I_v(t), \mathbf{T})$。根据 `app` 的定义，此表达式等于 $I_v(t)$。公理有效。
*   **规则 B2**: 若 $\vdash t_1 \equiv (\text{Quote } t_2)$，则 $\vdash (· \ \top \ t_1) \equiv t_2$
    归纳假设 $M \vDash t_1 \equiv (\text{Quote } t_2)$，即 $I_v(t_1) = I_v((\text{Quote } t_2)) = \text{quote}(I_v(t_2)) = I_v(t_2)$。
    我们需要证明 $I_v((· \ \top \ t_1)) = I_v(t_2)$。
    $I_v((· \ \top \ t_1)) = \text{app}(I_v(\top), I_v(t_1)) = \text{app}(\mathbf{T}, I_v(t_1))$。根据 `app` 定义，此表达式等于 $I_v(t_1)$。
    由归纳假设知 $I_v(t_1) = I_v(t_2)$，故规则保持有效性。

**C. 引用与矛盾公理**
*   **公理 C1**: $\vdash (\text{Quote } \bot) \equiv \bot$
    $I_v((\text{Quote } \bot)) = \text{quote}(I_v(\bot)) = \text{quote}(\mathbf{F}) = \mathbf{F} = I_v(\bot)$。公理有效。
*   **公理 C2**: $\vdash (· \ (\text{Quote } t) \ t) \equiv \top$
    $I_v((· \ (\text{Quote } t) \ t)) = \text{app}(I_v((\text{Quote } t)), I_v(t)) = \text{app}(\text{quote}(I_v(t)), I_v(t)) = \text{app}(I_v(t), I_v(t))$。
    *   若 $I_v(t) = \mathbf{T}$，结果为 $\text{app}(\mathbf{T}, \mathbf{T}) = \mathbf{T}$。
    *   若 $I_v(t) = \mathbf{F}$，结果为 $\text{app}(\mathbf{F}, \mathbf{F}) = \mathbf{T}$。
    在所有情况下结果均为 $\mathbf{T} = I_v(\top)$。公理有效。
*   **规则 C3**: 若 $\vdash t \equiv \top$，则 $\vdash (· \ \bot \ t) \equiv \bot$
    归纳假设 $M \vDash t \equiv \top$，即 $I_v(t) = I_v(\top) = \mathbf{T}$。
    $I_v((· \ \bot \ t)) = \text{app}(I_v(\bot), I_v(t)) = \text{app}(\mathbf{F}, \mathbf{T}) = \mathbf{F} = I_v(\bot)$。规则保持有效性。

**D. 原群证明公理**
*   **公理 D1**: $\vdash (· \ (\text{equiv } a \ b) \ a) \equiv b$
    令 $x = I_v(a), y = I_v(b)$。我们需要证明 $\text{app}(\text{eq}(x, y), x) = y$。
    *   情况 1: $x = y$。此时 $\text{eq}(x, y) = \mathbf{T}$。LHS = $\text{app}(\mathbf{T}, x) = x$。由于 $x=y$，故 LHS=RHS。
    *   情况 2: $x \neq y$。此时 $\text{eq}(x, y) = \mathbf{F}$。LHS = $\text{app}(\mathbf{F}, x) = \neg x$。由于 $x \neq y$，故 $\neg x = y$。故 LHS=RHS。
    公理在所有情况下均有效。
*   **公理 D2**: $\vdash (· \ (\text{equiv } a \ b) \ (\text{equiv } c \ d)) \equiv (\text{equiv } (· \ a \ c) \ (· \ b \ d))$
    令 $v_a=I_v(a), v_b=I_v(b), v_c=I_v(c), v_d=I_v(d)$。需证 $\text{app}(\text{eq}(v_a, v_b), \text{eq}(v_c, v_d)) = \text{eq}(\text{app}(v_a, v_c), \text{app}(v_b, v_d))$。
    我们通过对所有16种真值组合的详尽检查，可以验证该等式恒成立。公理有效。

| 案例     |  a  |  b  |  c  |  d  | `eq(a,b)` | `eq(c,d)` | **LHS** `app(..)`  |   `app(a,c)`   |   `app(b,d)`   | **RHS** `eq(..)`  | 验证  |
| :----- | :-: | :-: | :-: | :-: | :-------: | :-------: | :----------------: | :------------: | :------------: | :---------------: | :-: |
| **1**  |  F  |  F  |  F  |  F  |     T     |     T     | `app(T,T)` = **T** | `app(F,F)` = T | `app(F,F)` = T | `eq(T,T)` = **T** |  ✓  |
| **2**  |  F  |  F  |  F  |  T  |     T     |     F     | `app(T,F)` = **F** | `app(F,F)` = T | `app(F,T)` = F | `eq(T,F)` = **F** |  ✓  |
| **3**  |  F  |  F  |  T  |  F  |     T     |     F     | `app(T,F)` = **F** | `app(F,T)` = F | `app(F,F)` = T | `eq(F,T)` = **F** |  ✓  |
| **4**  |  F  |  F  |  T  |  T  |     T     |     T     | `app(T,T)` = **T** | `app(F,T)` = F | `app(F,T)` = F | `eq(F,F)` = **T** |  ✓  |
| **5**  |  F  |  T  |  F  |  F  |     F     |     T     | `app(F,T)` = **F** | `app(F,F)` = T | `app(T,F)` = F | `eq(T,F)` = **F** |  ✓  |
| **6**  |  F  |  T  |  F  |  T  |     F     |     F     | `app(F,F)` = **T** | `app(F,F)` = T | `app(T,T)` = T | `eq(T,T)` = **T** |  ✓  |
| **7 ** |  F  |  T  |  T  |  F  |     F     |     F     | `app(F,F)` = **T** | `app(F,T)` = F | `app(T,F)` = F | `eq(F,F)` = **T** |  ✓  |
| **8**  |  F  |  T  |  T  |  T  |     F     |     T     | `app(F,T)` = **F** | `app(F,T)` = F | `app(T,T)` = T | `eq(F,T)` = **F** |  ✓  |
| **9**  |  T  |  F  |  F  |  F  |     F     |     T     | `app(F,T)` = **F** | `app(T,F)` = F | `app(F,F)` = T | `eq(F,T)` = **F** |  ✓  |
| **10** |  T  |  F  |  F  |  T  |     F     |     F     | `app(F,F)` = **T** | `app(T,F)` = F | `app(F,T)` = F | `eq(F,F)` = **T** |  ✓  |
| **11** |  T  |  F  |  T  |  F  |     F     |     F     | `app(F,F)` = **T** | `app(T,T)` = T | `app(F,F)` = T | `eq(T,T)` = **T** |  ✓  |
| **12** |  T  |  F  |  T  |  T  |     F     |     T     | `app(F,T)` = **F** | `app(T,T)` = T | `app(F,T)` = F | `eq(T,F)` = **F** |  ✓  |
| **13** |  T  |  T  |  F  |  F  |     T     |     T     | `app(T,T)` = **T** | `app(T,F)` = F | `app(T,F)` = F | `eq(F,F)` = **T** |  ✓  |
| **14** |  T  |  T  |  F  |  T  |     T     |     F     | `app(T,F)` = **F** | `app(T,F)` = F | `app(T,T)` = T | `eq(F,T)` = **F** |  ✓  |
| **15** |  T  |  T  |  T  |  F  |     T     |     F     | `app(T,F)` = **F** | `app(T,T)` = T | `app(T,F)` = F | `eq(T,F)` = **F** |  ✓  |
| **16** |  T  |  T  |  T  |  T  |     T     |     T     | `app(T,T)` = **T** | `app(T,T)` = T | `app(T,T)` = T | `eq(T,T)` = **T** |  ✓  |

**E. 内化与外化规则**
*   **规则 E1 (内化)**: 若 $\vdash t_1 \equiv t_2$，则 $\vdash (\text{equiv } t_1 \ t_2) \equiv \top$
    归纳假设 $M \vDash t_1 \equiv t_2$，即 $I_v(t_1) = I_v(t_2)$。
    $I_v((\text{equiv } t_1 \ t_2)) = \text{eq}(I_v(t_1), I_v(t_2))$。由于两个参数相等，根据 `eq` 的定义，结果为 $\mathbf{T} = I_v(\top)$。规则保持有效性。
*   **规则 E2 (外化)**: 若 $\vdash (\text{equiv } t_1 \ t_2) \equiv \top$，则 $\vdash t_1 \equiv t_2$
    归纳假设 $M \vDash (\text{equiv } t_1 \ t_2) \equiv \top$，即 $I_v((\text{equiv } t_1 \ t_2)) = I_v(\top) = \mathbf{T}$。
    这意味着 $\text{eq}(I_v(t_1), I_v(t_2)) = \mathbf{T}$。根据 `eq` 的定义，这当且仅当 $I_v(t_1) = I_v(t_2)$。
    因此 $M \vDash t_1 \equiv t_2$ 成立。规则保持有效性。

由于所有公理均有效，且所有推理规则均保持有效性，我们通过归纳法得出，任何在 MEL 中可证的判断 `⊢ t₁ ≡ t₂`，在模型 M 中都是有效的，即 $M \vDash t_1 \equiv t_2$。
**Q.E.D.**

### **3.3 一致性证明 (Consistency Proof)**

一个形式系统是一致的，如果它不能证明一个矛盾。在 MEL 中，这意味着判断 `⊢ T ≡ ⊥` 是不可证的。

**定理 3.2 (一致性)**
原群等价逻辑 (MEL) 是一个一致的系统。

**证明**:
我们采用反证法。

1.  **假设**: 假设 MEL 是不一致的。根据定义，这意味着存在一个证明，其结论为 `⊢ T ≡ ⊥`。

2.  **应用可靠性定理**: 根据我们刚刚证明的可靠性定理 (定理 3.1)，如果一个判断在 MEL 中是可证的，那么它在模型 M 中必须是有效的。因此，从 `⊢ T ≡ ⊥` 可推出 $M \vDash \top \equiv \bot$。

3.  **分析语义后果**: 根据语义有效性的定义 (定义 3.3)，$M \vDash \top \equiv \bot$ 意味着对于任意赋值 $v$，都有 $I_v(\top) = I_v(\bot)$。由于 $\top$ 和 $\bot$ 是常量，它们的解释不依赖于赋值 $v$。所以，这直接意味着 $I(\top) = I(\bot)$。

4.  **导出矛盾**: 根据我们对模型 M 的构造 (定义 3.1)，我们明确地将常量解释为 $I(\top) = \mathbf{T}$ 和 $I(\bot) = \mathbf{F}$。我们的论域 $D$ 包含两个**不同**的对象 $\mathbf{T}$ 和 $\mathbf{F}$。因此，在我们的模型中，$I(\top) \neq I(\bot)$。

5.  **结论**: 第 (3) 步得出的结论 ($I(\top) = I(\bot)$) 与第 (4) 步中我们模型的既定事实 ($I(\top) \neq I(\bot)$) 直接矛盾。因此，我们在第 (1) 步的初始假设（MEL 是不一致的）必须是错误的。

故，原群等价逻辑 (MEL) 是一致的。
**Q.E.D. (∎)**


## 第 4 节 非平凡语义

### **定义 4.1 (项模型的论域)**
项模型 $M_T$ 的论域 $D_T$ 是所有项的集合 $\mathcal{T}$ 关于可证等价关系 `≡` 的商集 (Quotient Set)。
$$ D_T = \mathcal{T} / \equiv \ = \{[t] \mid t \in \mathcal{T}\} $$
其中，$[t]$ 是项 $t$ 的等价类，定义为 $[t] = \{s \in \mathcal{T} \mid \vdash t \equiv s\}$。
论域中的元素不再是抽象的 $\mathbf{T}$ 和 $\mathbf{F}$，而是项的等价类本身，例如 `[T]`, `[⊥]`, `[(· x T)]` 等。

### **定义 4.2 (项模型中的解释)**
我们在论域 $D_T$ 上定义常量和构造子的解释。

1.  **常量解释**:
    *   $I_T(\top) = [\top]$
    *   $I_T(\bot) = [\bot]$

2.  **构造子解释 (操作定义)**:
    这些操作必须在等价类上是**良定义的 (well-defined)**。这意味着运算的结果不应依赖于我们选择等价类中的哪个代表元。
    *   **组合 `app_T`**: $D_T \times D_T \to D_T$
        `app_T([t₁], [t₂]) = [(· t₁ t₂)]`
    *   **等价 `eq_T`**: $D_T \times D_T \to D_T$
        `eq_T([t₁], [t₂]) = [(equiv t₁ t₂)]`
    *   **引用 `quote_T`**: $D_T \to D_T$
        `quote_T([t₁]) = [(Quote t₁)]`

#### **证明 4.2.1：`app_T` 的良定义性**

**1. 前提 (Premises)**:
假设我们有两个输入等价类，它们可以用不同的代表元表示：
*   $[t_1] = [s_1]$
*   $[t_2] = [s_2]$

**2. 解释前提**:
根据等价类 $[t]$ 的定义，上述前提等价于：
*   (P1) $\vdash t_1 \equiv s_1$
*   (P2) $\vdash t_2 \equiv s_2$

**3. 待证结论 (Conclusion to Prove)**:
我们需要证明 `app_T([t_1], [t_2])` 等于 `app_T([s_1], [s_2])`。
*   根据 `app_T` 的定义，`app_T([t_1], [t_2]) = [(· t₁ t₂)]`。
*   根据 `app_T` 的定义，`app_T([s_1], [s_2]) = [(· s₁ s₂)]`。
*   因此，我们需要证明 $[(· t₁ t₂)] = [(· s₁ s₂)]$，这等价于证明：
    **`⊢ (· t₁ t₂) equiv (· s₁ s₂)`**

**4. 推导过程 (Derivation)**:
我们拥有前提 (P1) 和 (P2)。现在我们检视 MEL 的证明规则。**规则 A (Congruence)** 中明确规定：
$$ \dfrac{\vdash t_1 \equiv s_1 \quad \vdash t_2 \equiv s_2}{\vdash (· \ t_1 \ t_2) \equiv (· \ s_1 \ s_2) \qquad \dots} $$
将我们的前提 (P1) `⊢ t₁ ≡ s₁` 和 (P2) `⊢ t₂ ≡ s₂` 直接代入此规则，我们立即可以推导出 `⊢ (· t₁ t₂) ≡ (· s₁ s₂)`。

**5. 结论**:
我们已经证明了待证结论。因此，`app_T` 的定义不依赖于代表元的选择，它是良定义的。

#### **证明 4.2.2：`eq_T` 和 `quote_T` 的良定义性**

这两个证明的结构与 `app_T` 完全相同，只是引用了 (Congruence) 规则的不同部分。

**对于 `eq_T`**:
*   **前提**: $\vdash t_1 \equiv s_1$ 和 $\vdash t_2 \equiv s_2$。
*   **待证**: `⊢ (equiv t₁ t₂) ≡ (equiv s₁ s₂)`。
*   **推导**: (Congruence) 规则提供了 $\dfrac{\vdash t_1 \equiv s_1 \quad \vdash t_2 \equiv s_2}{\dots \qquad \vdash (\text{equiv } t_1 \ t_2) \equiv (\text{equiv } s_1 \ s_2)}$。该推导是直接的。
*   **结论**: `eq_T` 是良定义的。

**对于 `quote_T`**:
*   **前提**: $\vdash t_1 \equiv s_1$。（`quote_T` 是一元操作，所以只需要一个前提）。
*   **待证**: `⊢ (Quote t₁) ≡ (Quote s₁)`。
*   **推导**: (Congruence) 规则同样提供了 $\dfrac{\vdash t_1 \equiv s_1 \quad \vdash t_2 \equiv s_2}{\dots \qquad \vdash (Quote\ t_1 ) \equiv (Quote \ s_1) \qquad \dots}$。（注意：虽然规则写了两个前提，但对于一元构造子，我们只需要应用第一个前提）。
*   **结论**: `quote_T` 是良定义的。

**良定义性总结**: MEL 系统中的 (Congruence) 规则是专门为了确保 `≡` 是一个同余关系而设计的。这个性质正是构建项模型（一个商代数结构）并使其上的操作良定义的**充要条件**。


### **定义 4.3 (项模型中的有效性)**
一个判断 $t_1 \equiv t_2$ 在项模型 $M_T$ 中有效，记为 $M_T \vDash t_1 \equiv t_2$，当且仅当在 $M_T$ 中的解释相等。对于不含变量的项，这意味着 $I_T(t_1) = I_T(t_2)$，即 $[t_1] = [t_2]$。根据等价类的定义，这等价于 `⊢ t₁ ≡ t₂`。

### **定理 4.4 (规范模型定理 / Canonical Model Theorem)**
MEL 系统在其项模型 $M_T$ 中是可靠的（Sound）。
$$ \text{若 } \vdash t_1 \equiv t_2, \text{ 则 } M_T \vDash t_1 \equiv t_2 $$
**证明**:

#### **定义 4.4.1 (项模型中的赋值与解释)**
1.  **赋值 (Valuation)**: 一个赋值 $v_T$ 是一个从变量集 $\mathcal{V}$ 到论域 $D_T$ 的函数，即 $v_T: \mathcal{V} \to D_T$。
2.  **解释函数 (Interpretation Function)**: 对于给定的赋值 $v_T$，解释函数 $I_{v_T}: \mathcal{T} \to D_T$ 递归定义如下：
    *   $I_{v_T}(c) = [c]$，对于常量 $c \in \{T, \bot\}$。
    *   $I_{v_T}(x) = v_T(x)$，对于变量 $x \in \mathcal{V}$。
    *   $I_{v_T}((· \ t_1 \ t_2)) = \text{app}_T(I_{v_T}(t_1), I_{v_T}(t_2))$。
    *   $I_{v_T}((\text{equiv } t_1 \ t_2)) = \text{eq}_T(I_{v_T}(t_1), I_{v_T}(t_2))$。
    *   $I_{v_T}((\text{Quote } t_1)) = \text{quote}_T(I_{v_T}(t_1))$。

#### **定义 4.4.2 (项模型中的语义有效性)**
一个判断 `t₁ ≡ t₂` 在模型 $M_T$ 中是**有效的**，记为 $M_T \vDash t_1 \equiv t_2$，当且仅当对于**任意**赋值 $v_T: \mathcal{V} \to D_T$，都有 $I_{v_T}(t_1) = I_{v_T}(t_2)$。

#### **引理 4.4.3**:
令 $t$ 是一个项，其自由变量都在 $\{x_1, ..., x_n\}$ 中。令 $v_T$ 是一个赋值，使得 $v_T(x_i) = [s_i]$ 对于 $i=1, ..., n$。令 $t[s_1/x_1, ..., s_n/x_n]$ 表示将项 $t$ 中的每个自由变量 $x_i$ 同时替换为项 $s_i$ 后得到的新项。则有：
$$ I_{v_T}(t) = [t[s_1/x_1, ..., s_n/x_n]] $$

**引理证明 (通过对项 $t$ 的结构归纳法)**:
1.  **基础情况 (Base Cases)**:
    *   **t 是常量 c**: $I_{v_T}(c) = [c]$。同时，$c[s_i/x_i]$ 仍然是 $c$。所以 $I_{v_T}(c) = [c]$。成立。
    *   **t 是变量 $x_j$**: $I_{v_T}(x_j) = v_T(x_j) = [s_j]$。同时，$x_j[s_i/x_i]$ 就是 $s_j$。所以 $I_{v_T}(x_j) = [s_j]$。成立。

2.  **归纳步骤 (Inductive Step)**:
    假设引理对项 $t_1$ 和 $t_2$ 成立，即 $I_{v_T}(t_1) = [t_1[s_i/x_i]]$ 和 $I_{v_T}(t_2) = [t_2[s_i/x_i]]$。我们需要证明它对复合项也成立。
	*   **t 是 `(· t₁ t₂)`**:
	    $I_{v_T}((· \ t_1 \ t_2))$
	    $= \text{app}_T(I_{v_T}(t_1), I_{v_T}(t_2))$  *(根据 $I_{v_T}$ 的定义)*
	    $= \text{app}_T([t_1[s_i/x_i]], [t_2[s_i/x_i]])$  *(根据归纳假设)*
	    $= [(· \ t_1[s_i/x_i] \ t_2[s_i/x_i])]$  *(根据 `app_T` 的定义)*
	    $= [((· \ t_1 \ t_2))[s_i/x_i]]$  *(根据替换的定义)*
	    引理对组合项成立。
	*   **t 是 `(equiv t₁ t₂)`**:
	    $I_{v_T}((\text{equiv } t_1 \ t_2))$
	    $= \text{eq}_T(I_{v_T}(t_1), I_{v_T}(t_2))$  *(根据 $I_{v_T}$ 的定义)*
	    $= \text{eq}_T([t_1[s_i/x_i]], [t_2[s_i/x_i]])$  *(根据归纳假设)*
	    $= [(\text{equiv } t_1[s_i/x_i] \ t_2[s_i/x_i])]$  *(根据 `eq_T` 的定义)*
	    $= [((\text{equiv } t_1 \ t_2))[s_i/x_i]]$  *(根据替换的定义)*
	    引理对等价项成立。
	*   **t 是 `(Quote t₁)`**:
	    $I_{v_T}((\text{Quote } t_1))$
	    $= \text{quote}_T(I_{v_T}(t_1))$  *(根据 $I_{v_T}$ 的定义)*
	    $= \text{quote}_T([t_1[s_i/x_i]])$  *(根据归纳假设)*
	    $= [(\text{Quote } t_1[s_i/x_i])]$  *(根据 `quote_T` 的定义)*
	    $= [((\text{Quote } t_1))[s_i/x_i]]$  *(根据替换的定义)*
	    引理对引用项成立。

引理 2.1 证毕。它告诉我们，在项模型中对一个项进行语义解释，等价于在句法层面进行替换然后取其等价类。

#### **可靠性定理的主证明**

**1. 前提 (Premise)**:
假设我们有一个可证的判断 `⊢ t₁ ≡ t₂`。

**2. 待证结论 (Conclusion to Prove)**:
我们需要证明 $M_T \vDash t_1 \equiv t_2$。根据定义，这意味着对于**任意**赋值 $v_T$，我们都必须证明 $I_{v_T}(t_1) = I_{v_T}(t_2)$。

**3. 推导过程 (Derivation)**:
*   (A) 选择一个任意的赋值 $v_T: \mathcal{V} \to D_T$。设 $t_1, t_2$ 中的自由变量为 $\{x_1, ..., x_n\}$。根据 $v_T$ 的定义，对于每个 $x_j$，存在一个项 $s_j$ 使得 $v_T(x_j) = [s_j]$。

*   (B) 我们从前提 `⊢ t₁ ≡ t₂` 开始。这是关于项模式的陈述，它对项中的任何自由变量都成立。在等式逻辑中，一个基本的（通常是元）定理是**替换引理 (Substitution Lemma)**：如果一个等价关系是可证的，那么将等式两边的自由变量统一替换为任意项，得到的等价关系仍然是可证的。
    因此，从 `⊢ t₁ ≡ t₂`，我们可以推断出：
    `⊢ t₁[s₁/x₁, ..., sₙ/xₙ] ≡ t₂[s₁/x₁, ..., sₙ/xₙ]`

*   (C) 根据项模型论域 $D_T$ 中等价类的定义，(B) 中的可证等价关系意味着这两个新项属于同一个等价类：
    `[t₁[s₁/x₁, ..., sₙ/xₙ]] = [t₂[s₁/x₁, ..., sₙ/xₙ]]`

*   (D) 现在，我们应用**引理 2.1**。
    *   对于 $t_1$：$I_{v_T}(t_1) = [t₁[s₁/x₁, ..., sₙ/xₙ]]$
    *   对于 $t_2$：$I_{v_T}(t_2) = [t₂[s₁/x₁, ..., sₙ/xₙ]]$

*   (E) 结合 (C) 和 (D)，我们直接得出：
    $I_{v_T}(t_1) = I_{v_T}(t_2)$

*   (F) 由于我们在步骤 (A) 中选择的赋值 $v_T$ 是**任意**的，并且我们证明了结论 (E) 对它成立，所以我们已经满足了语义有效性的定义。

**4. 结论**:
我们已经证明了 $M_T \vDash t_1 \equiv t_2$。因此，可靠性定理成立。

**Q.E.D. (∎)**

---

### **4.5 建立两个模型间的同态映射**

现在我们有了两个模型：
1.  **原始二元模型 $M$**: 论域 $D = \{\mathbf{T}, \mathbf{F}\}$。
2.  **忠实项模型 $M_T$**: 论域 $D_T = \mathcal{T} / \equiv$。

我们将定义一个从 $M_T$ 到 $M$ 的**同态映射 (Homomorphism)** `h`，它保持模型的代数结构。

**定义 4.5.1 (同态映射 h)**
定义映射 $h: D_T \to D$ 如下。首先，我们选取一个任意的、固定的**规范赋值 (canonical valuation)** $v_0: \mathcal{V} \to D$，例如，将所有变量都映射到 $\mathbf{T}$ 的赋值。然后，我们定义：
$$ h([t]) = I_{v_0}(t) $$
其中 $I_{v_0}(t)$ 是项 $t$ 在原始二元模型 $M$ 中关于这个特定赋值 $v_0$ 的解释。

**命题 4.5.2 (h 的良定义性)**
映射 `h` 是良定义的。
**证明**:
我们需要证明，如果 $[t_1] = [t_2]$，那么 $h([t_1]) = h([t_2])$。这个定义的有效性不依赖于我们最初选择的规范赋值 $v_0$。

1.  前提是 $[t_1] = [t_2]$，根据等价类的定义，这意味着 `⊢ t₁ ≡ t₂`。
2.  根据 MEL 对原始模型 $M$ 的**可靠性定理 (定理 3.1)**，如果 `⊢ t₁ ≡ t₂`，则 $M \vDash t_1 \equiv t_2$。
3.  根据语义有效性的定义，$M \vDash t_1 \equiv t_2$ 意味着对于**任意**赋值 $v$，都有 $I_v(t_1) = I_v(t_2)$。
4.  既然该等式对*所有*赋值都成立，它自然也对我们在定义 `h` 时选定的那个特定的规范赋值 $v_0$ 成立。因此，我们有 $I_{v_0}(t_1) = I_{v_0}(t_2)$。
5.  根据 `h` 的定义，$h([t_1]) = I_{v_0}(t_1)$ 且 $h([t_2]) = I_{v_0}(t_2)$。
6.  因此，$h([t_1]) = h([t_2])$。这证明了 `h` 的值不依赖于等价类中代表元的选择，故 `h` 是良定义的。**这一步是连接两个世界的关键，它依赖于我们已证明的第一个可靠性定理。**

**命题 4.5.3 (h 是一个同态)**
映射 `h` 保持了所有构造子的结构。
**证明**:
我们需要对每个构造子进行验证，其中 `h` 的定义基于规范赋值 $v_0$。
1.  **对于 `·`**:
    $h(\text{app}_T([t_1], [t_2])) = h([(· \ t_1 \ t_2)]) = I_{v_0}((· \ t_1 \ t_2))$
    $= \text{app}(I_{v_0}(t_1), I_{v_0}(t_2)) = \text{app}(h([t_1]), h([t_2]))$
2.  **对于 `equiv`**:
    $h(\text{eq}_T([t_1], [t_2])) = h([(\text{equiv } t_1 \ t_2)]) = I_{v_0}((\text{equiv } t_1 \ t_2))$
    $= \text{eq}(I_{v_0}(t_1), I_{v_0}(t_2)) = \text{eq}(h([t_1]), h([t_2]))$
3.  **对于 `Quote`**:
    $h(\text{quote}_T([t_1])) = h([(\text{Quote } t_1)]) = I_{v_0}((\text{Quote } t_1))$
    $= \text{quote}(I_{v_0}(t_1)) = \text{quote}(h([t_1]))$
因此，`h` 是一个从代数结构 $(D_T, \text{app}_T, \text{eq}_T, \text{quote}_T)$ 到 $(D, \text{app}, \text{eq}, \text{quote})$ 的同态。

---

### **4.6 证明非平凡一致性**

**定理 4.6.1 (非平凡一致性 / Non-trivial Consistency)**
MEL 系统不是平凡的，即存在两个项 $t_1, t_2$ 使得 `⊬ t₁ ≡ t₂`。特别地，`⊬ T ≡ ⊥`。

**证明**:
我们再次使用反证法。

1.  **假设系统是平凡的 (Trivial)**: 假设对于任意两个项 $s_1, s_2 \in \mathcal{T}$，都有 `⊢ s₁ ≡ s₂`。

2.  **分析项模型的后果**: 如果系统是平凡的，那么所有的项都在同一个等价类中。这意味着项模型的论域 $D_T$ 是一个**单点集 (singleton set)**。也就是说，$D_T = \{[T]\}$，因为所有项都等价于 `T` (也等价于 `⊥` 等任何其他项)。

3.  **应用同态映射**: 我们有一个同态映射 $h: D_T \to D$。根据代数基本原理，一个同态映射的**像 (Image)** 的大小不能超过其**定义域 (Domain)** 的大小。
    *   由于 $D_T$ 是一个单点集，`h` 的像 $Im(h) = \{h(x) \mid x \in D_T\}$ 也必须是一个单点集。

4.  **导出矛盾**: 让我们来实际计算一下 `h` 的像。
    *   考虑 $D_T$ 中的元素 `[T]`。$h([T]) = I(T) = \mathbf{T}$。
    *   考虑 $D_T$ 中的元素 `[⊥]`。$h([⊥]) = I(⊥) = \mathbf{F}$。
    *   因此，`h` 的像 $Im(h)$ 至少包含 $\{\mathbf{T}, \mathbf{F}\}$ 这两个**不同**的元素。
    *   这意味着 `h` 的像的大小至少为 2。

5.  **结论**:
    *   从步骤 (3)，我们得出结论：`h` 的像的大小必须为 1。
    *   从步骤 (4)，我们得出结论：`h` 的像的大小至少为 2。
    *   这是一个明确的矛盾。因此，我们在步骤 (1) 的初始假设（系统是平凡的）必须是错误的。

故，MEL 系统不是平凡的。必然存在至少两个不等价的项。

由于我们已经证明了 `[T]` 和 `[⊥]` 被 `h` 映射到不同的值，它们必须是 $D_T$ 中不同的元素。即，$[T] \neq [⊥]$，这直接意味着 `⊬ T ≡ ⊥`。这个结论现在被置于一个更坚实的基础上。

**Q.E.D. (∎)**

