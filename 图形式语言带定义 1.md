## **1. 语法层**

#### **签名**

$$
\Sigma=\{\mathrm{Tuple}_n\ (n\ge 0),\ \mathrm{Def}\ (arity\ 2)\}.
$$

#### **原子集** $A$

一个给定的可数集。

#### **项集** $\mathsf{Term}$

项集 $\mathsf{Term}$ 是在签名 $\Sigma$ 与原子集 $A$ 上构造的自由项代数，由以下归纳规则定义：
*   **原子**: 若 $a\in A$，则 $a\in\mathsf{Term}$。
*   **元组**: 若 $t_1,\dots,t_n\in\mathsf{Term}$ (其中 $n \ge 0$)，则 $(t_1,\dots,t_n)\in\mathsf{Term}$。空元组 $()$ 是 $n=0$ 时的情形。
*   **定义**: 若 $t_1,t_2\in\mathsf{Term}$，则 $(t_1 := t_2)\in\mathsf{Term}$。

**注**：项 (Term) 在此系统中抽象地代表任意的**句法单元 (syntactic unit)**，如表达式、语句或类型。

#### **字面相等** $\equiv$

字面相等 $\equiv$ 是项代数上的结构同构关系，即构造子与对应子项逐一相等。

---

## **2. 切片算子**

对任一项 $t \in \mathsf{Term}$，其顶层连续子序列的集合 $\mathsf{Slice}(t)$ 定义如下：
$$
\mathsf{Slice}(t)=
\begin{cases}
\{(t_i,\dots,t_j)\mid 1\le i\le j\le n\}, & \text{若 } t=(t_1,\dots,t_n),\ n \ge 1\\[4pt]
\{()\}, & \text{若 } t=()\ (n=0)\\[4pt]
\{t\}, & \text{否则 (即 } t \text{ 为原子或定义项)}.
\end{cases}
$$

**引理 2.1**: 对于任意项 $t \in \mathsf{Term}$，恒有 $t \in \mathsf{Slice}(t)$。

---

## **3. 形式规则系统**

我们定义三个关系：子片段 (`⊑`)、定义性还原 (`~>`) 与句法依赖 (`R`)。

### **3.1 子片段关系 `⊑`**

`⊑` 是由以下规则生成的最小预序（自反、传递）。

```
(I-Slice)      u ∈ Slice(t)
            ----------------
                  u ⊑ t

(I-Trans)    s ⊑ u     u ⊑ t
            -----------------
                  s ⊑ t
```
**注**：自反性 ($t ⊑ t$) 可由 (I-Slice) 和引理 2.1 导出。

### **3.2 定义性还原关系 `~>`**

此关系直接由 `Def` 构造子的语义产生。
```
(Def-Reduce)   -----------------
               (t₁ := t₂) ~> t₂
```

### **3.3 句法依赖关系 `R`**

`R` 关系是由以下公理和规则生成的最小预序，捕捉了良构性的传递依赖。

```
(R-Reflex)      -----------
                   R(t,t)

(R-Trans)       R(t,u)   R(u,v)
                ---------------
                     R(t,v)

(R-Comp)        t 直接构成 u
                --------------
                     R(t,u)

(R-Inherit)     t ~> u   R(u,v)
                ---------------
                     R(t,v)

(R-Sub-Dep)     R(t,s)   u ⊑ s
                --------------
                     R(t,u)
```
其中，“$t$ 直接构成 $u$”是以下公理的简写：
*   $t=(t_1,\dots,t_n)$ 且 $u=t_i$ 对于某个 $1 \le i \le n$。
*   $t=(t_1 := t_2)$ 且 $u=t_1$ 或 $u=t_2$。

**规则解释**:
*   `(R-Comp)`: 一个复合项依赖于其直接结构组件。
*   `(R-Inherit)`: 一个定义项继承其定义体的所有依赖。
*   `(R-Sub-Dep)`: 若 $t$ 依赖于 $s$，则 $t$ 也依赖于 $s$ 的任意文本子片段。这对应于依赖链的**后扩展**。

**附注：关于 `(R-Monotone)` 规则的语义与可导出性**

`(R-Monotone)` 规则表述如下：
```
(R-Monotone)    s ⊑ t   R(s,u)
                --------------
                     R(t,u)
```

**1. 语义动机**

此规则捕捉了一个关于依赖传递的关键直觉：**依赖的上下文扩展**。其语义可以解读为：如果一个较小的句法片段 `s` 依赖于某个单元 `u`，那么任何包含 `s` 作为其文本子片段的、更大的句法单元 `t`，也必须继承对 `u` 的这份依赖。

例如，若表达式 `lookup(key)`（即 `s`）依赖于库函数 `lookup` 的定义（即 `u`），那么包含此表达式的完整语句 `if (x > 0) { result = lookup(key); }`（即 `t`）也自然地依赖于 `lookup` 的定义。`(R-Monotone)` 将这种继承关系形式化，确保了依赖关系在句法单元被嵌入或组合时能够被正确地向上传递。在规则解释中，这被称为依赖链的**前扩展**。

**2. 可导出性证明**

尽管 `(R-Monotone)` 具有清晰且重要的语义动机，但在我们当前定义的规则系统中，它是**冗余的**。它可以被 `(R-Reflex)`、`(R-Trans)` 和 `(R-Sub-Dep)` 共同导出。因此，为了保持公理系统的最小化，`(R-Monotone)` 可以被安全地移除而不损失系统的表达能力。

**定理**: 规则 `(R-Monotone)` 可由其他 `R` 关系规则导出。

**证明**:
我们的目标是证明，在给定前提 `s ⊑ t` 和 `R(s, u)` 的情况下，我们可以推导出结论 `R(t, u)`。

| 步骤 | 断言     | 理由                                      |
| :--- | :------- | :---------------------------------------- |
| 1.   | `s ⊑ t`  | 前提 1                                    |
| 2.   | `R(s, u)`  | 前提 2                                    |
| 3.   | `R(t, t)`  | 公理 `(R-Reflex)`                         |
| 4.   | `R(t, s)`  | 应用 `(R-Sub-Dep)` 于 (3) 和 (1)          |
| 5.   | `R(t, u)`  | 应用 `(R-Trans)` 于 (4) 和 (2)            |

**证明解释**:
- 我们从 `R` 关系的自反性 `R(t, t)` 出发 (步骤 3)。
- `(R-Sub-Dep)` 规则允许我们将依赖链进行后扩展：若 `t` 依赖于 `t` 自身，则它也依赖于 `t` 的任意子片段 `s` (步骤 4)。
- 最后，利用 `R` 关系的传递性 `(R-Trans)`，我们将 `R(t, s)` 和 `R(s, u)` 这两条依赖链连接起来，从而得到最终结论 `R(t, u)` (步骤 5)。

此证明表明，`(R-Monotone)` 所描述的“前扩展”特性，实际上可以由自反性、传递性以及更强的“后扩展”规则 `(R-Sub-Dep)` 组合而成。

---

## **4. 超图模型**

 为了将形式系统中的依赖关系模型化，我们引入一个基于有向超图的语义模型。该模型的构造基于一个满足特定闭包性质的项集。

**定义 4.1 (切片闭包集)**: 一个项集 $S \subseteq \mathsf{Term}$ 被称为**切片闭包的 (slice-closed)**，如果对于任意 $t \in S$，均有 $\mathsf{Slice}(t) \subseteq S$。

在本节的后续内容中，我们**假设**给定的项集 $S$ 是一个**切片闭包集**。基于此，我们构造一个有向超图 $H=(V, E)$。

*   **顶点集 $V$**: $V=S$。
*   **超边集 $E$**: $E$ 是 $V \times \mathcal{P}(V)$ 的子集，其中每个超边 $e=(h, T)$ 代表从头顶点 $h$ 到尾顶点集 $T$ 的一条依赖弧。$E$ 由以下三类超边构成：
    1.  **构成边 $E_{\mathsf{comp}}$**:
        *   对每个 $t=(t_1,\dots,t_n) \in V$，加入超边 $(t, \{t_1,\dots,t_n\})$。
        *   对每个 $t=(t_1 := t_2) \in V$，加入超边 $(t, \{t_1, t_2\})$。
        *   对每个原子 $a \in V$，加入超边 $(a, \emptyset)$。
    2.  **子片段边 $E_{\mathsf{slice}}$**:
        *   对每个 $t \in V$ 和每个 $u \in \mathsf{Slice}(t)$，加入超边 $(t, \{u\})$。
    3.  **定义边 $E_{\mathsf{def}}$**:
        *   对每个 $t=(t_1 := t_2) \in V$，加入超边 $(t, \{t_2\})$。

**模型中的关系定义**:

令**路径**是从顶点 $v_0$ 到 $v_k$ 的一个序列 $v_0, e_1, v_1, \dots, e_k, v_k$，其中 $v_i \in V$，$e_i = (v_{i-1}, T_i) \in E$ 且 $v_i \in T_i$。若存在这样的路径，我们记为 $v_0 \to^* v_k$。

*   $s \sqsubseteq_H t$ 当且仅当存在一条从 $t$ 到 $s$ 的、**仅由子片段边 ($E_{\mathsf{slice}}$)** 构成的路径。
*   $t \leadsto_H u$ 当且仅当超边 $(t, \{u\}) \in E_{\mathsf{def}}$。
*   $R_H(t, u)$ 当且仅当 $t \to^* u$，即从 $t$ 到 $u$ 存在一条由**任意类型超边**构成的路径（长度 $\ge 0$）。

---

## **5. 等价性定理**

对于任意项集 $S$ 及由其构造的超图 $H$，形式规则系统与超图模型是等价的。

**定理 1 (子片段关系等价性):**
对任意 $s, t \in S$，$s \sqsubseteq t \iff s \sqsubseteq_H t$。

**定理 2 (定义性还原关系等价性):**
对任意 $t, u \in S$，$t \leadsto u \iff t \leadsto_H u$。

**定理 3 (句法依赖关系等价性):**
对任意 $t, u \in S$，$R(t, u) \iff R_H(t, u)$。

*证明概要*: 证明通过对推导结构和路径结构的双重归纳进行。
($\Rightarrow$) 形式系统中的每条公理或规则都对应于超图中一个长度为1或更长的路径，或者是一种路径的拼接操作。例如，`(R-Comp)` 对应于一条长度为1的构成边路径，而 `(R-Trans)` 对应于路径的拼接。
($\Leftarrow$) 超图中的任意一条路径都可以通过组合应用相应的形式规则来模拟。一条路径 $t \to^* u$ 可以在形式系统中通过对路径长度的归纳来构造出 $R(t, u)$ 的一个推导。基础情况（长度为0或1的路径）直接由 `(R-Reflex)` 和基础依赖公理（如 `(R-Comp)`）覆盖。归纳步骤则利用 `(R-Trans)`, `(R-Monotone)`, `(R-Inherit)` 和 `(R-Sub-Dep)` 等规则来模拟路径的扩展。
