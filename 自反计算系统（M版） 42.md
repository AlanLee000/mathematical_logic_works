
### **自反计算逻辑框架 M (System M)**

#### **1. 语法 (Syntax)**

**1.1 签名与项**

设 `V` 为一个可数的变量集合。
设 `Σ` 为一个签名，包含以下函数符号：
*   `equiv: Term × Term → Term` （二元，等价断言构造器）
*   `rewrite: Term × Term → Term` （二元，重写规则构造器）
*   `tuple_n: Termⁿ → Term` for each n ≥ 0 （n元组构造器，简记为 `(t₁, ..., tₙ)`）
*   （可包含其他用户定义的构造器）

所有项的集合是在签名 `Σ` 上以变量集 `V` 为基础构建的自由项代数，记为 `T_Σ(V)`。**基项 (Ground Terms)** 的集合 `T_Σ` 是 `T_Σ(V)` 中不含变量的项的子集。

**1.2 规范项与良构约束**

系统的状态由一个称为**规范项 (Specification Term)** `T ∈ T_Σ(V)` 定义。一个规范项 `T` 必须是**良构的 (Well-formed)**，即满足以下两个约束：

1.  **变量作用域约束 (Variable Scoping Constraint):** `T` 中的任何变量 `v ∈ V` 必须出现在一个形式为 `rewrite(l, r)` 的子项的 `l` 或 `r` 部分。形式化地，对于 `T` 中任何变量出现的位置 `p`（即 `T|ₚ ∈ V`），都存在一个 `p` 的前缀 `q`，使得 `T|q` 的形式为 `rewrite(l, r)`。

2.  **规则安全性约束 (Rule Safety Constraint):** `T` 中任何形式为 `rewrite(l, r)` 的子项，其右侧 `r` 的变量集合必须是其左侧 `l` 变量集合的子集。即 `vars(r) ⊆ vars(l)`。

#### **2. 语义上下文 (Semantic Context)**

对于任意一个规范项 `T`，我们可以从中提取其在当前状态下的语义上下文，该上下文由一组重写规则和一组等价公理构成。

1.  **重写规则集 `R(T)`:**
    `R(T) = { (l, r) | rewrite(l, r) ∈ Sub(T) }`
    其中 `Sub(T)` 是 `T` 的所有子项的集合。我们使用 `l → r` 指代规则偶对 `(l, r)`。

2.  **等价公理集 `AxiomPairs(T)`:**
    `AxiomPairs(T) = { (s, t) | equiv(s, t) ∈ Sub(T) ∧ vars(equiv(s, t)) = ∅ }`
    此定义意味着，只有在当前状态 `T` 中作为基项存在的 `equiv` 子项才被视为公理。

#### **3. 推论关系 (Inferential Relation)**

系统的推论能力基于一个从当前规范项 `T` 动态构建的等价关系。为确保操作语义的良定义性和可判定性，我们做出一个关键的设计决策：**系统的重写操作和受域限制的基替换仅在基项（Ground Terms）的范畴内进行。**

**3.1 动态同余关系 `≡_T`**

对于一个给定的规范项 `T`，其动态同余关系 `≡_T` 定义在 `T` 的所有基项子项的集合 `GroundSub(T)` 上。

1.  **论域 (Universe):** `U = GroundSub(T)`。
2.  **基础等式:** `E = AxiomPairs(T)`。
3.  **定义:** `≡_T` 是在论域 `U` 上，包含基础等式 `E` 的最小同余闭包。它是一个满足自反性、对称性、传递性和同余性的等价关系。

**3.2 可判定性与算法**

由于论域 `U` 和基础等式集 `E` 都是有限的，对于任意给定的 `u, v ∈ U`，判断 `u ≡_T v` 的问题是**可判定的**。此判定可通过标准的同余闭包算法（例如，基于 Union-Find 数据结构并在不动点迭代中应用同余律）在多项式时间内有效解决。

此处的**可判定性**是系统 M 一个核心且刻意的设计决策，它源于对公理使用的**分层处理哲学 (Stratified Axiom Handling)**。系统严格区分了“带变量的公理模式”和“用于推论的基公理实例”：

1.  **公理的生成层（通过重写编程）**:
    任何具有普遍性、模式化的等价关系（例如交换律 `f(X,Y) = f(Y,X)`）本身**不被**直接编码为 `equiv` 项。相反，它们被编码为**重写规则**，这些规则的右侧 `r` 会*生成*一个或多个**基（ground）的 `equiv` 断言**。例如，一个规则 `rewrite(l(X,Y), r(equiv(f(X,Y), f(Y,X)), ...))` 在被触发时，会根据匹配到的具体基项，动态地在系统状态中“物化”出一个不含变量的公理实例，如 `equiv(f(a,b), f(b,a))`。

2.  **公理的应用层（通过同余闭包）**:
    `AxiomPairs(T)` 的定义严格筛选出当前状态 `T` 中所有**不含变量**的 `equiv` 子项。这意味着，驱动 `≡_T` 关系的等价理论总是由一个**有限的、具体的基等式集合**构成。这使得同余闭包算法始终可以在一个有限论域上执行，从而保证了 `u ≡_T v` 判定的可终止性和高效性。

这种分层设计绕过了通用 E-matching（模一个含变量的等式理论进行匹配）问题中固有的不可判定性或高复杂性。系统将公理的“应用范围”限制在当前已知的、具体的实体上，同时保留了通过重写规则动态扩展此范围的能力，实现了表达能力与计算可行性之间的精妙平衡。

**3.3 演示实例：动态生成与应用交换律公理**

此示例展示了系统如何通过重写规则动态生成一个交换律的实例，并在后续的重写步骤中利用该实例进行 E-matching。

**初始规范项 `T₀`**

假设我们有一个函数 `add`，我们希望在需要时才为其断言交换律。同时，我们有一个 `simplify` 规则，它只认识 `add(const_2, const_1)` 这种特定形式。

```
T₀ = tuple(
    // 规则1: 公理生成器
    // 当遇到 'declare_comm(add)' 和一个 'add' 项时,
    // 为该 'add' 项生成一个具体的交换律公理实例。
    rewrite(
        tuple(declare_comm(add), add(X, Y)),
        tuple(declare_comm(add), add(X, Y), equiv(add(X, Y), add(Y, X)))
    ),

    // 规则2: 简化器
    // 只能匹配 'add(const_2, const_1)' 形式。
    rewrite(
        add(const_2, const_1),
        simplified_result
    ),

    // 初始数据
    tuple(
        declare_comm(add),
        add(const_1, const_2)
    )
)
```

**计算步骤**

**1. 第一次迁移 `T₀ ⟶ T₁` (生成公理)**

*   **目标与规则**: `T₀` 中的子项 `a = tuple(declare_comm(add), add(const_1, const_2))` 匹配了**规则1**的左侧 `l = tuple(declare_comm(add), add(X, Y))`。
*   **匹配**: 得到基替换 `σ = {X ↦ const_1, Y ↦ const_2}`。
*   **重写**: `a` 被 `σ(r)` 替换，即 `tuple(declare_comm(add), add(const_1, const_2), equiv(add(const_1, const_2), add(const_2, const_1)))`。
*   **结果 `T₁`**:
    ```
    T₁ = tuple(
        // ... 规则1 和 规则2 保持不变 ...
        rewrite(...), 
        rewrite(...),
        // 原数据部分被替换
        tuple(
            declare_comm(add),
            add(const_1, const_2),
            equiv(add(const_1, const_2), add(const_2, const_1)) // <-- 新生成的基公理
        )
    )
    ```

**2. 第二次迁移 `T₁ ⟶ T₂` (应用公理进行 E-matching)**

*   **当前语义上下文**: 在 `T₁` 中，我们提取其语义上下文：
    *   `AxiomPairs(T₁) = { (add(const_1, const_2), add(const_2, const_1)) }`
    *   因此，`add(const_1, const_2) ≡_{T₁} add(const_2, const_1)`。

*   **目标与规则**: 系统现在尝试应用**规则2**，其左侧 `l = add(const_2, const_1)`。
*   **E-matching**: 系统在 `T₁` 中寻找可以匹配 `l` 的基项子项。它找到了子项 `a = add(const_1, const_2)`。
*   **匹配判定**: 系统求解受域限制的基替换问题 `σ(l) ≡_{T₁} a`。
    *   由于 `l` 本身是基项，所以 `σ` 是空替换。
    *   问题简化为判定 `add(const_2, const_1) ≡_{T₁} add(const_1, const_2)` 是否成立。
    *   根据从 `T₁` 动态构建的同余关系，此判定为**真**。

*   **重写**: 匹配成功！子项 `a = add(const_1, const_2)` 被规则2的右侧 `simplified_result` 替换。
*   **结果 `T₂`**:
    ```
    T₂ = tuple(
        // ... 规则1 和 规则2 保持不变 ...
        rewrite(...), 
        rewrite(...),
        // 数据部分再次被更新
        tuple(
            declare_comm(add),
            simplified_result, // <-- 重写发生
            equiv(add(const_1, const_2), add(const_2, const_1))
        )
    )
    ```

**结论**: 这个例子清晰地演示了分层哲学：`T₀ ⟶ T₁` 是**公理生成层**的计算，它产生了一个具体的、无变量的公理。`T₁ ⟶ T₂` 则是**公理应用层**的计算，它利用这个生成的公理来驱动 `≡_{T₁}` 关系，完成了一次非平凡的语义匹配（E-matching），从而触发了原本无法进行的句法重写。整个过程是完全可判定的。

#### **4. 操作语义 (Operational Semantics)**

系统的演化由一个单步迁移关系 `⟶` 定义。迁移的核心在于，使用 `T` 中的规则，对 `T` 中的一个基项子项进行重写。

**4.1 受域限制的基替换 (Inferential Matching)** 

**定义（受域限制的基替换）**

给定当前规范项 $T$，记 $U := \mathsf{GroundSub}(T)$ 为 $T$ 的**基项子项集合**。令 $l\in T_\Sigma(V)$ 为一个模式项，令 $a\in T_\Sigma$ 为一个目标基项。我们将称一个替换 $\sigma$ 为**受域限制的基替换（domain-restricted ground substitution）**，当且仅当满足：

1. $\mathsf{dom}(\sigma) = \mathsf{vars}(l)$；

2. $\mathsf{codom}(\sigma) \subseteq U$（即对每个 $x\in \mathsf{vars}(l)$，$\sigma(x)\in U$）；

3. $\sigma(l)\in U$。

因此 $\sigma(l)$ 必然落在论域 $U$ 内。

---

**受域限制的基替换问题（Restricted E-matching，修订版）**

在上述记号下，目标是寻找所有满足条件的受域限制的基替换 $\sigma$，使得

$$

\sigma(l)\equiv_T a.

$$

由于（3）的保证，$\sigma(l), a \in U$，因此判定谓词 $\sigma(l)\equiv_T a$ 在逻辑上定义良好。

 **解释性说明（语义与实现要点）**：将 $\sigma$ 的值域限制为 $U$ 是本系统设计的必要形式化步骤——它消除 $\equiv_T$ 的论域与 $\sigma(l)$ 可能落在外部项之间的类型不一致，从而保证匹配谓词 $\sigma(l)\equiv_T a$ 在逻辑上是有意义且可判定的。该限制同时在实现上将匹配搜索空间精确限定为 $U^{\,\mathsf{vars}(l)}$（即每个模式变量仅从 $U$ 中取值），使得搜索算法能利用同余代表与索引结构进行有效剪枝。

 **计算复杂性评注**：在此受域限制模型下，$\equiv_T$ 的判定仍可通过对有限集合 $U$ 上的同余闭包算法（如基于 Union-Find 的 congruence-closure）在多项式时间内完成；然而，枚举满足 $\sigma(l)\equiv_T a$ 的所有 $\sigma$ 本质上仍是一个组合搜索问题，其最坏情况复杂度受参数 $|U|$ 与 $|\mathsf{vars}(l)|$ 驱动（最坏情形上界为 $|U|^{|\mathsf{vars}(l)|}$ 次等价测试）。在没有引入额外代数律（如 AC）时，实际性能可通过下述技术显著改善：对每个变量维持候选集（由同余代表索引得到）、提前用同余类约束进行一致性剪枝、以及模式结构的分段匹配（symbol-guided matching）。若引入特定代数律，则匹配问题的复杂度分析需相应扩展并可能变得更困难。

**4.2 单步迁移关系 `⟶`**

一个规范项 `T` 可以通过单步迁移演化为 `T'`，记为 `T ⟶ T'`，当且仅当存在一个重写实例 `(p_app, p_rule, σ)`，使得：

1.  **目标与规则定位:**
    *   `p_app` 是 `T` 中一个**基项子项** `a = T|_{p_{app}}` 的位置 (`a ∈ T_Σ`)。
    *   `p_rule` 是 `T` 中一个规则子项 `rewrite(l, r) = T|_{p_{rule}}` 的位置。

2.  **匹配成功:**
    存在至少一个基替换 `σ` 是 `(l, a, ≡_T)` 的一个受域限制的基替换解。
    *(注：系统是非确定性的，任何一个有效的 `σ` 都可以触发一次迁移。)*

3.  **构造候选状态:**
    构造候选后继状态 `T_{cand} := T[σ(r)]_{p_{app}}`。根据规则安全性约束，`σ(r)` 必然是基项。

如果以上条件全部满足，则迁移发生，定义 `T' := T_{cand}`。否则，该重写实例不产生迁移。

#### **5. 计算 (Computation)**

*   一个**计算 (Computation)** 或**推导 (Derivation)** 是一个（有限或无限的）迁移序列：
    `T₀ ⟶ T₁ ⟶ T₂ ⟶ ...`
    其中 `T₀` 是一个初始的良构规范项。

*   一个规范项 `T_n` 如果不存在任何 `T'` 使得 `T_n ⟶ T'`，则称 `T_n` 是一个**范式 (Normal Form)**。计算在达到范式时**终止 (terminates)**。

---

# 附录 A — 良构性的不变性

**前置说明与记号约定**

* 设 $V$ 是可数变量集合，$\Sigma$ 为签名，项代数记为 $T_\Sigma(V)$。基项（ground term）的集合记为 $T_\Sigma\subseteq T_\Sigma(V)$。

* 给定项 $T$ 与位置 $p$，记 $T|_{p}$ 为 $T$ 在位置 $p$ 处的子项；记 $T[s]_{p}$ 为用项 $s$ 替换 $T$ 中位置 $p$ 处子项所得的项。

* 位置的前缀关系记为“$q$ 是 $p$ 的前缀”（写作 $q \preceq p$），严格前缀写作 $q \prec p$。若既非前缀亦非后缀，则称为不相交或不可比较（incomparable）。

* 对项 $u$，$\mathsf{vars}(u)$ 表示其中出现的变量集合。基替换（ground substitution）定义为 $\sigma:\mathsf{dom}(\sigma)\to T_\Sigma$ 且 $\mathsf{codom}(\sigma)\subseteq T_\Sigma$。若 $\mathsf{dom}(\sigma)=\mathsf{vars}(l)$ 则称 $\sigma$ 覆盖模式 $l$。

* 约束回顾（系统设定）：良构项 $T$ 满足

1. 变量作用域约束：$T$ 中的每个变量出现在某个形如 $\mathsf{rewrite}(l,r)$ 的子项的 $l$ 或 $r$ 中。

2. 规则安全性约束：对于任一 $\mathsf{rewrite}(l,r)$ 子项，$\mathsf{vars}(r)\subseteq\mathsf{vars}(l)$。

下列引理与定理在上述记号与约束下给出并证明。为避免歧义，假设所有考虑的项 $T$ 是**有限表示**的（因此其子项集、基项子项集均为有限集）。

---

## 引理 A.1（位置三分分类）

对任意项 $T$ 中的两个位置 $p$ 与 $q$，恰有三种互斥可能中的一种成立：

1. $q \prec p$（$q$ 是 $p$ 的严格前缀，$q$ 为 $p$ 的祖先）；

2. $p \prec q$（$p$ 是 $q$ 的严格前缀，$p$ 为 $q$ 的祖先）；

3. $p$ 与 $q$ 不可比较（neither is prefix of the other）。

**证明（短）**：位置按树路径表示，前缀关系是自然的偏序；任取两路径必然满足上述三相斥情况之一。∎

---

## 引理 A.2（替换右侧的基性：若 $\mathsf{vars}(r)\subseteq\mathsf{vars}(l)$ 且 $\sigma$ 为基替换，则 $\sigma(r)$ 为基项）

**陈述：** 令 $l,r\in T_\Sigma(V)$。若 $\mathsf{vars}(r)\subseteq\mathsf{vars}(l)$，且 $\sigma$ 是以 $\mathsf{vars}(l)$ 为定义域且值域在 $T_\Sigma$ 中的替换（即对每个 $x\in\mathsf{vars}(l)$，$\sigma(x)\in T_\Sigma$），则 $\sigma(r)\in T_\Sigma$。

**证明：** 通过对 $r$ 做结构归纳。

* 基本情形：若 $r$ 为变量 $x$。因为 $\mathsf{vars}(r)\subseteq\mathsf{vars}(l)$，$x\in\mathsf{vars}(l)$，故 $\sigma(x)\in T_\Sigma$，即 $\sigma(r)$ 为基项。

* 归纳步：若 $r = f(r_1,\dots,r_k)$（构造子 $f\in\Sigma$），则按归纳假设每个 $\sigma(r_i)\in T_\Sigma$。于是 $\sigma(r) = f(\sigma(r_1),\dots,\sigma(r_k))$ 为由构造子作用于基项所得的项，因而仍为基项。

因此 $\sigma(r)\in T_\Sigma$。∎

---

## 引理 A.3（被基替换覆盖的子树不含变量）

**陈述：** 设 $T$ 为任意项，位置 $p_{app}$ 处的子项 $a:=T|_{p_{app}}$ 为基项。设 $g\in T_\Sigma$（基项），令 $T' := T[g]_{p_{app}}$。则对任意位置 $p$ 满足 $p_{app} \preceq p$（即 $p$ 在被替换的子树内），有 $T'|_{p}\in T_\Sigma$（即该位置处无变量）。

**证明：** 由替换定义，$T[g]_{p_{app}}$ 在 $p_{app}$ 的子树被完全替换为基项 $g$。基项 $g$ 本身不含变量，所以其所有子位置对应的子项也不含变量。于是对任意 $p$ 以 $p_{app}$ 为前缀，有 $T'|_p$ 等于 $g$ 在相应位置的子项，故不含变量。∎

---

## 引理 A.4（子树不受替换影响的保持性）

**陈述：** 在与引理 A.3 相同设定下，任取位置 $q$ 若 $p_{app}$ **不是** $q$ 的前缀（即 $p_{app}\not\preceq q$），则 $T'|_{q} = T|_{q}$。

**证明：** 替换 $T[g]_{p_{app}}$ 仅改变以 $p_{app}$ 为根的子树；若 $q$ 不在该子树内，则该位置不被修改，子项保持不变。∎

---

## 定理 A.5（良构性的保持）
 **定理 A.5（良构性的保持）**

 设 $T$ 为良构的规范项（满足变量作用域约束与规则安全性约束）。若存在单步迁移 $T \longrightarrow T'$ 且该迁移由重写实例 $(p_{app},\,p_{rule},\,\sigma)$ 触发，且满足下列条件：

 * $a := T|_{p_{app}}$ 为被替换的基项（$a\in T_\Sigma$）；
 * $rewrite(l,r) = T|_{p_{rule}}$ 为触发的规则子项；
 * $\sigma$ 为一个**受域限制的基替换**（即 $\mathsf{dom}(\sigma)=\mathsf{vars}(l)$ 且 $\mathsf{codom}(\sigma)\subseteq U$，其中 $U:=\mathsf{GroundSub}(T)$），并且 $\sigma(l)\equiv_T a$（即 $\sigma$ 是 $(l,a,\equiv_T)$ 的一个推论匹配解）。

 定义 $T' := T[\sigma(r)]_{p_{app}}$。那么 $T'$ 仍为良构项（仍满足两条良构约束）。

 **证明**：下面证明规则安全性约束与变量作用域约束在 $T'$ 中保持。
 
1. **规则安全性约束的保持。**

 令 $S' = rewrite(l',r')$ 为 $T'$ 中任一 `rewrite` 子项。我们按 $S'$ 的来源分类。

 **情况 A（$S'$ 源自插入项 $\sigma(r)$）**：

 由于在迁移前我们已假设 $\sigma$ 的**值域被限制在** $U\subseteq T_\Sigma$，并且由规则安全性约束有 $\mathsf{vars}(r)\subseteq\mathsf{vars}(l)$，可应用引理 A.2 得出 $\sigma(r)\in T_\Sigma$。因此在被插入的子树内出现的任何 `rewrite(l',r')` 都是基项形式（其 $l',r'$ 不含变量），于是 $\mathsf{vars}(r')=\varnothing=\mathsf{vars}(l')$，从而 $\mathsf{vars}(r')\subseteq\mathsf{vars}(l')$ 成立。

 **情况 B（$S'$ 来自 $T$ 中原先存在且未被替换的子项）**：

 若 $S'$ 的位置 $q$ 满足 $p_{app}\not\preceq q$，则由引理 A.4 有 $T'|_q = T|_q$。因为 $T$ 良构，原子项 $S=T|_q$ 满足规则安全性约束，替换并未改变该子项，故在 $T'$ 中仍有 $\mathsf{vars}(r')\subseteq\mathsf{vars}(l')$。

 两种情况穷尽所有可能，因此规则安全性约束在 $T'$ 中保持。
 
2. **变量作用域约束的保持。**

 设 $v$ 为 $T'$ 中任一变量，取位置 $p$ 使得 $T'|_p=v$。由引理 A.3（被基替换覆盖的子树不含变量）知，对于被替换位置 $p_{app}$ 及其子树中的任意位置均不含变量；因此必有 $p_{app}\not\preceq p$。于是 $T|_p = T'|_p = v$。由于 $T$ 良构，存在某前缀位置 $q\preceq p$ 使得 $T|_q = rewrite(l_v,r_v)$ 且 $v\in\mathsf{vars}(l_v)\cup\mathsf{vars}(r_v)$。

 下面按 $q$ 与 $p_{app}$ 的相对关系分类（参照引理 A.1 的三分）：

 * 若 $q \prec p_{app}$：则 $rewrite(l_v,r_v)$ 为被替换子树的祖先节点。替换只作用于其某些后代位置，祖先节点保持其 root 构造子不变；因为 $rewrite(l_v,r_v)$ 含变量，故该祖先不能在替换时整体被基项 $a$ 代替（否则其将不含变量），因此 $rewrite(l_v,r_v)$ 在 $T'$ 中依然存在并包含变量 $v$，即 $v$ 仍被某个 `rewrite` 子项界定。

 * 不可能有 $q = p_{app}$，因为 $p_{app}$ 对应的 $a$ 是基项，而含变量的 `rewrite(l_v,r_v)` 不是基项，两者不可能相等。

 * 若 $p_{app} \prec q$：则 $q$ 位于被替换子树内部。但根据引理 A.3，被替换子树内不含变量，这与 $rewrite(l_v,r_v)$ 含变量相矛盾，因此此类情形不成立。

 由此得出：对于任意 $T'$ 中的变量 $v$，存在某 `rewrite` 子项在 $T'$ 中界定该变量，变量作用域约束保持。

 结合（1）与（2），可得 $T'$ 同时满足规则安全性约束与变量作用域约束，故 $T'$ 为良构项。证毕。


# **分析：System M 的表达能力边界与形式系统定位**

## **1. System M 的核心计算特征**

System M 的计算模型由其四个核心特征共同定义，这些特征的组合使其在形式系统领域中独树一帜。

1.  **自反性 (Self-Reflection)**: 系统的完整状态，包括数据、操作规则 (`rewrite`) 和语义公理 (`equiv`)，均被统一表示为一个单一的规范项 `T`。系统的演化 `T ⟶ T'` 是一种自我修改操作，规则可以作用于包含其他规则或公理的子项，从而实现元计算（computation on the computation itself）。

2.  **动态语义上下文 (Dynamic Semantic Context)**: 与传统逻辑系统中固定的公理和规则集不同，System M 的理论基础——即重写规则集 `R(T)` 和等价关系 `≡_T`——是动态的。它们在每一步计算后都根据当前状态 `T` 重新派生。这使得系统的逻辑可以随计算进程而演化。

3.  **等价推理驱动的匹配 (E-matching)**: 重写规则的应用并非基于简单的句法匹配，而是基于 `≡_T` 关系的语义匹配（`σ(l) ≡_T a`）。这使得系统能够抽象掉语法上的差异，在等价类的层面上进行模式匹配和重写，其能力类似于带有代数公理（如结合律、交换律）的重写系统。

4.  **受域限制的资源生成 (Domain-Restricted Resource Generation)**: 这是 System M 最具定义性的特征。规则实例化时，基替换 `σ` 的值域 `codom(σ)` 被严格限制在当前状态 `T` 已有的基项子项集合 `U = GroundSub(T)` 内。此约束意味着：
    *   **创造性受限**: 系统不能凭空引入全新的原子常量。所有用于实例化的“原材料”必须在当前状态中已经存在。
    *   **组合性生成**: 尽管原材料受限，但规则的右侧 `r` 可以通过其结构将这些原材料组合成一个全新的项 `σ(r)`。例如，若 `r = f(X, Y)` 且 `a, b ∈ U`，则 `σ(r) = f(a, b)` 可能是一个在 `U` 中不存在的新项。这个新项在 `T` 更新为 `T'` 后，将成为 `GroundSub(T')` 的一部分，为后续计算提供新的资源。正是这种组合性生成的能力，为系统提供了潜在的无限计算能力。

## **2. 与其他形式系统的关系**

### **2.1. 与一阶等式逻辑 (First-Order Equational Logic)**

*   **动态嵌入**: System M 可以动态地嵌入和执行任何有限的纯等式逻辑理论。一个等式理论的基公理集可以被编码为 `T` 中的一组 `equiv(s, t)` 子项。`u` 和 `v` 在该理论下等价，当且仅当在 `T` 中可以判定 `u ≡_T v`。同余闭包的定义确保了其与等式逻辑语义的一致性。
*   **超越之处**: System M 通过 `rewrite` 规则，可以动态地增加、删除或修改 `equiv` 公理，从而在运行时改变其底层的等式理论。这是标准等式逻辑不具备的元逻辑和计算能力。

### **2.2. 与重写逻辑 (Rewriting Logic)**

*   **相似性**: 系统的核心迁移关系 `T ⟶ T'` 是对项的重写，这与重写逻辑的基本思想一致。
*   **关键差异**:
    1.  **理论的内化 vs. 外化**: 在重写逻辑中，规则集 `R` 与被重写的项 `t` 通常是分离的 (`R ⊢ t → t'`)。在 System M 中，规则集 `R(T)` 内在于项 `T` 本身，实现了规则与数据的统一。
    2.  **匹配机制**: 标准重写逻辑使用句法匹配，而 System M 使用 `≡_T`-匹配，使其成为一种**模动态等价理论的重写系统**。
    3.  **资源约束**: 标准重写逻辑中的替换 `σ` 可以将变量映射到任何良构的项。System M 的 `codom(σ) ⊆ GroundSub(T)` 约束是一个根本性区别，使系统对当前状态的“物质资源”高度敏感。
*   **结论**: System M 可被视为一种**自反的、资源敏感的重写逻辑变体**。

### **2.3. 与 λ-演算 (Lambda Calculus)**

*   **模型差异**: 两者在计算的根本机制上完全不同。System M 是一阶的，其变量是模式变量，作用域由 `rewrite` 构造静态界定。λ-演算是高阶的，其变量通过 `λ` 绑定，遵循词法作用域和 β-归约。System M 缺乏内置的函数抽象与应用机制。
*   **关系**: 由于 System M 是图灵完备的（见下文），理论上它可以实现一个 λ-演算的求值器，但这仅是计算能力上的模拟，而非形式系统层面的等价或自然嵌入。

### **2.4. 与图转换 (Graph Rewriting)**

*   **概念联系**: 项可视为树（一种特殊的图），项重写可视为树转换。System M 可以被理解为一种高度结构化的**自反式树转换系统**。规则本身作为树节点存在，并可以修改其所在的树。
*   **模拟能力**: `≡_T` 关系可以用来模拟图转换中的节点合并。若 `a ≡_T b`，则 `a` 和 `b` 在语义上代表同一个实体，尽管它们在树中有不同的位置。这使得 M 能够表达超越纯树形结构的等价关系。

## **3. 表达能力的精确边界**

### **3.1. 何时 System M 等价于“一阶等式逻辑 + 规则”？**

System M 的行为在一个受限的子集内等价于一个标准的**项重写系统模一个固定的等式理论 (Term Rewriting System modulo a fixed equational theory)**，但这需要满足以下严格条件：

1.  **静态理论结构**: 初始规范项 `T₀` 被结构化为分离的部分，例如 `T₀ = context(Rules, Axioms, Data)`。
2.  **理论的不可修改性**: 系统的所有 `rewrite` 规则被设计为只修改 `Data` 部分，并且规则的右侧 `r` 在实例化后 `σ(r)` 不会引入新的 `rewrite` 或 `equiv` 构造器到顶层结构中。

在此条件下，规则集 `R(T)` 和公理集 `AxiomPairs(T)` 保持固定，系统退化为一个非自反的模型。然而，由于**受域限制的基替换**机制依然存在，它仍然与标准TRS不同，除非 `Data` 部分初始就包含了所有计算中可能用到的基项组件。

### **3.2. 何种扩展会导致图灵等价？**

**结论：System M 在其基本定义下，无需任何扩展，已经是图灵完备的 (Turing-complete)。**

**论证 (通过模拟双计数器机 Minsky Machine)**:

一个双计数器机（足以实现图灵完备性）可以通过 System M 进行直接模拟。

1.  **状态表示**: 机器的状态可表示为项 `state(InstrPtr, C1, C2)`。计数器 `C1` 和 `C2` 的值用 Peano 数表示：`zero`, `s(zero)`, `s(s(zero))`...

2.  **程序编码**: 机器的指令集被编码为一系列 `rewrite` 规则，这些规则本身是规范项 `T` 的一部分，从而实现了程序的自反表示。

3.  **模拟 `INC C1` 指令**:
    假设当前指令 `L1` 是增加计数器 `C1`，然后跳转到 `L2`。这可以通过以下规则实现：
    ```
    rewrite(
      state(l1, C1, C2),      // 模式 l
      state(l2, s(C1), C2)    // 结果 r
    )
    ```
    当系统状态 `T` 中包含子项 `state(l1, s(s(zero)), ...)` 时：
    *   **匹配**: 模式 `l` 匹配该状态子项。
    *   **替换 `σ`**: `σ = {C1 ↦ s(s(zero)), C2 ↦ ...}`。
    *   **资源约束满足**: `codom(σ)` 中的项 `s(s(zero))` 等，因其就是被匹配的子项，天然存在于 `GroundSub(T)` 中。
    *   **新项生成**: 规则右侧 `σ(r)` 被实例化为 `state(l2, s(s(s(zero))), ...)`。这里的关键在于，项 `s(s(s(zero)))` 是一个**新创建的项**。它是通过将构造器 `s` 应用于已存在于资源池 `GroundSub(T)` 中的项 `s(s(zero))` 而得到的。
    *   **演化**: `T` 被重写，新的状态项替换旧的，从而 `s(s(s(zero)))` 成为新状态 `T'` 的一部分，可用于未来的计算。

4.  **模拟 `DEC C1` 和 `JZERO C1`**:
    *   `DEC`: 规则 `rewrite(state(L, s(C1), C2), state(L_next, C1, C2))` 可实现减一。
    *   `JZERO`: 可通过两条规则实现条件分支，一条匹配 `state(L, zero, C2)`，另一条匹配 `state(L, s(C_val), C2)`。

由于 System M 能够表示任意数据结构（状态）、实现条件分支（多条规则）并通过**组合性生成**机制创建无限的结构（Peano数，模拟无限纸带），它满足了图灵完备计算所需的所有条件。

## **4. 总结**

*   **表达能力边界**: System M 是一个**图灵完备的、自反的计算框架**。其模型可精确描述为一种**受资源限制的、模动态等价理论的重写系统**。
*   **与逻辑系统的关系**: 它内在地包含并超越了传统的一阶等式逻辑和重写逻辑，其核心优势在于**动态性**和**自反性**。
*   **图灵完备性来源**: 其图灵完备性并非来自外部扩展，而是源于其基本定义中的**组合性生成**能力，即利用已有项作为“积木”来构建新项。
*   **理论价值**: `codom(σ) ⊆ GroundSub(T)` 这一独特约束为研究**资源敏感计算 (resource-aware computation)**、**化学计算模型 (chemical abstract machine)** 和**自组织系统 (self-organizing systems)** 提供了一个新颖且强大的形式化工具。
