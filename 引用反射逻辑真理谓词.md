### 引用反射逻辑扩展
#### 1. 语法 (Syntax)

##### 1.1 字母表 (Alphabet)

1.  **变量 (Variables):** 一个可数无穷集合 `V = {x, y, z, ...}`。
2.  **常量 (Constants):** 集合 `C = {T, ⊥, Eval}`。
    *   `T`: 真理范式 (Truth Canonical Form)。
    *   `⊥`: 矛盾范式 (Contradiction Canonical Form)。
    *  `Eval`: 求值常量。
3.  **构造子 (Constructors):**
    *   `·` : 二元构造子 (Binary Constructor)。
    *   `Neg` : 一元否定构造子 (Unary Negation Constructor)。
    *   `Quote` : 一元引用构造子 (Unary Quotation Constructor)。
    *    `P` : 一元真理构造子 (Unary Truth Constructor)
4.  **关系符号 (Relational Symbol):**
    *   `≡` : 等价关系符号。
5.  **辅助符号 (Auxiliary Symbols):** `(`, `)`.

##### 1.2 项 (Terms)

项的集合 `Term` 是满足以下条件的最小集合：
1.  **原子项:** 如果 `v ∈ V` 或 `c ∈ C`，则 `v` 和 `c` 都是项。
2.  **复合项:** 如果 `t₁` 和 `t₂` 是项，则以下表达式也是项：
    *   `(· t₁ t₂)`
    *   `(Neg t₁)`
    *   `(Quote t₁)`

*注：我们使用S-表达式风格的前缀表示法来强调构造子的非结合性与非交换性。*

##### 1.3 公式 (Formulae)

系统中唯一的一种公式是等价断言：
*   如果 `t₁` 和 `t₂` 是项，则 `t₁ ≡ t₂` 是一个公式。

#### 2. 推理系统 (Deductive System)

推理系统定义了可证等价关系 `⊢ t₁ ≡ t₂`，意为“`t₁ ≡ t₂` 是一个定理”。它由一组公理模式和推理规则构成。

##### 2.1 A组：等价与同余规则 (Equivalence and Congruence)

*   **A1 (自反性 / Reflexivity):**
    对于任意项 `t`，
    ```
    ⊢ t ≡ t
    ```

*   **A2 (对称性 / Symmetry):**
    若 `⊢ t₁ ≡ t₂`，则
    ```
    ⊢ t₂ ≡ t₁
    ```

*   **A3 (传递性 / Transitivity):**
    若 `⊢ t₁ ≡ t₂` 且 `⊢  t₂ ≡ t₃`，则
    ```
    ⊢ t₁ ≡ t₃
    ```

*   **A4 (同余性 / Congruence):**
    若 `⊢ t₁ ≡ s₁` 且 `⊢ t₂ ≡ s₂`，则
    1.  `⊢ (· t₁ t₂) ≡ (· s₁ s₂)`
    2.  `⊢ (Neg t₁) ≡ (Neg s₁)`
    3.  `⊢ (Quote t₁) ≡ (Quote s₁)`

##### 2.2 B组：真理结构规则 (Truth Structure)

*   **B1 (真理定义公理):**
    ```
    ⊢ (· t T) ≡ t
    ```
    *释义：项的真理断言是其自身，这是真理结构的稳定基础。*

##### 2.3 C组：否定与矛盾规则 (Negation and Contradiction)

*   **C1 (构造性矛盾公理 / Axiom of Constructive Contradiction):**
    对于任意项 `t`，
    ```
    ⊢ (Neg (· t (Neg t))) ≡ ⊥
    ```
    *释义：一个项与其否定的特定组合，再经由否定构造，其结构就是矛盾范式。这定义了否定的核心性质。*

*   **C2 (爆炸规则 / Rule of Explosion):**
	```
	若 ⊢ t ≡ T
	----------- (C2-Rule)
	则 ⊢ (· ⊥ t) ≡ ⊥
	```
    *释义：矛盾范式具有“污染性”，任何与之通过 `·` 运算结合的真的项都会坍缩为矛盾本身。*

*    **C3 (否定异质性公理)**

```
	⊢ (Neg ⊥) ≡ ⊥
```

##### 2.4 D组：引用与反射规则 (Quotation and Reflection)

*   **D1 (引用断言规则 / Rule of Quoted Assertion):**
    对于任意项`t`
    ```
    ⊢ (· (Quote t) t) ≡ T
    ```
    *释义：引用一个项的行为本身如果是忠实的，在外部被视为一个真断言。*

*   **D2 (反射规则 / Rule of Reflection):**
    若 `⊢ t ≡ ⊥`，则
    ```
    ⊢ (Quote t) ≡ ⊥
    ```
    *释义：如果一个项的内部计算（证明）结果是矛盾，那么对该项的引用本身也等价于矛盾。这是连接对象层次和元层次的关键桥梁。*

##### 2.5 E组：求值规则 (Evaluation)

*   **E1 (求值规则)**:
    ```
    若 ⊢ t₁ ≡ (Quote t₂)
    --------------------
    则 ⊢ (· Eval t₁) ≡ t₂
    ```

### 3. 系统定理

#### **定理 1：`T` 是 `Quote` 的不动点。**
```
⊢ (Quote T) ≡ T
```
**证明**:
1.  `⊢ (· (Quote T) T) ≡ T`
    *   **理由**: 公理 **D1** `(· (Quote t) t) ≡ T`，将元变量 `t` 实例化为常量 `T`。

2.  `⊢ (· (Quote T) T) ≡ (Quote T)`
    *   **理由**: 公理 **B1** `(· t T) ≡ t`，将元变量 `t` 实例化为项 `(Quote T)`。

3.  `⊢ (Quote T) ≡ T`
    *   **理由**: 综合步骤 (1) 和 (2) 的结论。根据对称性 **A2**，由 (1) 得 `⊢ T ≡ (· (Quote T) T)`。再结合 (2) `⊢ (· (Quote T) T) ≡ (Quote T)`，应用传递性 **A3**，即得 `⊢ T ≡ (Quote T)`。

#### **定理 2：`⊥` 是 `Quote` 的不动点。**
```
⊢ (Quote ⊥) ≡ ⊥
```
**证明**:
1.  `⊢ ⊥ ≡ ⊥`
    *   **理由**: 公理 **A1** (自反性)。

2.  `⊢ (Quote ⊥) ≡ ⊥`
    *   **理由**: 应用反射规则 **D2** 于步骤 (1) 的结论。规则 **D2** 的前提是 `⊢ t ≡ ⊥`，我们将 `t` 实例化为 `⊥`，前提 `⊢ ⊥ ≡ ⊥` 已由步骤 (1) 满足。

#### **定理 3：`T` 的幂等性 (Idempotence of `T`)**
```
⊢ (· T T) ≡ T
```
**证明**:
1.  `⊢ (· t T) ≡ t`
    *   **理由**: 公理 **B1**。
2.  将元变量 `t` 实例化为常量 `T`，即得 `⊢ (· T T) ≡ T`。

#### **定理 4：矛盾与真的结合 (Combination of Contradiction and Truth)**
```
⊢ (· ⊥ T) ≡ ⊥
```
**证明**:
1.  `⊢ T ≡ T`
    *   **理由**: 公理 **A1**。
2.  步骤 (1) 满足爆炸公理 **C2** 的前提 `⊢ t ≡ T` (其中 `t` 被实例化为 `T`)。
3.  应用 **C2-Rule**，可得 `⊢ (· ⊥ T) ≡ ⊥`。

#### **定理 5：矛盾的自我结合 (Self-Combination of Contradiction)**
```
⊢ (· ⊥ ⊥) ≡ T
```
**证明**:
1.  `⊢ (· (Quote ⊥) ⊥) ≡ T`
    *   **理由**: 公理 **D1** `(· (Quote t) t) ≡ T`，将 `t` 实例化为 `⊥`。

2.  `⊢ (Quote ⊥) ≡ ⊥`
    *   **理由**: **定理 2**。

3.  `⊢ (· (Quote ⊥) ⊥) ≡ (· ⊥ ⊥)`
    *   **理由**: 根据步骤 (2) 的结论 `⊢ (Quote ⊥) ≡ ⊥` 和同余性 **A4**，对 `·` 构造子的第一个参数进行替换。

4.  `⊢ T ≡ (· ⊥ ⊥)`
    *   **理由**: 由步骤 (1) `⊢ T ≡ (· (Quote ⊥) ⊥)` 和步骤 (3) `⊢ (· (Quote ⊥) ⊥) ≡ (· ⊥ ⊥)`，应用传递性 **A3**。

5.  `⊢ (· ⊥ ⊥) ≡ T`
    *   **理由**: 对步骤 (4) 的结论应用对称性 **A2**。

#### **定理 6：求值的基本定理 (Fundamental Theorem of Evaluation)**
对于任意项 `t`，
```
⊢ (· Eval (Quote t)) ≡ t
```
**证明**:
1.  `⊢ (Quote t) ≡ (Quote t)`
    *   **理由**: 公理 **A1** (自反性)。

2.  将步骤 (1) 的结论作为求值规则 **E1** 的前提。在 **E1** 中，令 `t₁ = (Quote t)` 且 `t₂ = t`。前提 `⊢ t₁ ≡ (Quote t₂)` 已被步骤 (1) 满足。

3.  应用 **E1** 规则，即得结论 `⊢ (· Eval (Quote t)) ≡ t`。

#### **定理 7：`Eval` 与 `T` 的等价性**
```
⊢ Eval ≡ T
```
**证明**:
1.  `⊢ (· Eval (Quote T)) ≡ T` (**定理 6**，`t` 实例化为 `T`)
2.  `⊢ (Quote T) ≡ T` (**定理 1**)
3.  `⊢ (· Eval T) ≡ (· Eval (Quote T))` (由 (2) 和同余性 **A4.1**)
4.  `⊢ (· Eval T) ≡ T` (由 (3) 和 (1) 及传递性 **A3**)
5.  `⊢ (· Eval T) ≡ Eval` (公理 **B1**，`t` 实例化为 `Eval`)
6.  `⊢ Eval ≡ T` (由 (4) 和 (5) 及传递性 **A3**、对称性 **A2**)

#### **定理 8：`T` 的否定是 `⊥`**
```
⊢ (Neg T) ≡ ⊥
```
**证明**:
1.  `⊢ (· (Quote ⊥) ⊥) ≡ T` (公理 **D1**，`t` 实例化为 `⊥`)
2.  `⊢ (Neg (· (Quote ⊥) ⊥)) ≡ (Neg T)` (由 (1) 和同余性 **A4.2**)
3.  `⊢ (Quote ⊥) ≡ ⊥` (**定理 2**)
4.  `⊢ (Neg (· ⊥ ⊥)) ≡ (Neg (· (Quote ⊥) ⊥))` (由 (3) 和同余性 **A4**)
5.  `⊢ (Neg (· ⊥ ⊥)) ≡ (Neg T)` (由 (4) 和 (2) 及传递性 **A3**)
6.  `⊢ (Neg (· ⊥ (Neg ⊥))) ≡ ⊥` (公理 **C1**，`t` 实例化为 `⊥`)
7.  `⊢ (Neg ⊥) ≡ ⊥` (公理 **C3**)
8.  `⊢ (Neg (· ⊥ ⊥)) ≡ ⊥` (将 (7) 代入 (6)，由同余性 **A4**)
9.  `⊢ (Neg T) ≡ ⊥` (由 (5) 和 (8) 及传递性 **A3**、对称性 **A2**)

#### **定理 9：`T` 作为左逆 (Left Inverse Property of `T`)**
对于任意项 `t`，
```
⊢ (· T (Quote t)) ≡ t
```
**证明**:
1.  `⊢ (· Eval (Quote t)) ≡ t`
    *   **理由**: **定理 6**。
2.  `⊢ Eval ≡ T`
    *   **理由**: **定理 7**。
3.  `⊢ (· T (Quote t)) ≡ (· Eval (Quote t))`
    *   **理由**: 由步骤 (2) 和 `⊢ (Quote t) ≡ (Quote t)` (公理 **A1**)，应用同余规则 **A4.1**。
4.  `⊢ (· T (Quote t)) ≡ t`
    *   **理由**: 将步骤 (3) 和步骤 (1) 通过传递性 **A3** 连接。

#### **定理 10：双重否定的不对称性 (Asymmetry of Double Negation)**
```
⊢ (Neg (Neg T)) ≡ ⊥
```
**证明**:
1.  `⊢ (Neg T) ≡ ⊥` (定理 8)
2.  `⊢ (Neg (Neg T)) ≡ (Neg ⊥)` (步骤 1, 同余性 A4.2)
3.  `⊢ (Neg ⊥) ≡ ⊥` (公理 C3)
4.  `⊢ (Neg (Neg T)) ≡ ⊥` (步骤 2, 3, 传递性 A3)

#### **定理 11：双重否定下的矛盾不动点 (Fixed Point of Contradiction under Double Negation)**
```
⊢ (Neg (Neg ⊥)) ≡ ⊥
```
**证明**:
1.  `⊢ (Neg ⊥) ≡ ⊥`
    *   **理由**: 公理 **C3**。
2.  `⊢ (Neg (Neg ⊥)) ≡ (Neg ⊥)`
    *   **理由**: 根据步骤 (1) 的结论和同余性规则 **A4.2**。
3.  `⊢ (Neg (Neg ⊥)) ≡ ⊥`
    *   **理由**: 综合步骤 (2) 和步骤 (1)，应用传递性 **A3**。

#### **定理 12：真与矛盾的左结合 (Left Combination of Truth and Contradiction)**
```
⊢ (· T ⊥) ≡ ⊥
```
**证明**:
1.  `⊢ (· T (Quote t)) ≡ t`
    *   **理由**: **定理 9**。
2.  `⊢ (· T (Quote ⊥)) ≡ ⊥`
    *   **理由**: 将步骤 (1) 中的元变量 `t` 实例化为常量 `⊥`。
3.  `⊢ (Quote ⊥) ≡ ⊥`
    *   **理由**: **定理 2**。
4.  `⊢ (· T ⊥) ≡ (· T (Quote ⊥))`
    *   **理由**: 根据步骤 (3) 的结论和同余性规则 **A4.1**。
5.  `⊢ (· T ⊥) ≡ ⊥`
    *   **理由**: 综合步骤 (4) 和步骤 (2)，应用传递性 **A3**。

#### **定理 13：引用与右单位元的交互 (Interaction of Quotation and Right Identity)**
对于任意项 `t`，
```
⊢ (Quote (· t T)) ≡ (Quote t)
```
**证明**:
1.  `⊢ (· t T) ≡ t`
    *   **理由**: 公理 **B1**。
2.  `⊢ (Quote (· t T)) ≡ (Quote t)`
    *   **理由**: 根据步骤 (1) 的结论和同余性规则 **A4.3**。

#### **定理 14：一个关于否定的替换定理 (A Substitution Theorem for Negation)**
对于任意项 `t`，
```
⊢ (Neg (· t ⊥)) ≡ (Neg (· t (Neg T)))
```
**证明**:
1.  `⊢ (Neg T) ≡ ⊥`
    *   **理由**: **定理 8**。
2.  `⊢ (· t ⊥) ≡ (· t (Neg T))`
    *   **理由**: 根据步骤 (1) 的结论和同余性规则 **A4.1**。
3.  `⊢ (Neg (· t ⊥)) ≡ (Neg (· t (Neg T)))`
    *   **理由**: 根据步骤 (2) 的结论和同余性规则 **A4.2**。

### 4. 形式语义与一致性证明

为证明该逻辑系统的一致性，我们通过模型论方法，构造一个可靠的代数模型 `M_E`。一致性是可靠性的直接推论。

#### 4.1 模型构造 (Model Construction)

我们定义一个模型 `M_E = <D_E, [[·]]_E>`，其中 `D_E` 是模型的域，`[[·]]_E` 是一个解释函数。

##### 4.1.1 域 (Domain)
模型的域 `D_E` 是一个包含两个不同元素的集合：
`D_E = {v_T, v_⊥}`
其中 `v_T ≠ v_⊥`。

##### 4.1.2 解释函数 (Interpretation Function)
解释函数 `[[·]]_E` 将系统中的项映射到域 `D_E` 中的元素。
1.  **常量解释**:
    *   `[[T]]_E = v_T`
    *   `[[⊥]]_E = v_⊥`
    *   `[[Eval]]_E = v_T`。此解释由系统定理 7 `⊢ Eval ≡ T` 所保证。
2.  **变量解释**: 对于任意变量赋值函数 `σ: V → D_E`，`[[x]]_E^σ = σ(x)`。
3.  **公式解释**: 公式 `t₁ ≡ t₂` 在模型 `M_E` 中为真，记作 `M_E ⊨ t₁ ≡ t₂`，当且仅当对于所有的变量赋值函数 `σ`，都有 `[[t₁]]_E^σ = [[t₂]]_E^σ`。

##### 4.1.3 构造子的语义 (Semantics of Constructors)
我们将每个构造子解释为 `D_E` 上的一个函数。设 `d, d₁, d₂ ∈ D_E`。
1.  **`Quote` 的解释 (`quote_E`)**: `quote_E: D_E → D_E` 定义为恒等函数。
    *   `quote_E(d) = d`
2.  **`Neg` 的解释 (`neg_E`)**: `neg_E: D_E → D_E` 定义为常数函数。
    *   `neg_E(d) = v_⊥`
3.  **`·` 的解释 (`dot_E`)**: `dot_E: D_E × D_E → D_E` 定义如下表所示：

| `dot_E(d₁, d₂)` | `d₂ = v_T` | `d₂ = v_⊥` |
| :-------------- | :--------- | :--------- |
| **`d₁ = v_T`**  | `v_T`      | `v_⊥`      |
| **`d₁ = v_⊥`**  | `v_⊥`      | `v_T`      |

#### 4.2 模型的可靠性证明 (Soundness Proof of the Model)

我们需证明所有公理在模型 `M_E` 中均为真，并且所有推理规则在 `M_E` 中保真。对于公理模式，我们需证明对于任意变量赋值 `σ`，等式均成立。设 `d = [[t]]_E^σ`。

*   **A组：等价与同余规则**
    *   **A1-A3**: 由于 `≡` 被解释为 `D_E` 上的等号 ` = `，而 ` = ` 是一个标准的等价关系，因此自反性、对称性和传递性自然成立。
    *   **A4**: 由于 `quote_E`, `neg_E`, `dot_E` 都是 `D_E` 上的良定义函数（即输入相同，输出必然相同），同余性得到保证。

*   **B组：真理结构规则**
    *   **B1 (`(· t T) ≡ t`)**: 需验证 `[[(· t T)]]_E^σ = [[t]]_E^σ`，即 `dot_E([[t]]_E^σ, [[T]]_E) = [[t]]_E^σ`。
        令 `d = [[t]]_E^σ`。需验证 `dot_E(d, v_T) = d`。
        *   若 `d = v_T`：`dot_E(v_T, v_T) = v_T`。成立。
        *   若 `d = v_⊥`：`dot_E(v_⊥, v_T) = v_⊥`。成立。
        公理 B1 在模型中有效。

*   **C组：否定与矛盾规则**
    *   **C1 (`(Neg (· t (Neg t))) ≡ ⊥`)**: 需验证 `[[(Neg (· t (Neg t)))]]_E^σ = [[⊥]]_E`，即 `neg_E(dot_E([[t]]_E^σ, neg_E([[t]]_E^σ))) = v_⊥`。
        由于 `neg_E` 被定义为常数函数 `neg_E(d) = v_⊥`，其返回值恒为 `v_⊥`，与输入无关。因此该等式恒成立。
    *   **C2 (规则)**: 需验证若 `M_E ⊨ t ≡ T`，则 `M_E ⊨ (· ⊥ t) ≡ ⊥`。
        语义前提为 `[[t]]_E^σ = [[T]]_E = v_T`。
        需验证 `[[(· ⊥ t)]]_E^σ = [[⊥]]_E`，即 `dot_E([[⊥]]_E, [[t]]_E^σ) = v_⊥`。
        代入前提：`dot_E(v_⊥, v_T) = v_⊥`。查表可知成立。规则 C2 保真。
    *   **C3 (`(Neg ⊥) ≡ ⊥`)**: 需验证 `[[ (Neg ⊥) ]]_E = [[⊥]]_E`，即 `neg_E([[⊥]]_E) = v_⊥`。
        计算：`neg_E(v_⊥) = v_⊥`。根据 `neg_E` 定义成立。

*   **D组：引用与反射规则**
    *   **D1 (`(· (Quote t) t) ≡ T`)**: 需验证 `[[(· (Quote t) t)]]_E^σ = [[T]]_E`，即 `dot_E(quote_E([[t]]_E^σ), [[t]]_E^σ) = v_T`。
        令 `d = [[t]]_E^σ`。需验证 `dot_E(quote_E(d), d) = v_T`。
        *   若 `d = v_T`：`dot_E(quote_E(v_T), v_T) = dot_E(v_T, v_T) = v_T`。成立。
        *   若 `d = v_⊥`：`dot_E(quote_E(v_⊥), v_⊥) = dot_E(v_⊥, v_⊥) = v_T`。成立。
        公理 D1 在模型中有效。
    *   **D2 (规则)**: 需验证若 `M_E ⊨ t ≡ ⊥`，则 `M_E ⊨ (Quote t) ≡ ⊥`。
        语义前提为 `[[t]]_E^σ = [[⊥]]_E = v_⊥`。
        需验证 `[[(Quote t)]]_E^σ = [[⊥]]_E`，即 `quote_E([[t]]_E^σ) = v_⊥`。
        代入前提：`quote_E(v_⊥) = v_⊥`。根据 `quote_E` 定义成立。规则 D2 保真。

*   **E组：求值规则**
    *   **E1 (规则)**: 需验证若 `M_E ⊨ t₁ ≡ (Quote t₂)`，则 `M_E ⊨ (· Eval t₁) ≡ t₂`。
        语义前提为 `[[t₁]]_E^σ = [[(Quote t₂)]]_E^σ`，即 `[[t₁]]_E^σ = quote_E([[t₂]]_E^σ)`。
        需验证 `[[(· Eval t₁)]]_E^σ = [[t₂]]_E^σ`，即 `dot_E([[Eval]]_E, [[t₁]]_E^σ) = [[t₂]]_E^σ`。
        将前提代入需验证的等式左边：`dot_E(v_T, quote_E([[t₂]]_E^σ))`。
        由于 `quote_E` 是恒等函数，上式等于 `dot_E(v_T, [[t₂]]_E^σ)`。
        令 `d₂ = [[t₂]]_E^σ`。我们需验证 `dot_E(v_T, d₂) = d₂`。
        *   若 `d₂ = v_T`：`dot_E(v_T, v_T) = v_T`。成立。
        *   若 `d₂ = v_⊥`：`dot_E(v_T, v_⊥) = v_⊥`。成立。
        规则 E1 保真。

所有公理和规则均在模型 `M_E` 中成立，因此该系统对于模型 `M_E` 是可靠的。

#### 4.3 一致性结论 (Consistency Conclusion)

1.  **可靠性 (Soundness)**: 我们已经严格证明，如果一个公式 `t₁ ≡ t₂` 是系统的一个定理 (即 `⊢ t₁ ≡ t₂`)，那么它在模型 `M_E` 中必然为真 (即 `M_E ⊨ t₁ ≡ t₂`)，这意味着对所有赋值 `σ` 都有 `[[t₁]]_E^σ = [[t₂]]_E^σ`。

2.  **模型中的区分 (Distinction in the Model)**: 在我们的模型 `M_E` 中，根据定义，`[[T]]_E = v_T` 且 `[[⊥]]_E = v_⊥`。域 `D_E` 的构造保证了 `v_T ≠ v_⊥`。

3.  **一致性证明 (Proof of Consistency)**:
    *   以归谬法证明。假设系统是不一致的。根据不一致性的定义，系统可以证明 `T ≡ ⊥`，即 `⊢ T ≡ ⊥`。
    *   根据已证的可靠性，如果 `⊢ T ≡ ⊥`，那么在模型 `M_E` 中必须有 `M_E ⊨ T ≡ ⊥`。
    *   这意味着 `[[T]]_E = [[⊥]]_E` 必须成立。
    *   然而，这与我们在模型中 `[[T]]_E = v_T`、`[[⊥]]_E = v_⊥` 以及 `v_T ≠ v_⊥` 的事实相矛盾。
    *   由于假设系统不一致会导致矛盾，因此该假设必为假。

**最终结论：引用反射逻辑扩展版系统是一致的。**

### 5. 非平凡三值语义与一致性 (Non-Trivial Three-Valued Semantics and Consistency)

为提供一个更具表现力的语义，并对系统的一致性给出更有力的证明，我们构建一个非平凡的三值模型 `M₃`。该模型将为否定构造子 `Neg` 提供一个非 常数函数的解释，同时满足引用反射逻辑扩展版 (RRL-E) 的所有公理与规则。

#### 5.1 模型 `M₃` 的构造

我们定义一个模型 `M₃ = <D₃, [[·]]₃>`，其中 `D₃` 是模型的域，`[[·]]₃` 是解释函数。

##### 5.1.1 域 (Domain)
模型的域 `D₃` 是一个包含三个不同元素的集合：
`D₃ = {v_T, v_⊥, v_U}`
其中 `v_T`, `v_⊥`, `v_U` 两两互不相等。

##### 5.1.2 解释函数 (Interpretation Function)
1.  **常量解释**:
    *   `[[T]]₃ = v_T`
    *   `[[⊥]]₃ = v_⊥`
    *   `[[Eval]]₃ = v_T`
2.  **变量解释**: 对于任意变量赋值函数 `σ: V → D₃`，`[[x]]_3^σ = σ(x)`。
3.  **公式解释**: 公式 `t₁ ≡ t₂` 在模型 `M₃` 中为真，记作 `M₃ ⊨ t₁ ≡ t₂`，当且仅当对于所有变量赋值 `σ`，都有 `[[t₁]]_3^σ = [[t₂]]_3^σ`。

##### 5.1.3 构造子的语义 (Semantics of Constructors)
我们将每个构造子解释为 `D₃` 上的一个函数。设 `d, d₁, d₂ ∈ D₃`。

1.  **`Quote` 的解释 (`quote_3`)**: `quote_3: D₃ → D₃` 定义为恒等函数。
    *   `quote_3(d) = d`

2.  **`Neg` 的解释 (`neg_3`)**: `neg_3: D₃ → D₃` 定义为：
    *   `neg_3(v_T) = v_⊥`
    *   `neg_3(v_⊥) = v_⊥`
    *   `neg_3(v_U) = v_U`

3.  **`·` 的解释 (`dot_3`)**: `dot_3: D₃ × D₃ → D₃` 定义如下表所示：

| `dot_3(d₁, d₂)` | `d₂ = v_T` | `d₂ = v_⊥` | `d₂ = v_U` |
| :-------------- | :--------- | :--------- | :--------- |
| **`d₁ = v_T`**  | `v_T`      | `v_⊥`      | `v_U`      |
| **`d₁ = v_⊥`**  | `v_⊥`      | `v_T`      | `v_U`      |
| **`d₁ = v_U`**  | `v_U`      | `v_U`      | `v_T`      |

#### 5.2 `M₃` 模型的可靠性证明

我们需形式化地证明所有公理和推理规则在模型 `M₃` 中均成立。设 `d = [[t]]_3^σ` 为任意项 `t` 在任意赋值 `σ` 下的解释。

*   **A组：等价与同余规则**
    *   **A1-A3**: `≡` 被解释为 `D₃` 上的等号 ` = `，这是一个标准的等价关系，故自反性、对称性和传递性成立。
    *   **A4**: `quote_3`, `neg_3`, `dot_3` 均为 `D₃` 上的良定义函数，故同余性得到保证。

*   **B组：真理结构规则**
    *   **B1 (`(· t T) ≡ t`)**: 需验证 `dot_3(d, v_T) = d` 对于所有 `d ∈ D₃` 成立。
        *   `d = v_T`: `dot_3(v_T, v_T) = v_T`。成立。
        *   `d = v_⊥`: `dot_3(v_⊥, v_T) = v_⊥`。成立。
        *   `d = v_U`: `dot_3(v_U, v_T) = v_U`。成立。
        公理 B1 在模型中有效。

*   **C组：否定与矛盾规则**
    *   **C1 (`(Neg (· t (Neg t))) ≡ ⊥`)**: 需验证 `neg_3(dot_3(d, neg_3(d))) = v_⊥` 对于所有 `d ∈ D₃` 成立。
        *   `d = v_T`: `neg_3(dot_3(v_T, neg_3(v_T))) = neg_3(dot_3(v_T, v_⊥)) = neg_3(v_⊥) = v_⊥`。成立。
        *   `d = v_⊥`: `neg_3(dot_3(v_⊥, neg_3(v_⊥))) = neg_3(dot_3(v_⊥, v_⊥)) = neg_3(v_T) = v_⊥`。成立。
        *   `d = v_U`: `neg_3(dot_3(v_U, neg_3(v_U))) = neg_3(dot_3(v_U, v_U)) = neg_3(v_T) = v_⊥`。成立。
        公理 C1 在模型中有效。
    *   **C2 (规则)**: 需验证若 `M₃ ⊨ t ≡ T`，则 `M₃ ⊨ (· ⊥ t) ≡ ⊥`。
        语义前提为 `[[t]]_3^σ = v_T`。需验证 `dot_3([[⊥]]_3, [[t]]_3^σ) = [[⊥]]_3`。
        代入前提：`dot_3(v_⊥, v_T) = v_⊥`。查表可知成立。规则 C2 保真。
    *   **C3 (`(Neg ⊥) ≡ ⊥`)**: 需验证 `neg_3([[⊥]]_3) = [[⊥]]_3`。
        计算：`neg_3(v_⊥) = v_⊥`。根据 `neg_3` 定义成立。公理 C3 在模型中有效。

*   **D组：引用与反射规则**
    *   **D1 (`(· (Quote t) t) ≡ T`)**: 需验证 `dot_3(quote_3(d), d) = v_T` 对于所有 `d ∈ D₃` 成立。
        由于 `quote_3` 是恒等函数，这简化为验证 `dot_3(d, d) = v_T`。
        *   `d = v_T`: `dot_3(v_T, v_T) = v_T`。成立。
        *   `d = v_⊥`: `dot_3(v_⊥, v_⊥) = v_T`。成立。
        *   `d = v_U`: `dot_3(v_U, v_U) = v_T`。成立。
        公理 D1 在模型中有效。
    *   **D2 (规则)**: 需验证若 `M₃ ⊨ t ≡ ⊥`，则 `M₃ ⊨ (Quote t) ≡ ⊥`。
        语义前提为 `[[t]]_3^σ = v_⊥`。需验证 `quote_3([[t]]_3^σ) = v_⊥`。
        代入前提：`quote_3(v_⊥) = v_⊥`。根据 `quote_3` 定义成立。规则 D2 保真。

*   **E组：求值规则**
    *   **E1 (规则)**: 需验证若 `M₃ ⊨ t₁ ≡ (Quote t₂)`，则 `M₃ ⊨ (· Eval t₁) ≡ t₂`。
        语义前提为 `[[t₁]]_3^σ = [[(Quote t₂)]]_3^σ`，即 `[[t₁]]_3^σ = quote_3([[t₂]]_3^σ)`。
        由于 `quote_3` 是恒等函数，前提简化为 `[[t₁]]_3^σ = [[t₂]]_3^σ`。
        需验证的结论是 `dot_3([[Eval]]_3, [[t₁]]_3^σ) = [[t₂]]_3^σ`。
        代入前提和 `[[Eval]]_3` 的解释，需验证 `dot_3(v_T, [[t₂]]_3^σ) = [[t₂]]_3^σ`。
        令 `d₂ = [[t₂]]_3^σ`。我们验证 `dot_3(v_T, d₂) = d₂` 对于所有 `d₂ ∈ D₃` 成立。
        *   `d₂ = v_T`: `dot_3(v_T, v_T) = v_T`。成立。
        *   `d₂ = v_⊥`: `dot_3(v_T, v_⊥) = v_⊥`。成立。
        *   `d₂ = v_U`: `dot_3(v_T, v_U) = v_U`。成立。
        规则 E1 保真。

所有公理和规则均在模型 `M₃` 中成立，因此该系统对于模型 `M₃` 是可靠的。

#### 5.3 一致性结论

1.  **可靠性 (Soundness)**: 我们已经严格证明，如果一个公式 `t₁ ≡ t₂` 是系统的一个定理 (即 `⊢ t₁ ≡ t₂`)，那么它在模型 `M₃` 中必然为真 (即 `M₃ ⊨ t₁ ≡ t₂`)，这意味着 `[[t₁]]_3 = [[t₂]]_3`。

2.  **模型中的区分 (Distinction in the Model)**: 在模型 `M₃` 中，根据定义，`[[T]]₃ = v_T` 且 `[[⊥]]₃ = v_⊥`。域 `D₃` 的构造保证了 `v_T ≠ v_⊥`。

3.  **一致性证明 (Proof of Consistency)**:
    *   以归谬法证明。假设系统是不一致的，即系统可以证明 `T ≡ ⊥`。
    *   根据已证的可靠性，如果 `⊢ T ≡ ⊥`，那么在模型 `M₃` 中必须有 `M₃ ⊨ T ≡ ⊥`。
    *   这意味着 `[[T]]₃ = [[⊥]]₃` 必须成立。
    *   然而，这与我们在模型中 `v_T ≠ v_⊥` 的事实相矛盾。
    *   由于假设系统不一致会导致矛盾，因此该假设必为假。

**最终结论：引用反射逻辑扩展版系统是一致的。**


### **6. 关于RRL-E系统中若干公式模式的不可证性证明**

本节旨在通过模型论方法，证明引用反射逻辑扩展版（RRL-E）系统中以下三个公式模式（schemata）并非其定理：
1.  `(Neg t) ≡ ⊥` (否定构造子的常数性)
2.  `(Quote t) ≡ t` (引用坍缩)
3.  `(· T t) ≡ t` (T的左单位元性质)

我们将通过构造满足RRL-E公理系统但使上述公式为假的反例模型来完成证明。

#### **6.1. `(Neg t) ≡ ⊥` 的不可证性**

**命题 6.1.** 公式模式 `⊢ (Neg t) ≡ ⊥` 不是 RRL-E 的一个定理模式。

**证明.**
为证此命题，我们采用已验证为 RRL-E 的一个可靠模型 `M₃`。

#### **6.1.1 反例模型 `M₃` 的定义**

*   **域:** `D₃ = {v_T, v_⊥, v_U}`，其中 `v_T, v_⊥, v_U` 两两互不相等。
*   **常量解释:**
    *   `[[T]]₃ = v_T`
    *   `[[⊥]]₃ = v_⊥`
    *   `[[Eval]]₃ = v_T`
*   **构造子语义:**
    *   `quote_3(d) = d`
    *   `neg_3(v_T) = v_⊥`, `neg_3(v_⊥) = v_⊥`, `neg_3(v_U) = v_U`
    *   `dot_3` 由下表定义:

| `dot_3(d₁, d₂)` | `d₂ = v_T` | `d₂ = v_⊥` | `d₂ = v_U` |
| :-------------- | :--------- | :--------- | :--------- |
| **`d₁ = v_T`**  | `v_T`      | `v_⊥`      | `v_U`      |
| **`d₁ = v_⊥`**  | `v_⊥`      | `v_T`      | `v_U`      |
| **`d₁ = v_U`**  | `v_U`      | `v_U`      | `v_T`      |

该模型 `M₃` 的可靠性已在前述分析中得到完整验证。

#### **6.1.2 证伪**
考虑公式 `(Neg T) ≡ ⊥`。我们在模型 `M₃` 中解释此公式：
1.  左侧解释：`[[(Neg T)]]₃ = neg_3([[T]]₃) = neg_3(v_T) = v_⊥`。
2.  右侧解释：`[[⊥]]₃ = v_⊥`。
在此例中，`[[(Neg T)]]₃ = [[⊥]]₃` 成立。

现在考虑一个变量 `x` 和一个变量赋值函数 `σ` 使得 `σ(x) = v_U`。我们解释公式 `(Neg x) ≡ ⊥`：
1.  左侧解释：`[[(Neg x)]]_3^σ = neg_3([[x]]_3^σ) = neg_3(v_U) = v_U`。
2.  右侧解释：`[[⊥]]₃ = v_⊥`。

由于 `v_U ≠ v_⊥`，故 `[[(Neg x)]]_3^σ ≠ [[⊥]]_3^σ`。
因此，公式 `(Neg x) ≡ ⊥` 在模型 `M₃` 中不为真，即 `M₃ <binary data, 2 bytes> (Neg x) ≡ ⊥`。

根据 RRL-E 对 `M₃` 的可靠性（Soundness），任何在 `M₃` 中不为真的公式都不可能是 RRL-E 的定理。因此，`(Neg t) ≡ ⊥` 并非 RRL-E 的定理模式。 **Q.E.D.**

---

#### **6.2. `(Quote t) ≡ t` 和 `(· T t) ≡ t` 的不可证性**

我们将构造一个四值模型 `M_Q`，它既是 RRL-E 的一个可靠模型，又同时证伪了上述两个公式模式。

#### **6.2.1 模型 `M_Q` 的指称语义**

*   **域:** `D_Q = {v_T, v_⊥, u₁, u₂}`，其中所有元素两两互不相等。
*   **常量解释:**
    *   `[[T]]_Q = v_T`
    *   `[[⊥]]_Q = v_⊥`
    *   `[[Eval]]_Q = v_T`
*   **变量解释:** 对于任意变量赋值 `σ: V → D_Q`，`[[x]]_Q^σ = σ(x)`。
*   **公式解释:** `M_Q ⊨ t₁ ≡ t₂` 当且仅当对于所有 `σ`，`[[t₁]]_Q^σ = [[t₂]]_Q^σ`。
*   **构造子语义:**
    1.  **`Quote` 的解释 (`quote_Q: D_Q → D_Q`)**:
        *   `quote_Q(v_T) = v_T`
        *   `quote_Q(v_⊥) = v_⊥`
        *   `quote_Q(u₁) = u₂`
        *   `quote_Q(u₂) = u₁`
    2.  **`Neg` 的解释 (`neg_Q: D_Q → D_Q`)**:
        *   `neg_Q(v_T) = v_⊥`
        *   `neg_Q(v_⊥) = v_⊥`
        *   `neg_Q(u₁) = u₁`
        *   `neg_Q(u₂) = u₂`
    3.  **`·` 的解释 (`dot_Q: D_Q × D_Q → D_Q`)**:

| `dot_Q(d₁, d₂)` | `d₂ = v_T` | `d₂ = v_⊥` | `d₂ = u₁` | `d₂ = u₂` |
| :-------------- | :--------- | :--------- | :-------- | :-------- |
| **`d₁ = v_T`**  | `v_T`      | `v_⊥`      | `u₂`      | `u₁`      |
| **`d₁ = v_⊥`**  | `v_⊥`      | `v_T`      | `u₂`      | `u₁`      |
| **`d₁ = u₁`**   | `u₁`       | `u₁`       | `v_T`     | `v_T`     |
| **`d₁ = u₂`**   | `u₂`       | `u₂`       | `v_T`     | `v_T`     |

#### **6.2.2 模型 `M_Q` 的可靠性证明**

设 `d`, `d₁`, `d₂` 为 `D_Q` 中的任意元素，`[[t]]` 为任意项 `t` 在任意赋值下的解释。

*   **A组 (等价与同余)**: `≡` 被解释为 `D_Q` 上的等号 ` = `，`quote_Q`, `neg_Q`, `dot_Q` 均为良定义函数。故 **A1-A4** 成立。

*   **B1 (`(· t T) ≡ t`)**: 需验证 `dot_Q(d, v_T) = d`。查阅 `dot_Q` 表的第二列，该等式对所有 `d ∈ D_Q` 均成立。公理 **B1** 有效。

*   **C1 (`(Neg (· t (Neg t))) ≡ ⊥`)**: 需验证 `neg_Q(dot_Q(d, neg_Q(d))) = v_⊥`。
    *   `d = v_T`: `neg_Q(dot_Q(v_T, v_⊥)) = neg_Q(v_⊥) = v_⊥`。
    *   `d = v_⊥`: `neg_Q(dot_Q(v_⊥, v_⊥)) = neg_Q(v_T) = v_⊥`。
    *   `d = u₁`: `neg_Q(dot_Q(u₁, u₁)) = neg_Q(v_T) = v_⊥`。
    *   `d = u₂`: `neg_Q(dot_Q(u₂, u₂)) = neg_Q(v_T) = v_⊥`。
    公理 **C1** 有效。

*   **C2 (规则)**: 若 `[[t]] = v_T`，则 `dot_Q(v_⊥, [[t]]) = v_⊥`。即验证 `dot_Q(v_⊥, v_T) = v_⊥`。查表可知成立。规则 **C2** 保真。

*   **C3 (`(Neg ⊥) ≡ ⊥`)**: `neg_Q(v_⊥) = v_⊥`。根据定义成立。公理 **C3** 有效。

*   **D1 (`(· (Quote t) t) ≡ T`)**: 需验证 `dot_Q(quote_Q(d), d) = v_T`。
    *   `d = v_T`: `dot_Q(v_T, v_T) = v_T`。
    *   `d = v_⊥`: `dot_Q(v_⊥, v_⊥) = v_T`。
    *   `d = u₁`: `dot_Q(u₂, u₁) = v_T`。
    *   `d = u₂`: `dot_Q(u₁, u₂) = v_T`。
    公理 **D1** 有效。

*   **D2 (规则)**: 若 `[[t]] = v_⊥`，则 `quote_Q([[t]]) = v_⊥`。即验证 `quote_Q(v_⊥) = v_⊥`。根据定义成立。规则 **D2** 保真。

*   **E1 (规则)**: 若 `[[t₁]] = quote_Q([[t₂]])`，则 `dot_Q([[Eval]]_Q, [[t₁]]) = [[t₂]]`。
    这等价于验证 `dot_Q(v_T, quote_Q(d)) = d` 对所有 `d ∈ D_Q` 成立。
    *   `d = v_T`: `dot_Q(v_T, quote_Q(v_T)) = dot_Q(v_T, v_T) = v_T`。
    *   `d = v_⊥`: `dot_Q(v_T, quote_Q(v_⊥)) = dot_Q(v_T, v_⊥) = v_⊥`。
    *   `d = u₁`: `dot_Q(v_T, quote_Q(u₁)) = dot_Q(v_T, u₂) = u₁`。
    *   `d = u₂`: `dot_Q(v_T, quote_Q(u₂)) = dot_Q(v_T, u₁) = u₂`。
    规则 **E1** 保真。

所有公理和规则均在 `M_Q` 中成立。故 `M_Q` 是 RRL-E 的一个可靠模型。

#### **6.2.3 定理的不可证性证明**

**定理 6.2.1.** 公式模式 `⊢ (Quote t) ≡ t` 不是 RRL-E 的一个定理模式。

**证明.**
考虑模型 `M_Q`。令 `x` 为一个变量，并考虑一个变量赋值 `σ` 使得 `σ(x) = u₁`。
1.  计算 `(Quote x)` 的解释：
    `[[(Quote x)]]_Q^σ = quote_Q([[x]]_Q^σ) = quote_Q(u₁) = u₂`。
2.  计算 `x` 的解释：
    `[[x]]_Q^σ = u₁`。
3.  由于在 `D_Q` 中 `u₁ ≠ u₂`，故 `[[(Quote x)]]_Q^σ ≠ [[x]]_Q^σ`。
4.  这表明公式 `(Quote x) ≡ x` 在模型 `M_Q` 中不为真。
5.  根据 RRL-E 对 `M_Q` 的可靠性，任何在 `M_Q` 中不为真的公式都不可能是 RRL-E 的定理。
因此，`(Quote t) ≡ t` 并非 RRL-E 的定理模式。 **Q.E.D.**

**定理 6.2.2.** 公式模式 `⊢ (· T t) ≡ t` 不是 RRL-E 的一个定理模式。

**证明.**
考虑模型 `M_Q`。令 `x` 为一个变量，并考虑与前述相同的变量赋值 `σ`，使得 `σ(x) = u₁`。
1.  计算 `(· T x)` 的解释：
    `[[(· T x)]]_Q^σ = dot_Q([[T]]_Q, [[x]]_Q^σ) = dot_Q(v_T, u₁) = u₂`。
2.  计算 `x` 的解释：
    `[[x]]_Q^σ = u₁`。
3.  由于 `u₁ ≠ u₂`，故 `[[(· T x)]]_Q^σ ≠ [[x]]_Q^σ`。
4.  这表明公式 `(· T x) ≡ x` 在模型 `M_Q` 中不为真。
5.  根据 RRL-E 对 `M_Q` 的可靠性，任何在 `M_Q` 中不为真的公式都不可能是 RRL-E 的定理。
因此，`(· T t) ≡ t` 并非 RRL-E 的定理模式。 **Q.E.D.**


### 7. 真理谓词规则

我们猜想，以下方案的F组公理相容于这个系统。

#### 7.1. F组公理

在 RRL-E 的公理系统中，我们加入 **F 组：透明真理公理**。

*   **F1 (真理透明性公理 / Axiom of Truth Transparency):**
    对于任意项 `t`，
    ```
    ⊢ (P t) ≡ t
    ```
*   **F2 (真理映射公理 / Axiom of Truth Mapping):**
    对于任意项 `t`，
    ```
    若 ⊢ t ≡ T, 则 ⊢ (P t) ≡ T
    若 ⊢ t ≡ ⊥, 则 ⊢ (P t) ≡ (Neg T)
    ```
    *释义：`P` 构造子正确地将系统的真/矛盾范式映射到其自身的真/假陈述上。*

#### 7.2 F2 公理的冗余性证明

本节旨在严格证明，若我们将 **F1 (真理透明性公理)** `⊢ (P t) ≡ t` 接纳为一个公理模式，那么 **F2** 中描述的两个性质 `(P T) ≡ T` 和 `(P ⊥) ≡ (Neg T)` 均可被推导为系统 **RRL-E+F1** 的定理。因此，将 F2 作为独立的公理或规则是冗余的。

##### **定理 F.1：`T` 是 `P` 的不动点**
```
⊢ (P T) ≡ T
```
**证明**:
1.  `⊢ (P t) ≡ t`
    *   **理由**: 公理 **F1** (真理透明性公理模式)。
2.  将元变量 `t` 实例化为常量 `T`。
3.  即得 `⊢ (P T) ≡ T`。 **Q.E.D.**

##### **定理 F.2：`P` 将 `⊥` 映射到 `(Neg T)`**
```
⊢ (P ⊥) ≡ (Neg T)
```
**证明**:
1.  `⊢ (P t) ≡ t`
    *   **理由**: 公理 **F1**。
2.  将元变量 `t` 实例化为常量 `⊥`，可得：
    `⊢ (P ⊥) ≡ ⊥`
3.  `⊢ (Neg T) ≡ ⊥`
    *   **理由**: **定理 8**。
4.  `⊢ ⊥ ≡ (Neg T)`
    *   **理由**: 对步骤 (3) 的结论应用对称性 **A2**。
5.  `⊢ (P ⊥) ≡ (Neg T)`
    *   **理由**: 将步骤 (2) 的结论 `⊢ (P ⊥) ≡ ⊥` 和步骤 (4) 的结论 `⊢ ⊥ ≡ (Neg T)` 通过传递性 **A3** 连接。 **Q.E.D.**

**结论：**
上述两个定理的证明仅依赖于 RRL-E 的原始公理和新加入的公理模式 F1。这表明 F2 的内容在 F1 被接受的前提下是完全可衍生的，因此 F2 作为一个独立的公理组是多余的。一个更优雅的系统 **RRL-E+F** 应该仅包含公理 F1。


### **8. F组公理的相容性形式化证明**

本节旨在为 RRL-E 系统增补 **F组：真理谓词公理** 后的新系统 **RRL-E+F** 提供一个严格的形式化一致性证明。我们将通过构造一个可靠的非平凡代数模型 `M₃` 来完成此证明。一致性是可靠性的直接推论。

#### **8.1 模型 `M₃` 的构造**

我们定义一个模型 `M₃ = <D₃, I₃>`，其中 `D₃` 为模型的域，`I₃` 为解释函数。

##### **8.1.1 域 (Domain)**

模型的域 `D₃` 是一个包含三个相异元素的集合：
`D₃ = {v_T, v_⊥, v_U}`，其中 `v_T, v_⊥, v_U` 两两互不相等。

##### **8.1.2 解释函数 (Interpretation Function)**

解释函数 `I₃` 将系统中的项映射到域 `D₃` 中的元素。我们用 `[[t]]₃` 表示项 `t` 在解释 `I₃` 下的指称。

1.  **常量解释**:
    *   `[[T]]₃ = v_T`
    *   `[[⊥]]₃ = v_⊥`
    *   `[[Eval]]₃ = v_T`

2.  **变量解释**: 对于任意变量赋值函数 `σ: V → D₃`，`[[x]]_3^σ = σ(x)`。为简化表示，在验证公理模式时，我们默认对于任意项 `t` 的解释 `[[t]]₃` 是在任意赋值 `σ` 下的值 `[[t]]_3^σ`。

3.  **公式解释**: 公式 `t₁ ≡ t₂` 在模型 `M₃` 中为真，记作 `M₃ ⊨ t₁ ≡ t₂`，当且仅当对于所有的变量赋值 `σ`，都有 `[[t₁]]_3^σ = [[t₂]]_3^σ`。

4.  **构造子解释**: 系统中的构造子 `·`, `Neg`, `Quote`, `P` 分别被解释为域 `D₃` 上的函数 `dot₃`, `neg₃`, `quote₃`, `p₃`。

#### **8.2 构造子的语义函数真值表**

以下表格定义了模型 `M₃` 中各个构造子所对应的语义函数。所有后续的可靠性验证将严格依据这些定义进行。

**表 8.1: `dot₃(d₁, d₂)` (二元构造子 `·` 的解释)**
| `dot₃(d₁, d₂)` | `d₂ = v_T` | `d₂ = v_⊥` | `d₂ = v_U` |
| :-------------- | :--------- | :--------- | :--------- |
| **`d₁ = v_T`**  | `v_T`      | `v_⊥`      | `v_U`      |
| **`d₁ = v_⊥`**  | `v_⊥`      | `v_T`      | `v_U`      |
| **`d₁ = v_U`**  | `v_U`      | `v_U`      | `v_T`      |

**表 8.2: `neg₃(d)` (一元构造子 `Neg` 的解释)**
| `d` | `neg₃(d)` |
| :---- | :-------- |
| `v_T` | `v_⊥`     |
| `v_⊥` | `v_⊥`     |
| `v_U` | `v_U`     |

**表 8.3: `quote₃(d)` (一元构造子 `Quote` 的解释)**
| `d` | `quote₃(d)` |
| :---- | :---------- |
| `v_T` | `v_T`       |
| `v_⊥` | `v_⊥`       |
| `v_U` | `v_U`       |

**表 8.4: `p₃(d)` (一元构造子 `P` 的解释)**
| `d` | `p₃(d)` |
| :---- | :------ |
| `v_T` | `v_T`   |
| `v_⊥` | `v_⊥`   |
| `v_U` | `v_U`   |

*注：`quote₃` 和 `p₃` 在此模型中均被解释为恒等函数。*

#### **8.3 模型的可靠性证明 (Soundness Proof)**

我们需证明 RRL-E+F 的所有公理在模型 `M₃` 中均为真，且所有推理规则在 `M₃` 中保真。设 `d` 为任意项 `t` 在任意赋值下的解释 `[[t]]₃ ∈ D₃`。

*   **A组：等价与同余规则 (A1-A4)**
    *   `≡` 被解释为 `D₃` 上的等号 ` = `，其自反性、对称性和传递性天然成立。
    *   `dot₃`, `neg₃`, `quote₃`, `p₃` 均为 `D₃` 上的良定义函数，故同余性得到保证。

*   **B1: `(· t T) ≡ t`**
    需验证：`dot₃(d, [[T]]₃) = d` 对所有 `d ∈ D₃` 成立。查阅**表 8.1** 的第二列 (`d₂ = v_T`)，可知该等式对 `d = v_T, v_⊥, v_U` 均成立。公理 B1 有效。

*   **C1: `(Neg (· t (Neg t))) ≡ ⊥`**
    需验证：`neg₃(dot₃(d, neg₃(d))) = [[⊥]]₃ = v_⊥` 对所有 `d ∈ D₃` 成立。
    *   **`d = v_T`**: `neg₃(dot₃(v_T, neg₃(v_T))) = neg₃(dot₃(v_T, v_⊥))` (据**表 8.2**) ` = neg₃(v_⊥)` (据**表 8.1**) ` = v_⊥` (据**表 8.2**)。成立。
    *   **`d = v_⊥`**: `neg₃(dot₃(v_⊥, neg₃(v_⊥))) = neg₃(dot₃(v_⊥, v_⊥))` (据**表 8.2**) ` = neg₃(v_T)` (据**表 8.1**) ` = v_⊥` (据**表 8.2**)。成立。
    *   **`d = v_U`**: `neg₃(dot₃(v_U, neg₃(v_U))) = neg₃(dot₃(v_U, v_U))` (据**表 8.2**) ` = neg₃(v_T)` (据**表 8.1**) ` = v_⊥` (据**表 8.2**)。成立。
    公理 C1 有效。

*   **C2 (规则):** 若 `M₃ ⊨ t ≡ T`，则 `M₃ ⊨ (· ⊥ t) ≡ ⊥`。
    语义前提为 `[[t]]₃ = [[T]]₃ = v_T`。需验证 `dot₃([[⊥]]₃, [[t]]₃) = [[⊥]]₃`。
    即 `dot₃(v_⊥, v_T) = v_⊥`。查阅**表 8.1**，成立。规则 C2 保真。

*   **C3: `(Neg ⊥) ≡ ⊥`**
    需验证：`neg₃([[⊥]]₃) = [[⊥]]₃`。即 `neg₃(v_⊥) = v_⊥`。查阅**表 8.2**，成立。公理 C3 有效。

*   **D1: `(· (Quote t) t) ≡ T`**
    需验证：`dot₃(quote₃(d), d) = [[T]]₃ = v_T` 对所有 `d ∈ D₃` 成立。
    由于 `quote₃` 是恒等函数，这简化为验证 `dot₃(d, d) = v_T`。
    *   **`d = v_T`**: `dot₃(v_T, v_T) = v_T`。
    *   **`d = v_⊥`**: `dot₃(v_⊥, v_⊥) = v_T`。
    *   **`d = v_U`**: `dot₃(v_U, v_U) = v_T`。
    查阅**表 8.1** 的对角线，可知等式均成立。公理 D1 有效。

*   **D2 (规则):** 若 `M₃ ⊨ t ≡ ⊥`，则 `M₃ ⊨ (Quote t) ≡ ⊥`。
    语义前提为 `[[t]]₃ = [[⊥]]₃ = v_⊥`。需验证 `quote₃([[t]]₃) = [[⊥]]₃`。
    即 `quote₃(v_⊥) = v_⊥`。查阅**表 8.3**，成立。规则 D2 保真。

*   **E1 (规则):** 若 `M₃ ⊨ t₁ ≡ (Quote t₂)`，则 `M₃ ⊨ (· Eval t₁) ≡ t₂`。
    语义前提为 `[[t₁]]₃ = quote₃([[t₂]]₃)`。由于 `quote₃` 是恒等函数，前提简化为 `[[t₁]]₃ = [[t₂]]₃`。
    需验证的结论是 `dot₃([[Eval]]₃, [[t₁]]₃) = [[t₂]]₃`。代入前提和 `[[Eval]]₃` 的解释，需验证 `dot₃(v_T, [[t₂]]₃) = [[t₂]]₃`。
    这等价于验证 B1 公理的左单位元版本，即 `dot₃(v_T, d) = d` 对所有 `d ∈ D₃` 成立。
    *   **`d = v_T`**: `dot₃(v_T, v_T) = v_T`。
    *   **`d = v_⊥`**: `dot₃(v_T, v_⊥) = v_⊥`。
    *   **`d = v_U`**: `dot₃(v_T, v_U) = v_U`。
    查阅**表 8.1** 的第一行，可知等式均成立。规则 E1 保真。

*   **F1 (真理透明性公理): `(P t) ≡ t`**
    需验证：`p₃(d) = d` 对所有 `d ∈ D₃` 成立。
    根据**表 8.4** 的定义，`p₃` 是恒等函数，故该公理有效。

#### **8.4 一致性结论**

1.  **可靠性定理 (Soundness Theorem)**: 已证明 RRL-E+F 系统的所有公理在模型 `M₃` 中为真，且所有推理规则保真。因此，如果 `⊢ t₁ ≡ t₂` 是 RRL-E+F 的一个定理，则 `M₃ ⊨ t₁ ≡ t₂`。

2.  **一致性证明 (Proof of Consistency)**:
    *   采用归谬法。假设系统 RRL-E+F 是不一致的。
    *   根据不一致性的定义，系统可证明 `T ≡ ⊥`，即 `⊢ T ≡ ⊥`。
    *   根据可靠性定理，若 `⊢ T ≡ ⊥`，则 `M₃ ⊨ T ≡ ⊥` 必须成立。
    *   根据模型中公式为真的定义，这意味着 `[[T]]₃ = [[⊥]]₃`。
    *   然而，根据模型 `M₃` 的构造：
        *   `[[T]]₃ = v_T`
        *   `[[⊥]]₃ = v_⊥`
    *   因此推导出 `v_T = v_⊥`。
    *   这与模型域 `D₃` 的定义中 `v_T ≠ v_⊥` 的基本设定相矛盾。
    *   由于“系统不一致”的假设导出了矛盾，故此假设必为假。

**最终结论：系统 RRL-E+F 是一致的 (consistent)。**


### 9. 说谎者问题

#### **前提假设 (Hypothesis H):**
存在一个项（Term）`L`，使得 `⊢ L ≡ (Neg L)` 是系统 RRL-E+F 的一个定理。

---

##### **命题 1: `L ≡ T` 是不可证的 (Unprovability of `L ≡ T`)**

**待证：** 在 RRL-E+F 系统中，给定假设 H，`L ≡ T` 不是一个定理。即 `⊬ L ≡ T`。

**证明方法：**
我们将采用归谬法 (Reductio ad absurdum)。我们假设 `L ≡ T` 是可证的，然后从这个假设和系统公理（包括 H）出发，推导出 `⊢ T ≡ ⊥`。由于我们已经证明 RRL-E+F 系统是一致的（即 `⊬ T ≡ ⊥`），这将证明我们的初始假设是错误的。

**形式化证明：**

1.  `⊢ L ≡ (Neg L)`
    *   **理由:** 假设 H。

2.  `⊢ L ≡ T`
    *   **理由:** 归谬法的假设。我们假设 `L ≡ T` 是一个定理。

3.  `⊢ T ≡ L`
    *   **理由:** 对步骤 (2) 应用对称性规则 **A2**。

4.  `⊢ T ≡ (Neg L)`
    *   **理由:** 结合步骤 (3) `⊢ T ≡ L` 和步骤 (1) `⊢ L ≡ (Neg L)`，应用传递性规则 **A3**。

5.  `⊢ (Neg L) ≡ (Neg T)`
    *   **理由:** 对步骤 (2) `⊢ L ≡ T` 应用同余性规则 **A4.2**。

6.  `⊢ T ≡ (Neg T)`
    *   **理由:** 结合步骤 (4) `⊢ T ≡ (Neg L)` 和步骤 (5) `⊢ (Neg L) ≡ (Neg T)`，应用传递性规则 **A3**。

7.  `⊢ (Neg T) ≡ ⊥`
    *   **理由:** 这是系统已证的**定理 8**。

8.  `⊢ T ≡ ⊥`
    *   **理由:** 结合步骤 (6) `⊢ T ≡ (Neg T)` 和步骤 (7) `⊢ (Neg T) ≡ ⊥`，应用传递性规则 **A3**。

**结论：**
我们从“`L ≡ T` 是可证的”这一假设出发，严格地在系统 RRL-E+F 内部推导出了 `⊢ T ≡ ⊥`。然而，我们在之前的分析中已经通过模型 `M₃` 严格证明了系统 RRL-E+F 是一致的，这意味着 `T ≡ ⊥` 不可能是该系统的一个定理。

由于我们的推导过程是有效的，而结论是不可接受的（在一个一致的系统中），因此必然是我们的初始假设（步骤 2）出了问题。

因此，假设 `⊢ L ≡ T` 必为假。即 `L ≡ T` 在系统 RRL-E+F 中是**不可证的**。 **Q.E.D.**

---

##### **命题 2: `L ≡ ⊥` 的假设与系统是相容的 (Compatibility of `L ≡ ⊥`)**

**待证：** 假设 `⊢ L ≡ ⊥` 与系统 RRL-E+F 以及假设 H 是相容的（consistent）。

**证明方法：**
要证明相容性，最严谨的方法是模型论方法。我们需要展示存在一个 RRL-E+F 的可靠模型，在该模型中，假设 H `⊢ L ≡ (Neg L)` 和新假设 `⊢ L ≡ ⊥` 的语义解释同时为真。如果这样一个模型存在（并且 `v_T ≠ v_⊥`），那么根据可靠性定理，将 `⊢ L ≡ ⊥` 作为新公理加入系统不会导致不一致性（即不会推导出 `T ≡ ⊥`）。

我们将使用先前已验证为 RRL-E+F 可靠模型的 `M₃`。

**形式化证明：**

1.  **选择模型:**
    我们选用三值模型 `M₃ = <D₃, I₃>`，其中：
    *   域 `D₃ = {v_T, v_⊥, v_U}`。
    *   `[[T]]₃ = v_T`, `[[⊥]]₃ = v_⊥`。
    *   `neg₃` 的定义为：`neg₃(v_T) = v_⊥`, `neg₃(v_⊥) = v_⊥`, `neg₃(v_U) = v_U`。
    我们已经证明 `M₃` 是 RRL-E+F 的一个可靠模型。

2.  **定义 `L` 的解释:**
    为了验证相容性，我们需要为项 `L` 在模型 `M₃` 中选择一个解释 `[[L]]₃ ∈ D₃`，并验证所有假设在该解释下都成立。
    我们根据待证的相容性假设 `⊢ L ≡ ⊥`，来设定 `L` 的解释：
    *   令 `[[L]]₃ = [[⊥]]₃ = v_⊥`。

3.  **验证假设在模型中成立:**
    现在，我们必须验证在此解释下，所有相关的假设（包括 H 和新假设）在模型 `M₃` 中都为真。

    *   **验证 `L ≡ ⊥`:**
        公式 `L ≡ ⊥` 在模型中为真，当且仅当 `[[L]]₃ = [[⊥]]₃`。
        根据我们的设定，`[[L]]₃ = v_⊥` 且 `[[⊥]]₃ = v_⊥`。
        因此，`v_⊥ = v_⊥` 成立。该假设在模型中得到满足。

    *   **验证 `L ≡ (Neg L)` (即假设 H):**
        公式 `L ≡ (Neg L)` 在模型中为真，当且仅当 `[[L]]₃ = [[(Neg L)]]₃`，即 `[[L]]₃ = neg₃([[L]]₃)`。
        我们将 `[[L]]₃ = v_⊥` 代入该等式：
        *   左侧: `[[L]]₃ = v_⊥`。
        *   右侧: `neg₃([[L]]₃) = neg₃(v_⊥)`。
        根据模型 `M₃` 中 `neg₃` 的定义，`neg₃(v_⊥) = v_⊥`。
        因此，`v_⊥ = v_⊥` 成立。假设 H 在模型中也得到满足。

**结论：**
我们成功地找到了一个模型 `M₃` 和一个对项 `L` 的解释 (`[[L]]₃ = v_⊥`)，使得：
1.  `M₃` 是 RRL-E+F 系统的一个可靠模型。
2.  新假设 `L ≡ ⊥` 的语义解释在 `M₃` 中为真。
3.  核心假设 H (`L ≡ (Neg L)`) 的语义解释在 `M₃` 中也为真。
4.  在该模型中 `[[T]]₃ = v_T ≠ v_⊥ = [[⊥]]₃`。

一个理论（在这里是 RRL-E+F + H + `⊢ L ≡ ⊥`）如果有一个模型，其中真和假不相等，那么这个理论就是**一致的（相容的）**。

因此，假设 `⊢ L ≡ ⊥` 与系统 RRL-E+F 及假设 H **是相容的**。 **Q.E.D.**

