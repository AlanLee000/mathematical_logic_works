### **1. 语法：项代数与规范项**

我们首先定义构成我们形式世界的语法对象。设 `V` 是一个可数的变量集合。所有项的宇宙是在签名 `Σ` 上以变量集 `V` 为基础构建的自由项代数 `T_Σ(V)`。

**签名 (Signature) `Σ`:**
`Σ` 包含以下构造器：
*   `equiv: Term × Term → Term` （二元，等价断言构造器）
*   `rewrite: Term × Term → Term` （二元，重写规则构造器）
*   `tuple_n: Termⁿ → Term` for each n ≥ 0 （n元组构造器）
    (我们常用 `(t₁, ..., tₙ)` 表示 `tuple_n(t₁, ..., tₙ)`)。

**项集 (Set of Terms) `T_Σ(V)`:**
`T_Σ(V)` 是在签名 `Σ` 上以变量集 `V` 为基础的最小集合。**基项 (Ground Terms)** 的集合 `T_Σ` 是 `T_Σ(V)` 中不含任何变量的项的子集。

**规范项与良构约束 (Specification Term and Well-Formedness Constraints)**

一个形式系统由一个称为“规范项”的特殊项 `T ∈ T_Σ(V)` 来指定。为保证系统的逻辑一致性和可判定性，`T` 必须满足以下三条严格的**良构约束 (Well-Formedness Constraints)**：

1.  **变量作用域约束 (Variable Scoping Constraint)**:
    `T` 中的任何变量 `v ∈ V` 必须仅出现在形式为 `rewrite(l, r)` 的子项的 `l` 或 `r` 部分。形式化地，对于 `T` 中任意一个包含变量的子项 `T|ₚ`，必存在一个位置 `q`，使得 `T|q` 的形式为 `rewrite(l, r)`，且 `p` 是 `q.1` (l的位置) 或 `q.2` (r的位置) 的后继位置。此约束确保了变量仅用于定义规则模式。

2.  **公理基项约束 (Axiom Groundness Constraint)**:
    `T` 中任何形式为 `equiv(s, t)` 的子项必须是一个 **基项** 才能被提取为公理。即，如果 `T|ₚ = equiv(s, t)`，则 `T|ₚ ∈ T_Σ`，这意味着 `s` 和 `t` 均不能含有变量。

3.  **规则安全性约束 (Rule Safety Constraint)**:
    `T` 中任何形式为 `rewrite(l, r)` 的子项，其右侧 `r` 的变量集合必须是其左侧 `l` 变量集合的子集。即，`vars(r) ⊆ vars(l)`。此约束保证了当规则应用于基项时，产生的结果也必然是基项。

这些约束共同确保了系统的“数据”部分（规则与公理之外的结构）始终是具体的基项，而“计算”部分（规则与公理）是良定义的。

***

### **2. 推论式重写 (Deductive Rewriting)**

**定义 (动态同余关系 `≡_T`)**

对于一个给定的良构规范项 `T`，其动态同余关系 `≡_T` 在 `T` 的所有基项子项的集合上定义，构建过程如下：

1.  **确定论域 (Universe of Discourse)**:
    论域为 `T` 的所有基项子项的集合，记为 `U = GroundSub(T)`。由于 `T` 是一个有限项，`U` 是一个有限的基项集合。

2.  **提取规则**:
	从 `T` 中提取所有重写规则，形成一个偶对集合：
    `R(T) = { (l, r) | rewrite(l, r) ∈ Sub(T) }`
    其中 `Sub(T)` 是 `T` 的所有子项的集合，`l, r ∈ T_Σ(V)`。我们使用元语言符号 `l → r` 来指代规则偶对 `(l, r)`。

3.  **提取公理 (Axiom Extraction)**:
    从 `T` 中提取所有等价断言，构成一个基项偶对集合：
    `E_pairs(T) = { (s, t) | equiv(s, t) ∈ Sub(T) }`
    根据**公理基项约束 (Constraint 2)**，`E_pairs(T)` 中的所有 `s` 和 `t` 均被保证为基项 (`s, t ∈ T_Σ`)。

	**重要注记**: `R(T)` 和 `E_Pairs(T)` 是从一个**静态快照** `T` 中提取出的集合。它们本身不构成系统的状态，而是用于在当前状态下分析和确定可用操作的辅助工具。系统的动态演化将直接修改规范项 `T` 的结构，从而在每一步都可能改变后续分析所依据的规则与公理基础。

4.  **计算同余闭包 (Congruence Closure)**:
    `≡_T` 被定义为在论域 `U` 上，包含 `E_pairs(T)` 的最小关系，该关系满足：
    *   **等价关系 (Equivalence):** `≡_T` 是自反的、对称的和传递的。
    *   **同余律 (Congruence):** 对于任意 `f ∈ Σ` (其元数为 `n`) 以及任意项 `s₁, ..., sₙ, t₁, ..., tₙ ∈ U`：
        如果 `f(s₁, ..., sₙ) ∈ U` 且 `f(t₁, ..., tₙ) ∈ U`，并且对于所有的 `i ∈ {1, ..., n}` 都有 `sᵢ ≡_T tᵢ`，那么必须有 `f(s₁, ..., sₙ) ≡_T f(t₁, ..., tₙ)`。

**可判定性论证 (Decidability Argument)**:
由于论域 `U` 是一个有限集，`E_pairs(T)` 是一个有限的基项等式集合，`≡_T` 所定义的等价问题是**可判定的**。判断任意 `u, v ∈ U` 是否满足 `u ≡_T v` 可以通过标准**同余闭包算法**在多项式时间内有效解决。
对于给定的 `l` 和 `a`，寻找所有满足条件的替换 `σ` 的过程（即 E-matching）在此系统中是**可判定的**。其判定算法如下：
1.  计算目标项 `a` 在 `≡_T` 关系下的等价类 `[a]_≡_T`。由于 `≡_T` 是可判定的且 `U` 有限，`[a]_≡_T` 是一个可计算的、有限的基项集合。
2.  遍历等价类 `[a]_≡_T` 中的每一个基项 `b`。
3.  对每一个 `b`，尝试通过标准的**句法匹配 (syntactic matching)** 算法求解 `σ(l) = b`。
4.  句法匹配本身是可判定的（通常是线性时间复杂度）。由于需要检查的候选项 `b` 的数量是有限的，整个推论匹配过程必定终止，并能枚举出所有有效的替换 `σ`。

### **4. 操作语义：系统的演化 (Operational Semantics: System Evolution)**

我们现在定义系统的动态行为。系统的**状态 (State)** 就是一个良构的规范项 `T ∈ T_Σ(V)`。系统的演化被定义为一个在所有良构规范项上的**单步迁移关系 (Single-Step Transition Relation)**，记为 `⟶`。

**定义 (单步迁移关系 `⟶`)**

一个规范项 `T` 可以通过单步迁移演化为 `T'`，记为 `T ⟶ T'`，当且仅当存在一个**适定重写实例 (Well-Defined Rewrite Instance)** `(p_app, p_rule, l→r, σ)`，使得：

1.  **理论派生 (Theory Derivation)**:
    首先，根据当前状态 `T`，计算其动态同余关系 `≡_T`，如第3节所定义。

2.  **实例匹配 (Instance Matching)**:
    该实例必须满足在 `T` 的上下文中定义的**推论匹配条件 (Inferential Matching Condition)**：
    *   `p_app` 是 `T` 中一个基项子项 `a = T|_{p_app}` 的位置。
    *   `p_rule` 是 `T` 中一个规则子项 `rewrite(l, r) = T|_{p_rule}` 的位置。
    *   `σ` 是一个基替换，其定义域为 `vars(l)`。
    *   存在一个基项 `b ∈ GroundSub(T)`，使得 `a ≡_T b` 且 `σ(l) = b`。

3.  **状态迁移 (State Transition)**:
    `T'` 是通过在 `T` 的 `p_app` 位置应用该实例的结果而得到的项：
    `T' := T[σ(r)]_{p_app}`
    其中 `T[s]_p` 表示将 `T` 在位置 `p` 的子项替换为项 `s` 后得到的新项。根据**规则安全性约束 (Constraint 3)**，`σ(r)` 被保证为一个基项，因此 `T'` 也是一个基项（在其数据部分）。

**重要评注：动态理论的非单调性 (Critical Remark: Non-monotonicity of the Dynamic Theory)**

此操作语义的核心特征在于其**自反性 (reflectivity)** 和 **非单调性 (non-monotonicity)**。在每一步迁移 `T ⟶ T'` 中：

*   用于匹配的理论 `≡_T` 是从 `T` 中**瞬时派生**的。
*   迁移完成后，旧的理论 `≡_T` 被**完全废弃**。
*   在下一个计算步骤中，将从新的状态 `T'` 中**重新计算**一个全新的、可能完全不同的理论 `≡_{T'}`。

这意味着一个重写步骤不仅改变了项的数据结构，更深刻地改变了系统在下一刻进行推理所依据的逻辑基础。之前成立的等价关系 `a ≡_T b` 在 `T'` 中可能不再成立，反之亦然。

**定义 (计算与范式)**

*   一个**计算 (Computation)** 或 **推导 (Derivation)** 是一个（可能无限的）迁移序列：
    `T₀ ⟶ T₁ ⟶ T₂ ⟶ ...`
    其中每个 `Tᵢ` 都是一个良构的规范项。

*   如果一个规范项 `T_n` 不存在任何 `T'` 使得 `T_n ⟶ T'`，则称 `T_n` 是一个**范式 (Normal Form)**。计算在达到范式时**终止 (terminates)**。
  

### **5. 系统的基本性质：良构保持性**

操作语义 `⟶` 的定义必须保证系统的完整性，即任何计算步骤都不能将一个合法的系统状态转变为一个非法的状态。这由以下关键定理保证。

**引理 5.1 (数据部分的基项性)**
对于任何一个良构规范项 `T`，若其子项 `T|ₚ` 的根符号不是 `rewrite`，则 `T|ₚ` 必须是一个基项。
*   **证明**: 这是**变量作用域约束 (Constraint 1)** 的直接推论。该约束规定，任何变量 `v` 的出现都必须在一个 `rewrite(l, r)` 子项的 `l` 或 `r` 内部。因此，任何不在 `rewrite` 构造器内部的子项都不能包含变量，故必为基项。▢

**定理 5.2 (良构保持性)**
如果 `T` 是一个良构的规范项，且 `T ⟶ T'`，则 `T'` 也必定是一个良构的规范项。

*   **证明**:
    假设 `T` 是良构的，且 `T ⟶ T'`。这意味着存在一个适定重写实例 `(p_app, p_rule, l→r, σ)`，使得 `T' = T[σ(r)]_{p_app}`。我们需要证明 `T'` 满足全部三条良构约束。

    1.  **变量作用域约束 (Constraint 1)**:
        根据实例匹配的定义，`T|_{p_app}` 是一个基项。根据**规则安全性约束 (Constraint 3)** on `rewrite(l, r)`，我们有 `vars(r) ⊆ vars(l)`。由于 `σ` 是一个基替换（其值域仅包含基项），`σ(r)` 也必然是一个基项。
        `T'` 是通过将 `T` 中的基项子项 `T|_{p_app}` 替换为另一个基项 `σ(r)` 得到的。此操作没有在 `T` 中引入任何新的变量，也没有改变 `T` 中任何原有变量的位置或作用域。因此，如果 `T` 满足变量作用域约束，`T'` 也同样满足。

    2.  **公理基项约束 (Constraint 2)**:
        迁移 `T ⟶ T'` 只修改了 `p_app` 位置的子项。我们需要证明 `T'` 中所有形如 `equiv(s', t')` 的子项都是基项。
        *   对于任何不在 `p_app` 位置或其上方（即不是 `p_app` 的前缀）的 `equiv` 子项，其自身并未被修改，因此它在 `T'` 中仍然是基项，正如它在 `T` 中一样。
        *   考虑 `p_app` 位置。被替换的子项 `T|_{p_app}` 是一个基项。根据**引理 5.1**，如果 `T|_{p_app}` 是一个形式为 `equiv(s,t)` 的项，它必须是基项。替换它的 `σ(r)` 也是一个基项。
        *   替换操作不会在一个基项 `σ(r)` 内部凭空创造出含有变量的 `equiv` 子项。
        因此，`T'` 中所有 `equiv` 子项都必然是基项。约束2得以保持。

    3.  **规则安全性约束 (Constraint 3)**:
        迁移 `T ⟶ T'` 只在 `p_app` 位置进行替换。`T` 中的任何 `rewrite(l, r)` 子项的内部结构都没有被改变。`p_app` 指向的是一个基项子项，根据**引理 5.1**，它不可能是 `rewrite` 项（因为 `rewrite` 项允许包含变量）。因此，替换操作不会修改任何规则。`T'` 中的规则集与 `T` 中的完全相同。既然 `T` 中所有规则都满足安全性约束，`T'` 中的也同样满足。

    由于 `T'` 满足全部三条良构约束，该定理得证。▢