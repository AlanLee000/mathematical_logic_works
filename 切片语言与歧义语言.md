## **1. 语法层**

#### **签名**

$$
\Sigma=\{\mathrm{Tuple}_n\ (n\ge 0),\ \mathrm{Def}\ (arity\ 2)\}.
$$

#### **原子集** $A$

一个给定的可数集。

#### **项集** $\mathsf{Term}$

项集 $\mathsf{Term}$ 是在签名 $\Sigma$ 与原子集 $A$ 上构造的自由项代数，由以下归纳规则定义：
*   **原子**: 若 $a\in A$，则 $a\in\mathsf{Term}$。
*   **元组**: 若 $t_1,\dots,t_n\in\mathsf{Term}$ (其中 $n \ge 0$)，则 $(t_1,\dots,t_n)\in\mathsf{Term}$。空元组 $()$ 是 $n=0$ 时的情形。
*   **定义**: 若 $t_1,t_2\in\mathsf{Term}$，则 $(t_1 := t_2)\in\mathsf{Term}$。

**注**：项 (Term) 在此系统中抽象地代表任意的**句法单元 (syntactic unit)**，如表达式、语句或类型。

#### **字面相等** $\equiv$

字面相等 $\equiv$ 是项代数上的结构同构关系，即构造子与对应子项逐一相等。

---

## **2. 切片算子**

对任一项 $t \in \mathsf{Term}$，其顶层连续子序列的集合 $\mathsf{Slice}(t)$ 定义如下：
$$
\mathsf{Slice}(t)=
\begin{cases}
\{(t_i,\dots,t_j)\mid 1\le i\le j\le n\}, & \text{若 } t=(t_1,\dots,t_n),\ n \ge 1\\[4pt]
\{()\}, & \text{若 } t=()\ (n=0)\\[4pt]
\{t\}, & \text{否则 (即 } t \text{ 为原子或定义项)}.
\end{cases}
$$

**引理 2.1**: 对于任意项 $t \in \mathsf{Term}$，恒有 $t \in \mathsf{Slice}(t)$。

---

## **3. 形式规则系统**

我们定义三个关系：子片段 (`⊑`)、定义性还原 (`~>`) 与句法依赖 (`R`)。

### **3.1 子片段关系 `⊑`**

`⊑` 是由以下规则生成的最小预序（自反、传递）。

```
(I-Slice)      u ∈ Slice(t)
            ----------------
                  u ⊑ t

(I-Trans)    s ⊑ u     u ⊑ t
            -----------------
                  s ⊑ t
```
**注**：自反性 ($t ⊑ t$) 可由 (I-Slice) 和引理 2.1 导出。

### **3.2 定义性还原关系 `~>`**

此关系直接由 `Def` 构造子的语义产生。
```
(Def-Reduce)   -----------------
               (t₁ := t₂) ~> t₂
```

### **3.3 句法依赖关系 `R`**

`R` 关系是由以下公理和规则生成的最小预序，捕捉了良构性的传递依赖。

```
(R-Reflex)      -----------
                   R(t,t)

(R-Trans)       R(t,u)   R(u,v)
                ---------------
                     R(t,v)

(R-Comp)        t 直接构成 u
                --------------
                     R(t,u)

(R-Inherit)     t ~> u   R(u,v)
                ---------------
                     R(t,v)

(R-Sub-Dep)     R(t,s)   u ⊑ s
                --------------
                     R(t,u)
```
其中，“$t$ 直接构成 $u$”是以下公理的简写：
*   $t=(t_1,\dots,t_n)$ 且 $u=t_i$ 对于某个 $1 \le i \le n$。
*   $t=(t_1 := t_2)$ 且 $u=t_1$ 或 $u=t_2$。

**规则解释**:
*   `(R-Comp)`: 一个复合项依赖于其直接结构组件。
*   `(R-Inherit)`: 一个定义项继承其定义体的所有依赖。
*   `(R-Sub-Dep)`: 若 $t$ 依赖于 $s$，则 $t$ 也依赖于 $s$ 的任意文本子片段。这对应于依赖链的**后扩展**。

**附注：关于 `(R-Monotone)` 规则的语义与可导出性**

`(R-Monotone)` 规则表述如下：
```
(R-Monotone)    s ⊑ t   R(s,u)
                --------------
                     R(t,u)
```

**可导出性证明**

**定理**: 规则 `(R-Monotone)` 可由其他 `R` 关系规则导出。

**证明**:
我们的目标是证明，在给定前提 `s ⊑ t` 和 `R(s, u)` 的情况下，我们可以推导出结论 `R(t, u)`。

| 步骤  | 断言        | 理由                           |
| :-- | :-------- | :--------------------------- |
| 1.  | `s ⊑ t`   | 前提 1                         |
| 2.  | `R(s, u)` | 前提 2                         |
| 3.  | `R(t, t)` | 公理 `(R-Reflex)`              |
| 4.  | `R(t, s)` | 应用 `(R-Sub-Dep)` 于 (3) 和 (1) |
| 5.  | `R(t, u)` | 应用 `(R-Trans)` 于 (4) 和 (2)   |

**证明解释**:
- 我们从 `R` 关系的自反性 `R(t, t)` 出发 (步骤 3)。
- `(R-Sub-Dep)` 规则允许我们将依赖链进行后扩展：若 `t` 依赖于 `t` 自身，则它也依赖于 `t` 的任意子片段 `s` (步骤 4)。
- 最后，利用 `R` 关系的传递性 `(R-Trans)`，我们将 `R(t, s)` 和 `R(s, u)` 这两条依赖链连接起来，从而得到最终结论 `R(t, u)` (步骤 5)。

此证明表明，`(R-Monotone)` 所描述的“前扩展”特性，实际上可以由自反性、传递性以及更强的“后扩展”规则 `(R-Sub-Dep)` 组合而成。

---

## **4. 超图模型**

 为了将形式系统中的依赖关系模型化，我们引入一个基于有向超图的语义模型。该模型的构造基于一个满足特定闭包性质的项集。

**定义 4.1 (切片闭包集)**: 一个项集 $S \subseteq \mathsf{Term}$ 被称为**切片闭包的 (slice-closed)**，如果对于任意 $t \in S$，均有 $\mathsf{Slice}(t) \subseteq S$。

在本节的后续内容中，我们**假设**给定的项集 $S$ 是一个**切片闭包集**。基于此，我们构造一个有向超图 $H=(V, E)$。

*   **顶点集 $V$**: $V=S$。
*   **超边集 $E$**: $E$ 是 $V \times \mathcal{P}(V)$ 的子集，其中每个超边 $e=(h, T)$ 代表从头顶点 $h$ 到尾顶点集 $T$ 的一条依赖弧。$E$ 由以下三类超边构成：
    1.  **构成边 $E_{\mathsf{comp}}$**:
        *   对每个 $t=(t_1,\dots,t_n) \in V$，加入超边 $(t, \{t_1,\dots,t_n\})$。
        *   对每个 $t=(t_1 := t_2) \in V$，加入超边 $(t, \{t_1, t_2\})$。
        *   对每个原子 $a \in V$，加入超边 $(a, \emptyset)$。
    2.  **子片段边 $E_{\mathsf{slice}}$**:
        *   对每个 $t \in V$ 和每个 $u \in \mathsf{Slice}(t)$，加入超边 $(t, \{u\})$。
    3.  **定义边 $E_{\mathsf{def}}$**:
        *   对每个 $t=(t_1 := t_2) \in V$，加入超边 $(t, \{t_2\})$。

**模型中的关系定义**:

令**路径**是从顶点 $v_0$ 到 $v_k$ 的一个序列 $v_0, e_1, v_1, \dots, e_k, v_k$，其中 $v_i \in V$，$e_i = (v_{i-1}, T_i) \in E$ 且 $v_i \in T_i$。若存在这样的路径，我们记为 $v_0 \to^* v_k$。

*   $s \sqsubseteq_H t$ 当且仅当存在一条从 $t$ 到 $s$ 的、**仅由子片段边 ($E_{\mathsf{slice}}$)** 构成的路径。
*   $t \leadsto_H u$ 当且仅当超边 $(t, \{u\}) \in E_{\mathsf{def}}$。
*   $R_H(t, u)$ 当且仅当 $t \to^* u$，即从 $t$ 到 $u$ 存在一条由**任意类型超边**构成的路径（长度 $\ge 0$）。

---

## **5. 可靠性与一致性**

### **5.1 可靠性 (Soundness) 证明**

**可靠性定理**：对于任意切片闭包集 $S$ 及其构造的超图模型 $H=(S, E)$：
1.  若 $s, t \in S$ 且 $s \preccurlyeq t$ 可由形式规则导出，则 $s \preccurlyeq_H t$。
2.  若 $t, u \in S$ 且 $t \sim> u$ 可由形式规则导出，则 $t \leadsto_H u$。
3.  若 $t, u \in S$ 且 $R(t, u)$ 可由形式规则导出，则 $R_H(t, u)$。

我们将对每个关系的推导结构进行归纳证明。

#### **1.1 `⊑` 关系的可靠性证明**

**证明目标**：若 $s \preccurlyeq t$ 可导，则 $s \preccurlyeq_H t$。
我们对 $s \preccurlyeq t$ 的推导长度进行归纳。

*   **基础情况 (Base Case)**：推导长度为 1。
    此时，该推导必然是应用了规则 `(I-Slice)`。
    -   前提：$u \in \mathsf{Slice}(t)$。
    -   结论：$u \preccurlyeq t$。
    根据超图模型的定义，对于任意 $u \in \mathsf{Slice}(t)$，会构造一条子片段边 $(t, \{u\}) \in E_{\mathsf{slice}}$。这条边本身构成了一条从 $t$ 到 $u$ 的、仅由子片段边构成的路径（长度为1）。根据 $s \preccurlyeq_H t$ 的定义，这正是 $u \preccurlyeq_H t$。基础情况成立。

*   **归纳步骤 (Inductive Step)**：假设所有长度小于 $k$ 的 `⊑` 推导都满足可靠性。我们考虑一个长度为 $k$ 的推导，其最后一步应用了 `(I-Trans)`。
    -   前提：$s \preccurlyeq u$ 和 $u \preccurlyeq t$。这两个前提的推导长度均小于 $k$。
    -   结论：$s \preccurlyeq t$。
    根据归纳假设：
    -   由 $s \preccurlyeq u$ 可导，我们有 $s \preccurlyeq_H u$。这意味着在模型 $H$ 中存在一条从 $u$ 到 $s$ 的、仅由 $E_{\mathsf{slice}}$ 边构成的路径 $P_1$。
    -   由 $u \preccurlyeq t$ 可导，我们有 $u \preccurlyeq_H t$。这意味着在模型 $H$ 中存在一条从 $t$ 到 $u$ 的、仅由 $E_{\mathsf{slice}}$ 边构成的路径 $P_2$。
    我们可以将路径 $P_2$ 和 $P_1$ 进行拼接（在顶点 $u$ 处连接），得到一条从 $t$ 到 $s$ 的新路径 $P_{2 \cdot 1}$。由于 $P_1$ 和 $P_2$ 都只包含子片段边，拼接后的路径也只包含子片段边。因此，存在一条从 $t$ 到 $s$ 的 $E_{\mathsf{slice}}$-路径，即 $s \preccurlyeq_H t$。归纳步骤成立。

**结论**：`⊑` 关系是可靠的。

#### **1.2 `~>` 关系的可靠性证明**

**证明目标**：若 $t \sim> u$ 可导，则 $t \leadsto_H u$。
此证明非常直接，因为 `~>` 关系没有传递性或自反性规则，只有一个公理化规则。

*   任何关于 $t \sim> u$ 的推导，都必须且只能是应用 `(Def-Reduce)` 规则一步完成。
*   该规则的形式为：`-----------------` / `(t₁ := t₂) ~> t₂`。
*   这意味着 $t$ 必然是 `(t₁ := t₂)` 且 $u$ 必然是 `t₂`。
*   根据超图模型的定义，对于每一个形如 $t = (t_1 := t_2)$ 的顶点，都会构造一条定义边 $(t, \{t_2\}) \in E_{\mathsf{def}}$。
*   根据 $t \leadsto_H u$ 的定义，这正是 $t \leadsto_H u$。

**结论**：`~>` 关系是可靠的。

#### **1.3 `R` 关系的可靠性证明**

**证明目标**：若 $R(t, u)$ 可导，则 $R_H(t, u)$。
我们对 $R(t, u)$ 的推导长度进行归纳。

*   **基础情况 (Base Cases - Axioms)**：推导长度为 1。
    *   **规则 `(R-Reflex)`**: `R(t,t)`。
        在模型中，$R_H(t,t)$ 意味着存在一条从 $t$ 到 $t$ 的路径。一条长度为 0 的路径（即顶点 $t$ 本身）满足这个定义。因此 $R_H(t,t)$ 成立。
    *   **规则 `(R-Comp)`**: `$t$ 直接构成 $u$`。
        -   情形一：$t=(t_1,\dots,t_n)$ 且 $u=t_i$。根据模型定义，存在构成边 $(t, \{t_1,\dots,t_n\}) \in E_{\mathsf{comp}}$。由于 $u \in \{t_1,\dots,t_n\}$，这条边构成了一条从 $t$ 到 $u$ 的路径（长度为1）。因此 $R_H(t,u)$ 成立。
        -   情形二：$t=(t_1 := t_2)$ 且 $u=t_1$ 或 $u=t_2$。同理，存在构成边 $(t, \{t_1, t_2\}) \in E_{\mathsf{comp}}$，这构成了一条从 $t$ 到 $u$ 的路径。因此 $R_H(t,u)$ 成立。

*   **归纳步骤 (Inductive Step - Rules)**：假设所有长度小于 $k$ 的 `R` 推导都满足可靠性。我们考虑一个长度为 $k$ 的推导，其最后一步应用了某个推理规则。
    *   **规则 `(R-Trans)`**:
        -   前提：$R(t,u)$ 和 $R(u,v)$。
        -   根据归纳假设，模型中存在从 $t$ 到 $u$ 的路径 $P_1$（即 $R_H(t,u)$），以及从 $u$ 到 $v$ 的路径 $P_2$（即 $R_H(u,v)$）。
        -   拼接这两条路径，得到一条从 $t$ 到 $v$ 的有效路径。因此 $R_H(t,v)$ 成立。
    *   **规则 `(R-Inherit)`**:
        -   前提：$t \sim> u$ 和 $R(u,v)$。
        -   根据 `~>` 关系的可靠性，我们有 $t \leadsto_H u$，即存在定义边 $e = (t, \{u\}) \in E_{\mathsf{def}}$。
        -   根据归纳假设，存在从 $u$ 到 $v$ 的路径 $P$（即 $R_H(u,v)$）。
        -   我们可以通过先走边 $e$ 到达 $u$，再沿着路径 $P$ 到达 $v$，从而构造出一条从 $t$ 到 $v$ 的新路径。因此 $R_H(t,v)$ 成立。
    *   **规则 `(R-Sub-Dep)`**:
        -   前提：$R(t,s)$ 和 $u \preccurlyeq s$。
        -   根据归纳假设，存在从 $t$ 到 $s$ 的路径 $P_1$（即 $R_H(t,s)$）。
        -   根据 `⊑` 关系的可靠性，存在一条从 $s$ 到 $u$ 的、仅由子片段边构成的路径 $P_2$（即 $u \preccurlyeq_H s$）。
        -   拼接路径 $P_1$ 和 $P_2$，得到一条从 $t$ 到 $u$ 的有效路径。因此 $R_H(t,u)$ 成立。

**注**：由于已经证明 `(R-Monotone)` 是可导出的，我们无需在此单独证明其可靠性。其可靠性由其他规则的可靠性复合保证。

**结论**：`R` 关系是可靠的。

**综合上述所有证明，该形式系统的整体可靠性得以确立。**

---

### **5.2 非平凡一致性 (Non-trivial Consistency) 证明**

一个系统是非平凡一致的，意味着它不能证明所有合法的陈述。在这个系统中，一个核心的陈述形式是 `R(t, u)`。为了证明非平凡一致性，我们只需构造一个模型，并在这个模型中找到两个项 `t` 和 `u`，使得 `R(t, u)` 不成立。

根据我们刚刚证明的可靠性（Soundness），如果模型中 `R_H(t, u)` 为假，那么在形式系统中 `R(t, u)` 必然是不可证明的。否则，如果 `R(t, u)` 可证，那么 `R_H(t, u)` 必为真，产生矛盾。

#### **5.2.1 构造一个反例模型**

1.  **选择原子集 (Atom Set)**：
    令原子集 $A$ 包含至少两个不同的原子，例如 $A = \{a, b, \dots\}$。

2.  **选择项集 (Term Set)**：
    我们选择一个最简单的非空切片闭包集 $S$。令 $S = \{a, b\}$。
    -   **切片闭包性检查**:
        -   $\mathsf{Slice}(a) = \{a\} \subseteq S$。
        -   $\mathsf{Slice}(b) = \{b\} \subseteq S$。
    -   该集合 $S$ 是切片闭包的。

3.  **构建超图模型 $H=(V, E)$**:
    -   **顶点集 $V$**: $V = S = \{a, b\}$。
    -   **超边集 $E$**:
        -   $E_{\mathsf{comp}}$: 因为 $a, b$ 都是原子，我们加入两条边：$(a, \emptyset)$ 和 $(b, \emptyset)$。
        -   $E_{\mathsf{slice}}$:
            -   对于 $a \in V$, $\mathsf{Slice}(a) = \{a\}$, 加入边 $(a, \{a\})$。
            -   对于 $b \in V$, $\mathsf{Slice}(b) = \{b\}$, 加入边 $(b, \{b\})$。
        -   $E_{\mathsf{def}}$: $S$ 中没有定义项 `(t₁ := t₂)`，所以该边集为空。
    -   总的边集 $E = \{ (a, \emptyset), (b, \emptyset), (a, \{a\}), (b, \{b\}) \}$。

#### **5.2.2 在模型中寻找不可达路径**

现在我们考察模型 $H$ 中从顶点 $a$ 到顶点 $b$ 的路径。

-   从顶点 $a$ 出发的边只有两条：$(a, \emptyset)$ 和 $(a, \{a\})$。
-   前者没有尾顶点，无法通向任何其他顶点。
-   后者通向的唯一顶点是 $a$ 自身（形成一个自环）。
-   因此，在模型 $H$ 中，不存在任何从 $a$ 出发能够到达 $b$ 的路径。

这意味着，$R_H(a, b)$ 在我们构造的这个模型中是**假**的。

#### **5.2.3 得出结论**

1.  我们成功地构建了一个有效的超图模型 $H$。
2.  在该模型中，我们找到了两个顶点 $a, b$ 使得 $R_H(a, b)$ 为假。
3.  根据系统的**可靠性** (Soundness)，如果 `R(a, b)` 在形式系统中是可证明的，那么 $R_H(a, b)$ 必须为真。
4.  由（2）和（3）产生矛盾。因此，`R(a, b)` 在形式系统中是**不可证明的**。

既然我们已经找到了一个不可证明的依赖关系命题，这就证明了该形式系统不是平凡的（即它不能推导出所有合法的陈述）。

**故，该形式系统是非平凡一致的。**

---

## **6. 元理论性质的形式化**

本节在上文定义的形式系统基础上，引入并形式化定义了四种关于项的元理论性质。

#### **定义 6.1：恰当解释 (Appropriately Interpreted)**

一个项 $t \in \mathsf{Term}$ 被认为是有**恰当解释的 (Appropriately Interpreted)**，记作 $\mathsf{AI}(t)$，当且仅当该项的句法依赖链中包含至少一个定义项。
$$
\mathsf{AI}(t) \iff \exists u \in \mathsf{Term}. ((\exists s_1, s_2 \in \mathsf{Term}. u \equiv (s_1 := s_2)) \land R(t, u))
$$

#### **定义 6.2：括号歧义 (Parenthesis Ambiguous)**

一个项 $t \in \mathsf{Term}$ 是**括号歧义的 (Parenthesis Ambiguous)**，记作 $\mathsf{PA}(t)$，当且仅当它是一个元组项，并且存在至少两个字面上不相等的切片，它们各自都有恰当解释。
$$
\mathsf{PA}(t) \iff (\exists n\ge 0, t_1,\dots,t_n. t \equiv (t_1,\dots,t_n)) \land (\exists s_1, s_2 \in \mathsf{Slice}(t). s_1 \not\equiv s_2 \land \mathsf{AI}(s_1) \land \mathsf{AI}(s_2))
$$

#### **定义 6.3：括号全歧义 (Fully Parenthesis Ambiguous)**

一个项 $t \in \mathsf{Term}$ 是**括号全歧义的 (Fully Parenthesis Ambiguous)**，记作 $\mathsf{FPA}(t)$，当且仅当它是一个元组项，并且其所有的切片都有恰当解释。
$$
\mathsf{FPA}(t) \iff (\exists n\ge 0, t_1,\dots,t_n. t \equiv (t_1,\dots,t_n)) \land (\forall s \in \mathsf{Slice}(t). \mathsf{AI}(s))
$$

#### **定义 6.4：统一括号全歧义 (Uniformly Fully Parenthesis Ambiguous)**

一个项 $t \in \mathsf{Term}$ 是**统一括号全歧义的 (Uniformly Fully Parenthesis Ambiguous)**，记作 $\mathsf{UFPA}(t)$，当且仅当它是一个元组项，并且存在一个定义项，该元组项的所有切片都句法地依赖于这同一个定义项。
$$
\mathsf{UFPA}(t) \iff (\exists n\ge 0, t_1,\dots,t_n. t \equiv (t_1,\dots,t_n)) \land (\exists u \in \mathsf{Term}. ((\exists s_1, s_2. u \equiv (s_1 := s_2)) \land (\forall s \in \mathsf{Slice}(t). R(s, u))))
$$

---

## **7. 案例研究：命题逻辑建模**

为了分析具体的逻辑规则，我们首先在本形式系统内对一个标准命题逻辑（以蕴含为唯一联结词）进行建模。

### **7.1 句法表示**
1.  **原子命题**: 命题逻辑中的原子命题 $p, q, \dots$ 由本系统的原子集 $A$ 中的元素 $p, q, \dots$ 表示。
2.  **逻辑联结词**: 蕴含联结词 `→` 由本系统中的一个特殊原子 $\mathsf{imp} \in A$ 表示。
3.  **命题公式**: 一个命题公式 $\phi \to \psi$ 被建模为一个三元组项 $(\mathsf{imp}, t_\phi, t_\psi)$，其中 $t_\phi, t_\psi$ 是分别对 $\phi, \psi$ 的建模项。
4.  **推理规则**: 将推理规则建模为元组。特别地，分离规则 (Modus Ponens) 的一个实例（从 $p$ 和 $p \to q$ 推出 $q$）被建模为项 $t_{MP}$：
    $$
    t_{MP} \equiv ( (p, (\mathsf{imp}, p, q)), q )
    $$

### **7.2 语义基础的建模**
我们将整个命题逻辑的语义基础（例如，真值表定义、赋值函数等）抽象地由一个定义项 $D_{Logic}$ 代表。
$$
D_{Logic} \equiv (\mathsf{Semantics} := \mathsf{TruthTables})
$$
其中 $\mathsf{Semantics}$ 和 $\mathsf{TruthTables}$ 是 $A$ 中的两个特殊原子。

### **7.3 建模公理**
为了将句法与语义关联起来，我们引入以下两条建模公理，它们断言任何合法的公式构造都依赖于逻辑系统的语义基础。
1.  **(MA-Atom)**: 对于任意原子命题 $p \in A$, $R(p, D_{Logic})$。
2.  **(MA-Comp)**: 对于任意项 $t_\phi, t_\psi \in \mathsf{Term}$, $R((\mathsf{imp}, t_\phi, t_\psi), D_{Logic})$。

---

## **8. 分离规则的性质分析**

本节的目标是证明代表分离规则的项 $t_{MP}$ 具有统一括号全歧义性质。

#### **定理 8.1**
代表分离规则的项 $t_{MP}$ 是统一括号全歧义的。
$$
\mathsf{UFPA}(t_{MP})
$$
#### **证明**

根据定义 6.4，我们需要证明：
$$
\exists u. ((\exists s_1, s_2. u \equiv (s_1 := s_2)) \land (\forall s \in \mathsf{Slice}(t_{MP}). R(s, u)))
$$

1.  **选择定义项**: 令 $u \equiv D_{Logic}$。根据其构造 $D_{Logic} \equiv (\mathsf{Semantics} := \mathsf{TruthTables})$，它是一个定义项。

2.  **枚举所有切片**: $t_{MP} \equiv ( (p, (\mathsf{imp}, p, q)), q )$。其顶层连续子序列集合 $\mathsf{Slice}(t_{MP})$ 包含以下三个项：
    *   $s_1 \equiv ((p, (\mathsf{imp}, p, q)))$
    *   $s_2 \equiv (q)$
    *   $s_3 \equiv ((p, (\mathsf{imp}, p, q)), q)$

3.  **对每个切片进行证明**: 我们的目标是证明对于 $i \in \{1,2,3\}$，均有 $R(s_i, D_{Logic})$。为使证明清晰，我们首先定义一个中间项 $t' \equiv (p, (\mathsf{imp}, p, q))$。

    *   **证明 $R(s_1, D_{Logic})$**:
        | 步骤 | 断言 | 理由 |
        | :--- | :--- | :--- |
        | (i) | $p$ 直接构成 $t'$ | $t' \equiv (p, (\mathsf{imp}, p, q))$ 的结构 |
        | (ii) | $R(t', p)$ | (i) 和 `(R-Comp)` |
        | (iii) | $R(p, D_{Logic})$ | 建模公理 `(MA-Atom)` |
        | (iv) | $R(t', D_{Logic})$ | (ii), (iii) 和 `(R-Trans)` |
        | (v) | $t'$ 直接构成 $s_1$ | $s_1 \equiv (t')$ 的结构 |
        | (vi) | $R(s_1, t')$ | (v) 和 `(R-Comp)` |
        | (vii) | $R(s_1, D_{Logic})$ | (vi), (iv) 和 `(R-Trans)` |

    *   **证明 $R(s_2, D_{Logic})$**:
        | 步骤 | 断言 | 理由 |
        | :--- | :--- | :--- |
        | (i) | $q$ 直接构成 $s_2$ | $s_2 \equiv (q)$ 的结构 |
        | (ii) | $R(s_2, q)$ | (i) 和 `(R-Comp)` |
        | (iii) | $R(q, D_{Logic})$ | 建模公理 `(MA-Atom)` |
        | (iv) | $R(s_2, D_{Logic})$ | (ii), (iii) 和 `(R-Trans)` |

    *   **证明 $R(s_3, D_{Logic})$**:
        | 步骤 | 断言 | 理由 |
        | :--- | :--- | :--- |
        | (i) | $t'$ 直接构成 $s_3$ | $s_3 \equiv (t', q)$ 的结构 |
        | (ii) | $R(s_3, t')$ | (i) 和 `(R-Comp)` |
        | (iii) | $R(t', D_{Logic})$ | 已于证明 $R(s_1, D_{Logic})$ 的步骤 (iv) 中证得 |
        | (iv) | $R(s_3, D_{Logic})$ | (ii), (iii) 和 `(R-Trans)` |

4.  **结论**: 我们已经成功找到了一个定义项 $D_{Logic}$，使得 $t_{MP}$ 的所有切片 $s \in \mathsf{Slice}(t_{MP})$ 都满足 $R(s, D_{Logic})$。因此，根据定义 6.4，$\mathsf{UFPA}(t_{MP})$ 成立。

**(证明完毕)**

---

## **9. 关于 UFPA 性质的定理 (Theorems Regarding the UFPA Property)**

本节将在前述形式系统的基础上，呈现并证明一系列关于统一括号全歧义 (UFPA) 性质的元理论定理。这些定理系统性地阐明了 UFPA 性质的内在层次、构造规则及其在句法结构中的传递性。

### **定理 9.1 (UFPA 的向下蕴含 / Implication Hierarchy)**

**陈述**: 任何具有统一括号全歧义 (UFPA) 性质的项，亦必然具有括号全歧义 (FPA) 性质。
$$
\forall t \in \mathsf{Term}. (\mathsf{UFPA}(t) \implies \mathsf{FPA}(t))
$$

**证明 (Proof)**:
我们采用直接证明法，假设 `UFPA(t)` 为真，并推导 `FPA(t)` 为真。

| 步骤  | 断言 | 理由 |
| :-- | :--- | :--- |
| 1. | $\mathsf{UFPA}(t)$ | 前提 (Assumption) |
| 2. | $(\exists n\ge 0, t_1,\dots,t_n. t \equiv (t_1,\dots,t_n)) \land (\exists u. ((\exists s_1, s_2. u \equiv (s_1 := s_2)) \land (\forall s \in \mathsf{Slice}(t). R(s, u))))$ | 定义 6.4 (UFPA) |
| 3. | $t$ 是一个元组项。 | 从 (2) 的第一个合取项 |
| 4. | $\exists u. (u \text{ 是定义项} \land (\forall s \in \mathsf{Slice}(t). R(s, u)))$ | 从 (2) 的第二个合取项 |
| 5. | 令 $u_0$ 为一个特定的定义项，满足 $\forall s \in \mathsf{Slice}(t). R(s, u_0)$。 | 存在量词实例化 (Existential Instantiation) 于 (4) |
| 6. | 目标：证明 $\mathsf{FPA}(t)$。根据定义 6.3，需证：$t \text{ 是元组} \land (\forall s \in \mathsf{Slice}(t). \mathsf{AI}(s))$。 | 定义 6.3 (FPA) |
| 7. | $t$ 是元组项已由 (3) 证得。 | |
| 8. | 需证：$\forall s \in \mathsf{Slice}(t). \mathsf{AI}(s)$。任取一任意切片 $s' \in \mathsf{Slice}(t)$。 | 全称量词引入的证明策略 (Universal Introduction) |
| 9. | $R(s', u_0)$ | 全称量词实例化 (Universal Instantiation) 于 (5)，令 $s=s'$ |
| 10. | `AI(s')` 的定义为 $\exists u'. (u' \text{ 是定义项} \land R(s', u'))$。 | 定义 6.1 (AI) |
| 11. | 令 $u' \equiv u_0$。我们已知 $u_0$ 是定义项 (来自 5) 且 $R(s', u_0)$ (来自 9)。 | |
| 12. | $\exists u'. (u' \text{ 是定义项} \land R(s', u'))$ 成立。故 $\mathsf{AI}(s')$ 成立。 | 存在量词引入 (Existential Introduction) |
| 13. | 因为 $s'$ 是 $\mathsf{Slice}(t)$ 中的任意元素，故 $\forall s \in \mathsf{Slice}(t). \mathsf{AI}(s)$ 成立。 | 全称量词概括 (Universal Generalization) 于 (8-12) |
| 14. | 结合 (7) 与 (13)，$\mathsf{FPA}(t)$ 的定义被满足。 | 合取引入 (Conjunction Introduction) |
| 15. | $\mathsf{UFPA}(t) \implies \mathsf{FPA}(t)$ | 条件证明 (Conditional Proof) |

**(证明完毕)**

---

### **定理 9.2 (层级区分 / Hierarchy Distinction)**

**陈述**: 存在项 $t$，使得该项具有 FPA 性质，但**不**具有 UFPA 性质。
$$
\exists t \in \mathsf{Term}. (\mathsf{FPA}(t) \land \neg \mathsf{UFPA}(t))
$$

**证明 (Proof)**:
我们通过构造一个具体的项和公理体系来证明此存在性命题。

1.  **构造**:
    *   令原子集 $A = \{a, b, d_1, v_1, d_2, v_2\}$。
    *   令定义项 $D_1 \equiv (d_1 := v_1)$ 和 $D_2 \equiv (d_2 := v_2)$。
    *   引入公理 (A1) $R(a, D_1)$ 和 (A2) $R(b, D_2)$。
    *   令考察项 $t \equiv (a, b)$。

2.  **证明 $\mathsf{FPA}(t)$**:
    *   (a) $t$ 是元组项，满足 FPA 定义的第一个条件。
    *   (b) $\mathsf{Slice}(t) = \{(a), (b), (a, b)\}$。我们需要对每个切片证明 $\mathsf{AI}$ 成立。
        *   **对于 $(a)$**:
            1. $R((a), a)$ `[规则 (R-Comp)]`
            2. $R(a, D_1)$ `[公理 (A1)]`
            3. $R((a), D_1)$ `[规则 (R-Trans) 应用于 1, 2]`
            4. 因为 $D_1$ 是定义项，故 $\mathsf{AI}((a))$ 成立。
        *   **对于 $(b)$**:
            1. $R((b), b)$ `[规则 (R-Comp)]`
            2. $R(b, D_2)$ `[公理 (A2)]`
            3. $R((b), D_2)$ `[规则 (R-Trans) 应用于 1, 2]`
            4. 因为 $D_2$ 是定义项，故 $\mathsf{AI}((b))$ 成立。
        *   **对于 $(a, b)$**:
            1. $R((a,b), a)$ `[规则 (R-Comp)]`
            2. $R(a, D_1)$ `[公理 (A1)]`
            3. $R((a,b), D_1)$ `[规则 (R-Trans) 应用于 1, 2]`
            4. 因为 $D_1$ 是定义项，故 $\mathsf{AI}((a,b))$ 成立。
    *   (c) 所有切片均满足 $\mathsf{AI}$，故 $\mathsf{FPA}(t)$ 成立。

3.  **证明 $\neg \mathsf{UFPA}(t)$**:
    *   (a) 采用反证法。假设 $\mathsf{UFPA}(t)$ 成立。
    *   (b) 根据定义，存在一个**单一的**定义项 $u_0$，使得 $\forall s \in \mathsf{Slice}(t). R(s, u_0)$。
    *   (c) 这意味着 $R((a), u_0)$, $R((b), u_0)$, $R((a,b), u_0)$ 必须同时成立。
    *   (d) 考虑 $R((b), u_0)$。在我们的公理体系和模型中，从 $b$ 出发的依赖路径只通向 $D_2$。若 $u_0 \not\equiv D_2$，则 $R(b, u_0)$ 不可证，从而 $R((b), u_0)$ 亦不可证（依赖于 (R-Comp) 和 (R-Trans)）。因此 $u_0$ 必须是 $D_2$。
    *   (e) 考虑 $R((a), u_0)$。同理，从 $a$ 出发的依赖路径只通向 $D_1$。若要此命题成立， $u_0$ 必须是 $D_1$。
    *   (f) 结论 (d) 和 (e) 要求 $u_0 \equiv D_1$ 且 $u_0 \equiv D_2$。但这与我们构造的 $D_1 \not\equiv D_2$ 矛盾。
    *   (g) 因此，不存在任何单一的定义项 $u_0$ 满足条件。假设 (a) 错误，$\neg \mathsf{UFPA}(t)$ 成立。

4.  **总结**: 我们已证明 $\mathsf{FPA}(t) \land \neg \mathsf{UFPA}(t)$，故定理得证。

**(证明完毕)**

---

### **定理 9.3 (UFPA 的切片遗传性 / Heredity over Slicing)**

**陈述**: 若项 $t$ 具有 UFPA 性质，则它的任何一个本身也是元组的切片 $s$，亦必然具有 UFPA 性质，且依赖于与 $t$ 相同的定义项。
$$
\forall t, s \in \mathsf{Term}. ( (\mathsf{UFPA}(t) \land s \in \mathsf{Slice}(t) \land s \text{ is a tuple}) \implies \mathsf{UFPA}(s) )
$$

**证明 (Proof)**:
采用直接证明法。

| 步骤  | 断言 | 理由 |
| :-- | :--- | :--- |
| 1. | $\mathsf{UFPA}(t) \land s \in \mathsf{Slice}(t) \land s \text{ is a tuple}$ | 前提 (Assumption) |
| 2. | 存在定义项 $u_0$，使得 $\forall s' \in \mathsf{Slice}(t). R(s', u_0)$。 | 从 (1) 的 $\mathsf{UFPA}(t)$ 部分及定义 6.4 |
| 3. | 目标：证明 $\mathsf{UFPA}(s)$。根据定义，需证：$s$ 是元组 $\land$ $\exists u. (u \text{ 是定义项} \land \forall s'' \in \mathsf{Slice}(s). R(s'', u))$。| 定义 6.4 (UFPA) |
| 4. | $s$ 是元组。 | 从 (1) 直接得出 |
| 5. | 我们选择 $u \equiv u_0$。$u_0$ 是定义项。 | 从 (2) |
| 6. | 需证：$\forall s'' \in \mathsf{Slice}(s). R(s'', u_0)$。任取一任意切片 $s'' \in \mathsf{Slice}(s)$。 | 全称量词引入的证明策略 |
| 7. | **引理**: 若 $s \in \mathsf{Slice}(t)$ 且 $s'' \in \mathsf{Slice}(s)$，则 $s'' \in \mathsf{Slice}(t)$。 | `Slice` 算子定义：顶层连续子序列的子序列仍为顶层连续子序列。 |
| 8. | $s'' \in \mathsf{Slice}(t)$。 | 从 (1) 的 $s \in \mathsf{Slice}(t)$，(6) 的 $s'' \in \mathsf{Slice}(s)$ 及 (7) 的引理 |
| 9. | $R(s'', u_0)$。 | 全称量词实例化于 (2)，令 $s' = s''$ |
| 10.| 因为 $s''$ 是 $\mathsf{Slice}(s)$ 中的任意元素，故 $\forall s'' \in \mathsf{Slice}(s). R(s'', u_0)$ 成立。 | 全称量词概括于 (6-9) |
| 11.| 结合 (4), (5) 与 (10)，$\mathsf{UFPA}(s)$ 的定义被满足。 | 合取引入 |

**(证明完毕)**

---

### **定理 9.4 (UFPA 的组合性 / Compositionality of UFPA)**

**陈述**: 若一系列项 $t_1, \dots, t_n$ 均相对于同一个定义项 $u$ 具有 UFPA 性质，则由它们构成的新元组 $T \equiv (t_1, \dots, t_n)$ 亦相对于该定义项 $u$ 具有 UFPA 性质。
$$
\forall n\ge1, t_1,\dots,t_n, u. ((\forall i \in \{1..n\}. \mathsf{UFPA}_u(t_i)) \implies \mathsf{UFPA}_u((t_1, \dots, t_n)))
$$
(其中 $\mathsf{UFPA}_u(t)$ 为 $\mathsf{UFPA}(t)$ 且其统一定义项为 $u$ 的简写。)

**证明 (Proof)**:
采用直接证明法。

| 步骤 | 断言 | 理由 |
| :-- | :--- | :--- |
| 1. | $\forall i \in \{1..n\}. \mathsf{UFPA}_u(t_i)$ | 前提 (Assumption) |
| 2. | $T \equiv (t_1, \dots, t_n)$ | 定义 |
| 3. | 目标：证明 $\mathsf{UFPA}_u(T)$。 | |
| 4. | $T$ 是一个元组项。 | 根据 (2) 的构造 |
| 5. | 需证：$\forall s \in \mathsf{Slice}(T). R(s, u)$。任取一任意切片 $s \in \mathsf{Slice}(T)$。 | 全称量词引入的证明策略 |
| 6. | 根据 `Slice` 定义，$s \equiv (t_i, \dots, t_j)$ 对于某 $1 \le i \le j \le n$。 | `Slice` 算子定义 |
| 7. | $R(s, t_i)$ | 规则 (R-Comp)，因 $t_i$ 是 $s$ 的直接构成部分 |
| 8. | $\mathsf{UFPA}_u(t_i)$ | 全称量词实例化于 (1) |
| 9. | $\forall s' \in \mathsf{Slice}(t_i). R(s', u)$ | 从 (8) 及 UFPA 定义 |
| 10.| $t_i \in \mathsf{Slice}(t_i)$ | 引理 2.1 |
| 11.| $R(t_i, u)$ | 全称量词实例化于 (9)，令 $s' = t_i$ |
| 12.| $R(s, u)$ | 规则 (R-Trans) 应用于 (7) 和 (11) |
| 13.| 因为 $s$ 是 $\mathsf{Slice}(T)$ 中的任意元素，故 $\forall s \in \mathsf{Slice}(T). R(s, u)$ 成立。 | 全称量词概括于 (5-12) |
| 14.| 结合 (4) 与 (13)，$\mathsf{UFPA}_u(T)$ 成立。 | UFPA 定义 |

**(证明完毕)**

---

### **定理 9.5 (UFPA 在子片段关系下的保持性 / Preservation under Sub-fragment Relation)**

**陈述**: 若项 $t$ 具有 UFPA 性质，且 $s$ 是 $t$ 的一个子片段 ($s \preccurlyeq t$) 并自身为元组，则 $s$ 亦具有 UFPA 性质，且依赖于与 $t$ 相同的定义项。
$$
\forall t, s, u. ((\mathsf{UFPA}_u(t) \land s \preccurlyeq t \land s \text{ is a tuple}) \implies \mathsf{UFPA}_u(s))
$$

**证明 (Proof)**:
对 $s \preccurlyeq t$ 的推导长度 $k$ 进行结构归纳。

*   **基础情况 ($k=1$)**:
    1.  `s ⊑ t` 的推导仅一步，必然是应用规则 `(I-Slice)`。
    2.  因此，$s \in \mathsf{Slice}(t)$。
    3.  此时前提变为 $\mathsf{UFPA}_u(t) \land s \in \mathsf{Slice}(t) \land s \text{ is a tuple}$。
    4.  根据**定理 9.3 (切片遗传性)**，可直接推导出 $\mathsf{UFPA}_u(s)$。
    5.  基础情况成立。

*   **归纳步骤**:
    1.  **归纳假设**: 对于所有推导长度小于 $k$ 的 $v \preccurlyeq w$，定理成立。
    2.  考虑一个推导长度为 $k$ 的 `s ⊑ t`，其最后一步必为规则 `(I-Trans)`。
    3.  因此，存在一个中间项 $v$，使得 $s \preccurlyeq v$ 和 $v \preccurlyeq t$ 的推导长度均小于 $k$。
    4.  我们已知 $\mathsf{UFPA}_u(t)$ 且 $v \preccurlyeq t$。
    5.  **情形分析**:
        *   **情形 A**: $v$ 是元组。
            *   应用归纳假设于 `v ⊑ t`：由 $\mathsf{UFPA}_u(t) \land v \preccurlyeq t \land v \text{ is a tuple}$，可得 $\mathsf{UFPA}_u(v)$。
            *   现在我们有 $\mathsf{UFPA}_u(v) \land s \preccurlyeq v \land s \text{ is a tuple}$。
            *   再次应用归纳假设于 `s ⊑ v`，可得 $\mathsf{UFPA}_u(s)$。
        *   **情形 B**: $v$ 不是元组 (原子或定义项)。
            *   由 `s ⊑ v` 及其推导结构，最终必有 $s \in \mathsf{Slice}(v')$ 对于某个 $v' \preccurlyeq v$。若 $v$ 是原子或定义项，`Slice(v) = {v}`，则 `s ≡ v`。
            *   这与前提 `s` 是元组而 `v` 不是元组相矛盾。故此情形不可能发生。
    6.  归纳步骤成立。

**结论**: 通过结构归纳，定理得证。

**(证明完毕)**

---

### **定理 9.6 (UFPA 的句法域限制 / Syntactic Domain Restriction)**

**陈述**: 一个项 $t$ 具有 UFPA 性质的充要条件是，该项为一个元组项且满足统一依赖条件。因此，原子项和定义项不具有 UFPA 性质。
$$
\forall t \in \mathsf{Term}. ((t \text{ is an atom} \lor t \text{ is a definition}) \implies \neg \mathsf{UFPA}(t))
$$

**证明 (Proof)**:
该证明是 UFPA 定义的直接推论。

1.  根据定义 6.4，$\mathsf{UFPA}(t)$ 的形式化陈述为：
    $$
    (\exists n\ge 0, t_1,\dots,t_n. t \equiv (t_1,\dots,t_n)) \land (\dots)
    $$
2.  该定义的第一个合取项 $(\exists n\ge 0, t_1,\dots,t_n. t \equiv (t_1,\dots,t_n))$ 是对“$t$ 是一个元组项”的精确表述。
3.  根据合取范式的逻辑，若第一个合取项为假，则整个命题 $\mathsf{UFPA}(t)$ 为假。
4.  若 $t$ 是一个原子项 $a$，则 $a \not\equiv (t_1, \dots, t_n)$ 对于任何 $t_i$ 和 $n$ 均成立，因为它们的顶层构造子（原子 vs. $\mathrm{Tuple}_n$）不同。故第一个合取项为假。
5.  若 $t$ 是一个定义项 $(s_1 := s_2)$，则 $(s_1 := s_2) \not\equiv (t_1, \dots, t_n)$ 对于任何 $t_i$ 和 $n$ 均成立，因为它们的顶层构造子（$\mathrm{Def}$ vs. $\mathrm{Tuple}_n$）不同。故第一个合取项为假。
6.  因此，对于任何原子项或定义项 $t$，$\mathsf{UFPA}(t)$ 必为假。

**(证明完毕)**